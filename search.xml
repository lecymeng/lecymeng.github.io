<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>unRAID NAS Server Pro 6.8.1 快乐版</title>
      <link href="20200406/unraid-nas-server-pro-6.8.1-readme/"/>
      <url>20200406/unraid-nas-server-pro-6.8.1-readme/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="unRAID-NAS-Server-Pro-6-8-1-快乐版"><a href="#unRAID-NAS-Server-Pro-6-8-1-快乐版" class="headerlink" title="unRAID NAS Server Pro 6.8.1 快乐版"></a>unRAID NAS Server Pro 6.8.1 快乐版</h1><!--[unRAID NAS Server Pro 6.8.2 开心版](http://www.hopol.cn/2020/01/1510/)--><p>下载地址：<a href="https://mega.nz/folder/kv4w0YJA#YtT-Kr3lfa2zDPrEOpSEyw">MEGA</a></p><h2 id="解压后截图"><a href="#解压后截图" class="headerlink" title="解压后截图"></a>解压后截图</h2><p><img src="https://blog-1251678165.cos.ap-chengdu.myqcloud.com/Crms8X.jpg" alt="Crms8X"></p><h2 id="食用方式"><a href="#食用方式" class="headerlink" title="食用方式"></a>食用方式</h2><ul><li><p>将 U 盘格式化为 FAT32 格式，名称为：UNRAID</p></li><li><p>将解压出来的所有文件拷贝到 U 盘根目录下<br><img src="https://blog-1251678165.cos.ap-chengdu.myqcloud.com/VQXhuT.jpg" alt="VQXhuT"></p></li><li><p>用管理员权限运行 make_bootable.bat</p></li><li><p>将 U 盘插入设备并启动，正常引导之后会看到当前获取到的 IP。</p><a id="more"></a></li><li><p>我这里直接插入网线，上级有 DHCP 服务器，所以直接获取到局域网 IP。</p></li><li><p>浏览器输入 IP，默认打开的页面就能看到 Flash GUID，格式为 <code>XXXX-XXXX-XXXX-XXXXXXXXXXXX</code>，复制备用。<br><img src="https://blog-1251678165.cos.ap-chengdu.myqcloud.com/QhfdHI.jpg" alt="QhfdHI"></p></li><li><p>拔下引导 U 盘，插入 PC 端，输入如下命令格式：<code>keymaker XXXX-XXXX-XXXX-XXXXXXXXXXXX</code><br><img src="https://blog-1251678165.cos.ap-chengdu.myqcloud.com/cnIXF1.jpg" alt="cnIXF1"></p></li><li><p>中间有空格，生成一个 XXXX-XXXX-XXXX-XXXXXXXXXXXX.key 文件。</p></li><li><p>将这它重命名为：BTRS.key ，并拷贝到 U 盘 config 目录下</p></li><li><p>将引导 U 盘重新插入设备并开机，一切就结束了！！！<br><img src="https://blog-1251678165.cos.ap-chengdu.myqcloud.com/VarF2U.jpg" alt="VarF2U"></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> NAS </tag>
            
            <tag> Unraid </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>unRAID NAS Server Pro 6.7.2 快乐版</title>
      <link href="20200406/unraid-nas-server-pro-6.7.2-readme/"/>
      <url>20200406/unraid-nas-server-pro-6.7.2-readme/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="unRAID-NAS-Server-Pro-6-7-2-快乐版"><a href="#unRAID-NAS-Server-Pro-6-7-2-快乐版" class="headerlink" title="unRAID NAS Server Pro 6.7.2 快乐版"></a>unRAID NAS Server Pro 6.7.2 快乐版</h1><!--[unRAID NAS Server Pro 6.7.2 开心版](http://www.hopol.cn/2019/12/1475/)--><p>下载地址：<a href="https://mega.nz/folder/M7gQTYzT#75R708IKqoFkbz3bV4e9DQ">MEGA</a></p><h2 id="快乐方式一"><a href="#快乐方式一" class="headerlink" title="快乐方式一"></a>快乐方式一</h2><ul><li>下载 unRAIDServer-6.7.2-x86_64_K_fu11.7z 并解压</li><li>使用 Unraid.USB.Creator.Win32-1.6.exe U 盘制作工具</li><li>用制作好的 U 盘启动，并记录下 Flash GUID 信息备用</li></ul><p>然后申请试用。</p><ul><li>将 crack 目录下 的两个文件拷贝到 U 盘根目录下并覆盖</li><li>将 GUID 复制到 keymaker.exe 生成注册授权文件，保存到 U 盘 config 目录下</li><li>重新用 U 盘引导开机，查看右上角信息<a id="more"></a></li></ul><h2 id="快乐方式二"><a href="#快乐方式二" class="headerlink" title="快乐方式二"></a>快乐方式二</h2><ol><li>将 U 盘格式化为 FAT32 格式，名称为：UNRAID</li><li>下载 unRAIDServer-6.7.2-x86_64.7z 并解压，拷贝所有文件到 U 盘根目录下</li><li>用管理员权限运行 make_bootable.bat</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> NAS </tag>
            
            <tag> Unraid </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用FRP进行内网穿透</title>
      <link href="20200404/intranet-penetration-by-frp/"/>
      <url>20200404/intranet-penetration-by-frp/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="使用frp进行内网穿透"><a href="#使用frp进行内网穿透" class="headerlink" title="使用frp进行内网穿透"></a>使用frp进行内网穿透</h1><p>FRP项目地址：<a href="https://github.com/fatedier/frp">https://github.com/fatedier/frp</a><br>FRP中文说明：<a href="https://github.com/fatedier/frp/blob/master/README_zh.md">https://github.com/fatedier/frp/blob/master/README_zh.md</a></p><h2 id="frp是什么"><a href="#frp是什么" class="headerlink" title="frp是什么"></a>frp是什么</h2><p>简单地说:frp就是一个<a href="https://www.zhihu.com/question/24723688">反向代理软件</a>，它体积轻量但功能很强大，可以<strong>使处于内网或防火墙后的设备对外界提供服务</strong>，它支持 <strong>HTTP、TCP、UDP</strong>等众多协议。</p><h2 id="为什么需要内网穿透"><a href="#为什么需要内网穿透" class="headerlink" title="为什么需要内网穿透"></a>为什么需要内网穿透</h2><p><strong>从公网中访问自己的私有设备向来是一件难事儿。</strong><br>自己的主力台式机、NAS等等设备，它们可能处于路由器后，或者运营商因为IP地址短缺不给你分配公网IP地址。如果我们想直接访问到这些设备（远程桌面，远程文件，SSH等等），一般来说要通过一些转发或者P2P组网软件的帮助。<br>我有一台计算机位于一个很复杂的局域网中，我想要实现远程桌面和文件访问，目前来看其所处的网络环境很难通过简单的端口映射将其暴露在公网之中，我试过这么几种方法：</p><a id="more"></a><ol><li>远程桌面使用TeamViewer。可用，但需要访问端也拥有TeamViewer软件，不是很方便，希望能使用Windows自带的远程桌面。且TeamViewer不易实现远程文件访问。</li><li>使用蒲公英VPN软件进行组网，可用，但免费版本网络速度极慢，体验不佳，几乎无法正常使用。</li><li>使用花生壳软件进行DDNS解析，可用，但同第二点所述，免费版本有带宽限制，无法实际使用。</li><li><strong>搭建frp服务器进行内网穿透，可用且推荐，可以达到不错的速度，且理论上可以开放任何想要的端口，可以实现的功能远不止远程桌面或者文件共享。</strong></li></ol><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>搭建一个完整的frp服务链，我们需要</p><ol><li>VPS一台（也可以是具有公网IP的实体机）</li><li>访问目标设备（就是你最终要访问的设备，例如：PC，NAS，路由器）</li><li>简单的Linux基础（会用cp等几个简单命令即可）</li></ol><h3 id="VPS相关"><a href="#VPS相关" class="headerlink" title="VPS相关"></a>VPS相关</h3><ul><li>因为frp的原理是利用服务端（所准备的VPS）进行转发，因而VPS的速度直接决定了之后连接的质量，请根据自己的需要选择相应主机配置。</li><li>本人使用了搬瓦工的洛杉矶机房，北京联通下测试速度也还过得去。</li><li>系统使用Ubuntu 16.04.5 x64，frp客户端和服务端本身同时均支持Linux和Windows，且配置方法一样，请根据实际环境自行测试，如果你是新建的VPS，那选择Ubuntu 16.04.5 x64就可以了。</li></ul><h2 id="服务端设置"><a href="#服务端设置" class="headerlink" title="服务端设置"></a>服务端设置</h2><p>SSH连接到VPS之后运行如下命令查看处理器架构，根据架构下载不同版本的frp</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@Weicools:/home# archx86_64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><p>这里选择的是Linux x86_64的版本：frp_0.32.1_linux_amd64.tar.gz</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 下载frp程序root@Weicools:/home# wget https://github.com/fatedier/frp/releases/download/v0.32.1/frp_0.32.1_linux_amd64.tar.gz# 解压root@Weicools:/home# tar -zxvf frp_0.32.1_linux_amd64.tar.gz# 改个名字root@Weicools:/home# cp -r frp_0.32.1_linux_amd64 frp# 进入frp程序目录root@Weicools:/home# cd frproot@Weicools:/home/frp# <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们只需要关注如下几个文件</p><ul><li>frps 服务端程序</li><li>frps.ini 服务端配置文件</li><li>frpc 客户端程序</li><li>frpc.ini 客户端配置文件</li></ul><h3 id="服务端配置"><a href="#服务端配置" class="headerlink" title="服务端配置"></a>服务端配置</h3><p>编辑frp服务端配置文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@Weicools:/home/frp# vim frps.ini<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>服务端配置文件内容根据需求自行配置，编辑完成后保存（vim保存如果不会请自行搜索）。</p><h4 id="简洁版本"><a href="#简洁版本" class="headerlink" title="简洁版本"></a>简洁版本</h4><pre class="line-numbers language-none"><code class="language-none">[common]                                                                                                                   bind_port = 7000token = 12345678<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="带Dashboard版本"><a href="#带Dashboard版本" class="headerlink" title="带Dashboard版本"></a>带Dashboard版本</h4><pre class="line-numbers language-none"><code class="language-none">[common]bind_port = 7000dashboard_port = 7500token = 12345678    dashboard_user = admindashboard_pwd = adminvhost_http_port = 10080vhost_https_port = 10443<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="配置注意事项"><a href="#配置注意事项" class="headerlink" title="配置注意事项"></a>配置注意事项</h4><ul><li><code>bind_port = 7000</code> 可以自行修改（如果没有必要，端口均可使用默认值），但要和接后面客户端配置文件中的 <code>bind_port</code> 相同，且服务端的7000端口需要放行，具体可以用宝塔面板（安全选项）进行设置，或者网上查询命令设置放行的方法。</li><li><code>dashboard_port</code> 是服务端仪表板的端口，若使用7500端口（需要放行），在配置完成服务启动后可以通过浏览器访问 x.x.x.x:7500 （其中x.x.x.x为VPS的IP）查看frp服务运行信息。</li><li><code>token</code> 是用于客户端和服务端连接的口令，请自行设置并记录，稍后会用到。</li><li><code>dashboard_user</code> 和 <code>dashboard_pwd</code> 表示打开仪表板页面登录的用户名和密码，自行设置即可。</li><li><code>vhost_http_port</code> 和 <code>vhost_https_port</code> 用于反向代理HTTP主机时使用，本文不涉及HTTP协议，因而照抄或者删除这两条均可。</li></ul><h3 id="运行frps服务端"><a href="#运行frps服务端" class="headerlink" title="运行frps服务端"></a>运行frps服务端</h3><p>配置完成服务端配置文件之后我们就可以运行frps的服务端了</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@Weicools:/home/frp# ./frps -c frps.ini<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果看到屏幕输出一下这样的内容，即表示运行正常，如果出现错误提示，请检查上面的步骤。</p><pre class="line-numbers language-none"><code class="language-none">2020/04/03 22:22:39 [I] [service.go:130] frps tcp listen on 0.0.0.0:70002020/04/03 22:22:39 [I] [service.go:172] http service listen on 0.0.0.0:100802020/04/03 22:22:39 [I] [service.go:193] https service listen on 0.0.0.0:104432020/04/03 22:22:39 [I] [service.go:216] Dashboard listen on 0.0.0.0:75002020/04/03 22:22:39 [I] [root.go:210] Start frps success<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时访问 <code>服务端IP:7500</code> 并使用自己设置的用户名密码登录，即可看到仪表板界面<br><img src="https://blog-1251678165.cos.ap-chengdu.myqcloud.com/FIRUx8.png" alt="frp服务端仪表板界面"></p><h3 id="服务端后台运行和自启"><a href="#服务端后台运行和自启" class="headerlink" title="服务端后台运行和自启"></a>服务端后台运行和自启</h3><h4 id="后台运行方法-nohup"><a href="#后台运行方法-nohup" class="headerlink" title="后台运行方法-nohup"></a>后台运行方法-nohup</h4><p>至此，我们的服务端仅运行在前台，如果Ctrl+C停止或者关闭SSH窗口后，frps均会停止运行，因而我们使用 <a href="https://ehlxr.me/2017/01/18/Linux-%E7%9A%84-nohup-%E5%91%BD%E4%BB%A4%E7%9A%84%E7%94%A8%E6%B3%95/">nohup命令</a>（nohup后台程序管理或关闭相关命令可自行查询资料）将其运行在后台。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@Weicools:/home/frp# nohup ./frps -c frps.ini &amp;# 或者root@Weicools:/home/frp# nohup ./frps -c frps.ini &gt;/dev/null 2&gt;&amp;1 &amp;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出如下内容即表示正常运行</p><pre class="line-numbers language-none"><code class="language-none">nohup: ignoring input and appending output to 'nohup.out'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此时可先使用 <code>Ctrl+C</code> 关闭 nohup，frps依然会在后台运行，使用 <code>jobs</code> 命令查看后台运行的程序，在结果中我们可以看到frps正在后台正常运行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@Weicools:/home/frp# jobs[1]+  Running    nohup ./frps -c frps.ini &amp;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>此时访问 x.x.x.x:7500 依然可以打开仪表板界面，至此，服务端即设置完成，就可以关闭SSH窗口了。</p><h4 id="后台运行方法-systemctl"><a href="#后台运行方法-systemctl" class="headerlink" title="后台运行方法-systemctl"></a>后台运行方法-systemctl</h4><h5 id="运行服务创建"><a href="#运行服务创建" class="headerlink" title="运行服务创建"></a>运行服务创建</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@Weicools:/home# vim /lib/systemd/system/frps.service<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>frps.service文件内容</p><pre class="line-numbers language-none"><code class="language-none">[Unit]Description=frps serviceAfter=network.target syslog.targetWants=network.target[Service]Type=simpleExecStart=/home/frp/frps -c /home/frp/frps.ini[Install]WantedBy=multi-user.target<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="启动后台服务"><a href="#启动后台服务" class="headerlink" title="启动后台服务"></a>启动后台服务</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@Weicools:/home# systemctl start frps<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="开启自启动"><a href="#开启自启动" class="headerlink" title="开启自启动"></a>开启自启动</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@Weicools:/home# systemctl enable frps<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="停止frp服务端"><a href="#停止frp服务端" class="headerlink" title="停止frp服务端"></a>停止frp服务端</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 先找到这个进程root@Weicools:/home# ps -aux|grep frp| grep -v greproot    22416  0.0  1.2 114188 12432 ?    Sl    2019   1:05 ./frps -c ./frps.ini# 然后kill -9 进程号root@Weicools:/home# kill -9 22416<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="客户端设置"><a href="#客户端设置" class="headerlink" title="客户端设置"></a>客户端设置</h2><p>根据设备的情况选择相应的frp程序进行<a href="https://github.com/fatedier/frp/releases">下载</a></p><p>Windows下下载和解压等步骤不再描述。假定你下载了 <code>frp_0.32.1_windows_amd64.zip</code>，将其解压在了D盘根目录下，并且将文件夹重命名为 <code>frp</code>。</p><p>用文本编辑器打开frpc.ini，与服务端类似，内容如下。</p><pre class="line-numbers language-none"><code class="language-none">[common]server_addr = x.x.x.xserver_port = 7000token = 12345678[RDP]type = tcplocal_ip = 127.0.0.1           local_port = 3389remote_port = 7001  [SMB]type = tcplocal_ip = 127.0.0.1local_port = 445remote_port = 7002<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>RDP即Remote Desktop 远程桌面，Windows的RDP默认端口是3389，协议为TCP，建议使用frp远程连接前，在局域网中测试好，能够成功连接后再使用frp穿透连接。</li><li>SMB即Windows文件共享所使用的协议，默认端口号445，协议TCP，本条规则可实现远程文件访问。</li></ol><p>其中common字段下的三项即为服务端的设置。</p><ul><li><code>server_addr</code> 为服务端IP地址，填入即可。</li><li><code>server_port</code> 为服务器端口，填入你设置的端口号即可，服务端配置的 <code>bind_port</code> 例如：7000</li><li><code>token</code> 是你在服务器上设置的连接口令，原样填入即可。</li></ul><h3 id="自定义规则"><a href="#自定义规则" class="headerlink" title="自定义规则"></a>自定义规则</h3><p>frp实际使用时，会按照端口号进行对应的转发，原理如下图所示。</p><p><img src="https://blog-1251678165.cos.ap-chengdu.myqcloud.com/gZRQkk.jpg" alt="gZRQkk"></p><p>上面 <code>frpc.ini</code> 的 <code>Remote Desktop</code> <code>SMB</code> 字段都是自己定义的规则，自定义端口对应时格式如下</p><pre class="line-numbers language-none"><code class="language-none">[xxx]type = tcplocal_ip = 127.0.0.1           local_port = 1234remote_port = 5678 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>[xxx]</code> 表示一个规则名称，自己定义，便于查询即可。</li><li><code>type</code> 表示转发的协议类型，有TCP和UDP等选项可以选择，如有需要请自行查询frp手册。</li><li><code>local_port</code> 是本地应用的端口号，按照实际应用工作在本机的端口号填写即可。</li><li><code>remote_port</code> 是该条规则在服务端开放的端口号，自己填写并记录即可。</li></ul><h3 id="运行frpc"><a href="#运行frpc" class="headerlink" title="运行frpc"></a>运行frpc</h3><p>配置完成frpc.ini后，就可以运行frpc了</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 使用命令提示符或Powershell进入该目录下cd D:\frp`# 执行./frpc -c frpc.ini<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行frpc程序，窗口中输出如下内容表示运行正常。</p><pre class="line-numbers language-none"><code class="language-none">2020/04/03 23:14:56 [I] [service.go:205] login to server success, get run id [2b65b4e58a5917ac], server udp port [0]2020/04/03 23:14:56 [I] [proxy_manager.go:136] [2b65b4e58a5917ac] proxy added: [rdp smb]2020/04/03 23:14:56 [I] [control.go:143] [smb] start proxy success2020/04/03 23:14:56 [I] [control.go:143] [rdp] start proxy success<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>不要关闭命令行窗口，此时可以在局域网外使用相应程序访问 x.x.x.x:xxxx （IP为VPS的IP，端口为自定义的remote_port）即可访问到相应服务。</p><h3 id="客户端后台运行及自启"><a href="#客户端后台运行及自启" class="headerlink" title="客户端后台运行及自启"></a>客户端后台运行及自启</h3><h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><p>frpc运行时始终有一个命令行窗口运行在前台，影响美观，我们可以使用一个批处理文件来将其运行在后台，而且可以双击执行，每次打开frpc不用再自己输命令了。<br>在任何一个目录下新建一个文本文件并将其重命名为<code>frpc.bat</code>，编辑，粘贴如下内容并保存。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">@echo offif "%1" == "h" goto beginmshta vbscript:createobject("wscript.shell").run("""%~nx0"" h",0)(window.close)&amp;&amp;exit:beginREMcd D:\frpfrpc -c frpc.iniexit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将cd后的路径更改为你的frpc实际存放的目录。</p><p>之后直接运行这个 <code>.bat</code> 文件即可启动frpc并隐藏窗口（可在任务管理器中退出）。<br>至于开机启动，把这个 .bat 文件直接扔进Windows的开机启动文件夹就好了)<br>至此，Windows客户端配置完成，之后就是你自己根据需要在frpc.ini后追加规则即可。</p><p>客户端启动后台运行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">nohup ./frpc -c frpc.ini &amp;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">nohup /mnt/user/moedata/frp/frpc -c /mnt/user/moedata/frp/frpc.ini &amp;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>客户端停止后台运行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ps -aux|grep frp| grep -v grep<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> NAS </tag>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用NPS进行内网穿透</title>
      <link href="20200316/intranet-penetration-by-nps/"/>
      <url>20200316/intranet-penetration-by-nps/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><h4 id="下载-NPS-程序安装"><a href="#下载-NPS-程序安装" class="headerlink" title="下载 NPS 程序安装"></a>下载 NPS 程序安装</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 运行如下命令，根据CPU架构，选择相应版本并进行下载wget https://github.com/ehang-io/nps/releases/download/v0.26.6/linux_amd64_server.tar.gz# 解压tar -zxvf linux_amd64_server.tar.gz# 文件夹改个名，方便使用cp -r linux_amd64_server nps_server# 进入nps_servercd nps_server# 开启Nps./nps start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><a id="more"></a><h4 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a>Docker 安装</h4><pre class="line-numbers language-none"><code class="language-none"># docker方式docker run -d --name npsserver --net=host -v /home/npsconf:/conf ffdfgdfg/nps<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="nps-conf-关键配置"><a href="#nps-conf-关键配置" class="headerlink" title="nps.conf 关键配置"></a>nps.conf 关键配置</h4><pre class="line-numbers language-none"><code class="language-none"># Public password, which clients can use to connect to the server# After the connection, the server will be able to open relevant ports and parse related domain names according to its own configuration file.public_vkey=abcdx#webweb_host=1.2.3.4web_username=UserNameweb_password=xzyweb_port = 8012<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@WeicoolsNAS:/mnt/user/moedata/#mkdir NpsClientroot@WeicoolsNAS:/mnt/user/moedata/#cd NpsClientroot@WeicoolsNAS:/mnt/user/moedata/NpsClient#wget https://github.com/cnlh/nps/releases/download/v0.26.6/linux_amd64_client.tar.gzroot@WeicoolsNAS:/mnt/user/moedata/NpsClient#tar -zxvf linux_amd64_client.tar.gz# 临时运行测试root@WeicoolsNAS:/mnt/user/moedata/NpsClient#./npc -server=104.36.64.74:8024 -vkey=weicools@2233 -type=tcp# 后台运行root@WeicoolsNAS:/mnt/user/moedata/NpsClient#nohup ./npc -server=weicools.tk:8024 -vkey=weicools@2233 -type=tcpnohup ./npc -server=weicools.tk:8024 -vkey=weicools@12138 -type=tcpnohup ./npc -server=104.36.64.74:8024 -vkey=weicools@2233 -type=tcpnohup ./npc -server=104.36.64.74:8024 -vkey=weicools@12138 -type=tcp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="NPS-开机自启"><a href="#NPS-开机自启" class="headerlink" title="NPS 开机自启"></a>NPS 开机自启</h3><h4 id="群晖"><a href="#群晖" class="headerlink" title="群晖"></a>群晖</h4><blockquote><p><a href="https://www.jianshu.com/p/2f4d13636e38">https://www.jianshu.com/p/2f4d13636e38</a></p></blockquote><pre class="line-numbers language-none"><code class="language-none">Weicools@WeicoolsSyno:~$ sudo -ivi /usr/syno/etc.defaults/rc.sysv/autonps.shinput: /var/services/homes/Weicools/NpsClient/./npc -server=weicools.tk:8024 -vkey=weicools@12138 -type=tcpvi /etc/rcinput(:$):# Auto start nps client/usr/syno/etc.defaults/rc.sysv/autonps.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Unraid"><a href="#Unraid" class="headerlink" title="Unraid"></a>Unraid</h4><p><a href="https://www.vediotalk.com/archives/4184">https://www.vediotalk.com/archives/4184</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> NAS </tag>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>端口号占用解决方法</title>
      <link href="20200306/port-number-occupy-solution/"/>
      <url>20200306/port-number-occupy-solution/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="端口号占用解决方法"><a href="#端口号占用解决方法" class="headerlink" title="端口号占用解决方法"></a>端口号占用解决方法</h1><h2 id="Linux-端口号占用解决方法"><a href="#Linux-端口号占用解决方法" class="headerlink" title="Linux 端口号占用解决方法"></a>Linux 端口号占用解决方法</h2><h3 id="查询端口号"><a href="#查询端口号" class="headerlink" title="查询端口号"></a>查询端口号</h3><ol><li>使用<code>netstat</code>命令<br>netstat -tunlp 会显示所有端口和所有对应的程序，如果像得到自己关系的结果，可以使用 grep 对结果集进行过滤。例如：</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">netstat -tunlp | grep java<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样就能过滤出只带有 java 进程的所有端口被占用的情况。</p><a id="more"></a><ol start="2"><li>使用<code>lsof -i:某个端口</code></li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 查看22号端口被占用的程序lsof -i:22# 通过上述命令，可以查看到相应的进程号，如果还想查看该进程的详细信息可以使用：ps -ef | grep 进程号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="杀掉进程"><a href="#杀掉进程" class="headerlink" title="杀掉进程"></a>杀掉进程</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kill -9 PID号<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="windows-端口占用解决方法"><a href="#windows-端口占用解决方法" class="headerlink" title="windows 端口占用解决方法"></a>windows 端口占用解决方法</h2><p>查看所有的端口占用情况</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">netstat -ano<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查找指定端口的占用情况<br>例如查找 8080 端口：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">netstat -ano | findstr "8080"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过查找端口号就能找到相应的进程号，通过查找相应的进程号就能找到相应进程的详细信息<br>查看对应 PID 对应的进程</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tasklist | findstr "5555"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过 tasklist 可以列出具体的进程信息<br>通过进程名，停止进程</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">taskkill /f /t /im xxx.exetaskkill -PID &lt;进程号&gt; -F //强制关闭某个进程 ，例如：taskkill -PID 5555 -F<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Network </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android TabLayout</title>
      <link href="20200225/android-widget-tablayout/"/>
      <url>20200225/android-widget-tablayout/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Android-TabLayout"><a href="#Android-TabLayout" class="headerlink" title="Android TabLayout"></a>Android TabLayout</h1><h2 id="优雅地修改指示器宽度"><a href="#优雅地修改指示器宽度" class="headerlink" title="优雅地修改指示器宽度"></a>优雅地修改指示器宽度</h2><p>在开发过程中，经常会碰到把指示器的宽度，做的和文字宽度一样，或者比文字宽度还要短的设计。使用 TabLayout 我们可以快速实现一个 Material Design 风格的标签栏，但 TabLayout 的指示线 Indicator 默认是占满一格 Tab 的，且官方未直接提供修改 Indicator 宽度的方法。</p><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>如果你的项目中也有修改指示线宽度的需求，并且已经在网上找过修改方法，很可能你现在项目中用的就是这个方法。通过分析源码用反射实现的，代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void setIndicatorWidth(@NonNull final TabLayout tabLayout, final int margin) {    tabLayout.post(new Runnable() {        @Override        public void run() {            try {                Field mTabStripField = tabLayout.getClass().getDeclaredField("mTabStrip");                mTabStripField.setAccessible(true);                LinearLayout mTabStrip = (LinearLayout) mTabStripField.get(tabLayout);                for (int i = 0; i &lt; mTabStrip.getChildCount(); i++) {                    View tabView = mTabStrip.getChildAt(i);                    Field mTextViewField = tabView.getClass().getDeclaredField("mTextView");                    mTextViewField.setAccessible(true);                    TextView mTextView = (TextView) mTextViewField.get(tabView);                    tabView.setPadding(0, 0, 0, 0);                    int width = mTextView.getWidth();                    if (width == 0) {                        mTextView.measure(0, 0);                        width = mTextView.getMeasuredWidth();                    }                    LinearLayout.LayoutParams params = (LinearLayout.LayoutParams) tabView.getLayoutParams();                    params.width = width;                    params.leftMargin = margin;                    params.rightMargin = margin;                    tabView.setLayoutParams(params);                    tabView.invalidate();                }            } catch (Exception e) {                e.printStackTrace();            }        }    });}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样做是在 28 以下没问题的，但如果把项目的 SDK 升级到 28 或以上，它就不再有效了，原因是 TabLayout 源码中的变量名修改了，所以代码也要改成这样：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void setIndicatorWidth(@NonNull final TabLayout tabLayout, final int margin) {    tabLayout.post(new Runnable() {        @Override        public void run() {            try {                Field slidingTabIndicatorField = tabLayout.getClass().getDeclaredField("slidingTabIndicator");                slidingTabIndicatorField.setAccessible(true);                LinearLayout mTabStrip = (LinearLayout) slidingTabIndicatorField.get(tabLayout);                for (int i = 0; i &lt; mTabStrip.getChildCount(); i++) {                    View tabView = mTabStrip.getChildAt(i);                    Field textViewField = tabView.getClass().getDeclaredField("textView");                    textViewField.setAccessible(true);                    TextView mTextView = (TextView) textViewField.get(tabView);                    tabView.setPadding(0, 0, 0, 0);                    int width = mTextView.getWidth();                    if (width == 0) {                        mTextView.measure(0, 0);                        width = mTextView.getMeasuredWidth();                    }                    LinearLayout.LayoutParams params = (LinearLayout.LayoutParams) tabView.getLayoutParams();                    params.width = width;                    params.leftMargin = margin;                    params.rightMargin = margin;                    tabView.setLayoutParams(params);                    tabView.invalidate();                }            } catch (Exception e) {                e.printStackTrace();            }        }    });}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过反射虽然可以实现，但是反射不够优雅，并且它有可能因为 SDK 的升级而失效。</p><h3 id="自定义-Tab"><a href="#自定义-Tab" class="headerlink" title="自定义 Tab"></a>自定义 Tab</h3><p>TabLayout 中的 Tab 是允许自定义的，但 Indicator 不属于 Tab。<br>所以有这样一种解决方案，把 Indicator 隐藏掉，然后在自定义 Tab 的布局中加入指示线。<br>我们可以通过把 Indicator 的颜色设为透明来隐藏它：</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>android.support.design.widget.TabLayout</span>    <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@+id/tab_layout<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">app:</span>tabIndicatorColor</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@android:color/transparent<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在代码中，当 Tab 添加完毕后，替换成自定义的 Tab：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">TabLayout.Tab tab = tabLayout.getTabAt(i);tab.setCustomView(R.layout.layout_tab);TextView tv = tab.getCustomView().findViewById(R.id.text_view);tv.setText(tab.getText());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>并且还需要监听 Tab 的切换，控制指示线的显示隐藏：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">tabLayout.addOnTabSelectedListener(new TabLayout.OnTabSelectedListener() {    @Override    public void onTabSelected(TabLayout.Tab tab) {        // TODO 刷新Tab    }    @Override    public void onTabUnselected(TabLayout.Tab tab) {        // TODO 刷新Tab    }    @Override    public void onTabReselected(TabLayout.Tab tab) { }});<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用这种方法，什么样式都能实现了。但有个缺点是: 在 Tab 切换的时候，没有了指示线的移动动画。</p><h3 id="Support-v28-属性配置"><a href="#Support-v28-属性配置" class="headerlink" title="Support v28+ 属性配置"></a>Support v28+ 属性配置</h3><p>如果你使用的 SDK 版本是 28 或以上，并且需要将 Indicator 的宽度修改成和文字宽度一样，那么太棒了，现在你只需要给 TabLayout 配置一个属性就好了：</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>android.support.design.widget.TabLayout</span>    <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@+id/tab_layout<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">app:</span>tabIndicatorFullWidth</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当 tabIndicatorFullWidth 取 false 的时候，Indicator 的宽度会和文字的宽度一样，但这也意味着，当不同 Tab 里的文字宽度不一样时，Indicator 的宽度也会不一样，像下面这样。</p><p>//todo 贴图</p><p>如果设计要求 Indicator 的宽度必须固定，或者宽度要比文字短，那我们还要接着找别的解决方案。</p><h3 id="使用-Drawable-样式"><a href="#使用-Drawable-样式" class="headerlink" title="使用 Drawable 样式"></a>使用 Drawable 样式</h3><p>这种方案可能是最优雅的解决方案，使用也特别简单。<br>Indicator 是允许我们设置 drawable 来自定义样式的，比如添加圆角什么的。但无论什么样式，Indicator 依然是占满 Tab 宽度的。没关系，我们把它的背景设成透明，包含一个固定宽度的 shape 就好了，像这样：</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>layer-list</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>shape</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>rectangle<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span> <span class="token attr-name"><span class="token namespace">android:</span>gravity</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>center<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>shape</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>size</span>                <span class="token attr-name"><span class="token namespace">android:</span>width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>16dp<span class="token punctuation">"</span></span>                <span class="token attr-name"><span class="token namespace">android:</span>height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>4dp<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>corners</span> <span class="token attr-name"><span class="token namespace">android:</span>radius</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>4dp<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>solid</span> <span class="token attr-name"><span class="token namespace">android:</span>color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@color/colorAccent<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>shape</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>item</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>layer-list</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后在布局文件中配置 tabIndicator 属性：</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!-- app:tabIndicator 需要升级Support库到v28 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>android.support.design.widget.TabLayout</span>    <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@+id/tab_layout<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">app:</span>tabIndicatorHeight</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>10dp<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">app:</span>tabIndicator</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@drawable/tab_indicator<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也可以在代码中设置：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">// setSelectedTabIndicator 需要升级Support库到v28tabLayout.setSelectedTabIndicator(R.drawable.tab_indicator);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>从上面这个例子还可以发现，使用这个方法，不仅可以在视觉上增加 Indicator 的左右边距，还可以增加它的上下边距。</p><p>好啦，其实就是配置一个 Drawable 文件这么简单。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Widget </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IADB 扩展</title>
      <link href="20200106/iadb/"/>
      <url>20200106/iadb/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="IADB-工具"><a href="#IADB-工具" class="headerlink" title="IADB 工具"></a>IADB 工具</h1><p>ADB 扩展工具</p><p>含义：i adb &amp;&amp; IA Debug Bridge<br>实现步骤：</p><ol><li>Shell 脚本：iadb.sh（调用 adb 命令）</li><li>二进制程序：iadb（使用 shc 封装成可执行程序）<a id="more"></a></li></ol><p><img src="https://blog-1251678165.cos.ap-chengdu.myqcloud.com/Ns2t4O.png"></p><h2 id="参数-1"><a href="#参数-1" class="headerlink" title="参数 1"></a>参数 1</h2><table><thead><tr><th>Param</th><th>AppName</th><th>PackageName</th></tr></thead><tbody><tr><td>sp</td><td>SpaceK</td><td>com.oneapp.max.cleaner.booster.cn</td></tr><tr><td>op</td><td>Optimizer-K</td><td>com.oneapp.max.cn</td></tr><tr><td>pp</td><td>PPP-K</td><td>com.oneapp.max.security.pro.cn</td></tr><tr><td>wa</td><td>Walk-K</td><td>Com.walk.sports.cn</td></tr></tbody></table><h2 id="参数-2"><a href="#参数-2" class="headerlink" title="参数 2"></a>参数 2</h2><table><thead><tr><th>Param</th><th>说明</th><th>使用</th></tr></thead><tbody><tr><td>rp</td><td>Revoke Permissions</td><td></td></tr><tr><td>rp-r</td><td>Revoke Permissions and Restart</td><td></td></tr><tr><td>uninstall</td><td>Uninstall App</td><td></td></tr><tr><td>kill</td><td>Kill App</td><td></td></tr><tr><td>start</td><td>Start App</td><td></td></tr><tr><td>restart</td><td>Restart App</td><td></td></tr><tr><td>clear</td><td>Clear App Data</td><td></td></tr><tr><td>clear-r</td><td>Clear App Data and&nbsp;Restart</td><td></td></tr></tbody></table><h3 id="Revoke-Permissions"><a href="#Revoke-Permissions" class="headerlink" title="Revoke Permissions"></a>Revoke Permissions</h3><h3 id="Revoke-Permissions-and-Restart"><a href="#Revoke-Permissions-and-Restart" class="headerlink" title="Revoke Permissions and Restart"></a>Revoke Permissions and Restart</h3><h3 id="Uninstall-App"><a href="#Uninstall-App" class="headerlink" title="Uninstall App"></a>Uninstall App</h3><pre class="line-numbers language-none"><code class="language-none">adb uninstall [-k] &lt;packagename&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><packagename> 表示应用的包名，-k 参数可选，表示卸载应用但保留数据和缓存目录</packagename></p><h3 id="Kill-App"><a href="#Kill-App" class="headerlink" title="Kill App"></a>Kill App</h3><h3 id="Start-App"><a href="#Start-App" class="headerlink" title="Start App"></a>Start App</h3><h3 id="Restart-App"><a href="#Restart-App" class="headerlink" title="Restart App"></a>Restart App</h3><h3 id="Clear-App-Data"><a href="#Clear-App-Data" class="headerlink" title="Clear App Data"></a>Clear App Data</h3><pre class="line-numbers language-none"><code class="language-none">adb shell pm clear &lt;packagename&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>&lt;packagename&gt;</code> 表示应用名包，这条命令的效果相当于在设置里的应用信息界面点击了「清除缓存」和「清除数据」</p><h3 id="Clear-App-Data-and-Restart"><a href="#Clear-App-Data-and-Restart" class="headerlink" title="Clear App Data and&nbsp;Restart"></a>Clear App Data and&nbsp;Restart</h3><p>脚本的好处是便捷、高效，拿起来就可以写，写完就能跑，都不用编译</p><p>但坏处也显而易见，一些敏感的、不想让外人知道的东西都是明文写在里面的，所以，在这推荐一款神奇的脚本封装程序——shc：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">brew install shc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>日常用法：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">shc -r -f /shellfile.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>运行成功后会在当前目录下生成两个文件：</p><pre class="line-numbers language-none"><code class="language-none">shellfile.sh.xshellfile.sh.c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>shellfile.sh.x</code>是脚本所对应的可执行程序</p><p><code>shellfile.sh.c</code>是<code>shellfile.sh.x</code>对应的 c 语言实现的源码</p><p>shc 根据脚本文件的第一行<code>#!/bin/bash</code>或其他 shell 将脚本翻译成相应的 c 源码并生成可执行程序。</p><p>但 shc 似乎无法识别 expect</p><p>封装后的脚本安全性会有所提高，但这也仅能防个君子，通过 gdb 或其他调试工具仍然能获得最初的源码</p><p>test adb</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Script </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Talk-With-Moe</title>
      <link href="20191222/talk-with-moe/"/>
      <url>20191222/talk-with-moe/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Talk-With-Me"><a href="#Talk-With-Me" class="headerlink" title="Talk With Me"></a>Talk With Me</h1><p>啦啦啦啦啦略略略略略啦啦啦啦啦略略略略略啦啦啦啦啦略略略略略啦啦啦啦啦略略略略略啦啦啦啦啦略略略略略，此处省略一万字……</p><a id="more"></a><h3 id="最高境界是：每一句都有聊下去的欲望"><a href="#最高境界是：每一句都有聊下去的欲望" class="headerlink" title="最高境界是：每一句都有聊下去的欲望"></a>最高境界是：每一句都有聊下去的欲望</h3><p>毕竟，和人尬聊，不是一件光彩的事，聊天过程中，请你们谨记</p><p>“三不”心法：</p><ul><li>不要跪舔</li><li>不要表白</li><li>不要玻璃心</li></ul><h3 id="朋友圈打造"><a href="#朋友圈打造" class="headerlink" title="朋友圈打造"></a>朋友圈打造</h3><p>在讲聊天之前，有一件很重要却又非常容易被忽视的事情——朋友圈打造。WHAT？</p><p>几乎每一个人添加好友之后，第一件事就是去翻看浏览对方的朋友圈。翻看完后，都会在心里给这个人打一个印象分。</p><p>可以说，朋友圈是我们社交的第二身份证。WHAT？？</p><h3 id="一、知己知彼"><a href="#一、知己知彼" class="headerlink" title="一、知己知彼"></a>一、知己知彼</h3><p>即“了解他是什么样的人，了解自己想成为什么样的人”。</p><p>最起码，你需要了解他的基本性格：<br>活泼开朗？<br>内敛羞涩？<br>沉默寡言？<br>风趣幽默？<br>睿智健谈？</p><p>一般情况下，他是什么类型的人，也决定了他<strong>对什么样的女子感兴趣</strong></p><p>了解了对方，你还需要知道自己想成为什么样的人。</p><p>不建议一个女生为了讨好男生，去伪装成他喜欢的样子，而失去自我。</p><p>一来你也装不了多久；<br>二来用你的个性去吸引他，比装出他喜欢的样子更能维持长久的感情。</p><h3 id="二、聊天方法论"><a href="#二、聊天方法论" class="headerlink" title="二、聊天方法论"></a>二、聊天方法论</h3><h4 id="1、节奏：循次渐近"><a href="#1、节奏：循次渐近" class="headerlink" title="1、节奏：循次渐近"></a>1、节奏：循次渐近</h4><p>聊天就是沟通，沟通就是你来我往的事情。</p><p>好多人，一激动起来就自嗨，唧唧哇哇说一大堆，问一大堆问题，这样会让人没有聊下去的欲望。</p><h4 id="2、气氛：语言轻快、舒服、幽默"><a href="#2、气氛：语言轻快、舒服、幽默" class="headerlink" title="2、气氛：语言轻快、舒服、幽默"></a>2、气氛：语言轻快、舒服、幽默</h4><p>一定要有表情包！x 3<br>什么表情包？要可爱、有趣、小暧昧！</p><h4 id="3、话题：要学会“冷读术”。"><a href="#3、话题：要学会“冷读术”。" class="headerlink" title="3、话题：要学会“冷读术”。"></a>3、话题：要学会“冷读术”。</h4><p>冷读他的基本信息：头像、昵称、个性签名，尤其是朋友圈！</p><p>还可以通过其他途径打听，以及他在聊天时透露的信息。</p><p>聊天最重要的还是从“兴趣”切入。</p><p>我总结了男女之间能聊的兴趣点大抵是这 5 个：</p><pre class="line-numbers language-none"><code class="language-none">运动、旅游、健身、美食、学习<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>聊工作行不行？<br>不建议聊太多工作，因为很多时候聊工作都在<code>抱怨</code>，而且很容易把聊天氛围聊成<code>商业会谈</code></p><p>另外，你朋友圈发的内容，他点赞或评论了，说明这个话题引起了他的注意。</p><h3 id="禁忌"><a href="#禁忌" class="headerlink" title="禁忌"></a>禁忌</h3><h4 id="不要聊不擅长的内容"><a href="#不要聊不擅长的内容" class="headerlink" title="不要聊不擅长的内容"></a>不要聊不擅长的内容</h4><p>很容易陷入尬聊</p><h4 id="不要一本正经的说废话"><a href="#不要一本正经的说废话" class="headerlink" title="不要一本正经的说废话"></a>不要一本正经的说废话</h4><p>说回他喜欢篮球，有些女生这样聊：运动挺好的／运动有益健康／多运动不错／你除了爱打篮球还爱做什么运动……</p><p>来来去去都是说这几句客套话</p><h3 id="学会拓展话题。这很重要！"><a href="#学会拓展话题。这很重要！" class="headerlink" title="学会拓展话题。这很重要！"></a>学会拓展话题。这很重要！</h3><p>还是说回他喜欢篮球，你可以这样聊：</p><p>篮球我是真不懂，不过以前读书我们班篮球倒是拿了年级第 2 名，反正我就跟着那些女生们一起傻傻的尖叫、鼓掌，哈哈哈哈哈哈 ／你打篮球时是不是也有一帮女粉丝啊？／你是 mvp 吗？／有机会带我去目睹一下你在球场上的英姿才行呐～<br>篮球我是真不懂，我比较喜欢打羽毛球，你会不会打？／哎呦，看来我遇到大神了！／大神求带！／pk 吗？赢了请你吃饭，敢不敢？<br>篮球我是真不懂，我运动细胞为零～我小时候……／你看起来很爱运动，我想我是因为一直没有一个好的教练带我才那么烂／老师求带！<br>……（记得要配合表情使用，可爱有趣的表情。）</p><p>聊天，不一定要局限于这个“话题的深度”，可以拓展“话题的广度”。<br>比如聊篮球不是一定要去哪场比赛谁输谁赢、哪个球星怎样，而是能从我们生活熟悉的场景切入去拓展。</p><h3 id="常用技巧"><a href="#常用技巧" class="headerlink" title="常用技巧"></a>常用技巧</h3><p>聊天技巧只不过是辅助工具，前提是要有一个真诚的心。</p><p>聊天的技巧非常非常多：讲故事，冷读，找共性，夸奖与请教，魅力值展示（让他追逐你），调戏，曲解，切断兴趣，借题发挥，寻找漏洞，破框架，推拉，情感过山车，列框架，惩罚，奖励……</p><p>我讲几点非常重要的内容！</p><h4 id="1-引起他的好奇心"><a href="#1-引起他的好奇心" class="headerlink" title="1. 引起他的好奇心"></a>1. 引起他的好奇心</h4><pre class="line-numbers language-none"><code class="language-none">讲故事：你：哈哈哈哈哈 你让我想起了一件事很有意思的事。男：什么事？你：我……<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>讲故事是你的加分项</strong>，是很好展示你魅力值的机会，让他对你又一个深入的了解。不一定是你多美多优秀，可以说是你很好玩，你对人对事的心态、观点和想法等等。</p><pre class="line-numbers language-none"><code class="language-none">冷读+切断兴趣+调戏：你：我发现你有三个优点。（冷读）男：说来看看你：我不（切断兴趣），要不你给我发一个红包，我就告诉你一个。（调戏，不是真的要，只是一种思路）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-建立亲和感"><a href="#2-建立亲和感" class="headerlink" title="2. 建立亲和感"></a>2. 建立亲和感</h4><p>找共性：<br>有意无意的透露出你跟他有共同点<br>比如你知道他喜欢健身，你偶尔发你健身的朋友圈；当他问你在干嘛，你说：“刚健身回来，最近有点小偷懒了，跟不上了。”</p><p>认同他<br>夸奖与请教、魅力值展示（让他追逐你）</p><h4 id="3-幽默缓解尴尬"><a href="#3-幽默缓解尴尬" class="headerlink" title="3. 幽默缓解尴尬"></a>3. 幽默缓解尴尬</h4><p>借题发挥：</p><pre class="line-numbers language-none"><code class="language-none">比如你跟他聊星座男：星座都是骗人的，还那么多人信。你：爱情也是骗人的，也那么多人谈呢。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>借机调侃：</p><pre class="line-numbers language-none"><code class="language-none">女：天天加班吗？男：没有，天天加班会猝死女：求生欲很强啊！！（如果你回“要注意身体”，那就很无趣了。）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>破框架：</p><pre class="line-numbers language-none"><code class="language-none">如果你说的东西，他不感兴趣或者沉默你：没关系，我知道你智商比较低，跟不上我。哈哈哈哈哈哈<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>曲解：</p><pre class="line-numbers language-none"><code class="language-none">当有人在大家面前猛夸你漂亮，你可以说：胖子的春天来了吗？）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="4-建立暧昧"><a href="#4-建立暧昧" class="headerlink" title="4. 建立暧昧"></a>4. 建立暧昧</h4><p>这是非常非常重要的一个内容！！这个内容里最重要的精髓在于：<strong>引导约会见面</strong></p><p>列框架+惩罚他：</p><pre class="line-numbers language-none"><code class="language-none">男：不好意思，昨晚睡着了，没看到信息。你：我还以为你打算失踪了呢+嘟嘴不满的表情男：不会啦你：以后睡前要说晚安，不如有人会瞎等的。（列框架）男：嗯，好的你：罚～得罚你……<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>奖励他：</p><pre class="line-numbers language-none"><code class="language-none">你帮我打游戏，赢了10局请你吃饭pk吗？赢了请你吃饭这么厉害？我不信，你要是真赢了，我请你吃饭。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>夸奖与请教：</p><pre class="line-numbers language-none"><code class="language-none">这么厉害！哇！大神求带！<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>魅力值展示（让他追逐你）：</p><pre class="line-numbers language-none"><code class="language-none">你展示魅力值时，当你发现他感兴趣或者夸赞你，你可以引导他追逐你。比如你去一个很漂亮的地方旅游，- 他说：不错哦，风景很漂亮，人更漂亮- 你可以说：是不是很漂亮，很值得一去哦～我计划下次去xx，要是有机会一起去玩啊！再比如他觉得你羽毛球打得很好- 你可以说：多打多练你也可以哦～下次约一次打咯<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>曲解：</p><pre class="line-numbers language-none"><code class="language-none">男：今天天气很好女：那当然，也不看看是跟谁出来<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>调戏+切断兴趣</p><pre class="line-numbers language-none"><code class="language-none">你：你看我在干嘛+美食图片+想不想吃男：想啊，打包女：想的美，不给，100一块<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>建立暧昧是非常非常重要的一个内容，一个个暧昧的种子种下，是为了接下来的<strong>开花结果</strong></p><h4 id="5-最后，主动结束话题"><a href="#5-最后，主动结束话题" class="headerlink" title="5. 最后，主动结束话题"></a>5. 最后，主动结束话题</h4><p>在聊的很嗨的时候，主动结束话题，让他一个晚上都意犹未尽，你就成功了。</p><p>特别注意 ⚠️ ：千万不要去争论、较真！ 这会显得你不好相处。</p><h3 id="不适用"><a href="#不适用" class="headerlink" title="不适用"></a>不适用</h3><p>厌烦，不搭理</p>]]></content>
      
      
      
        <tags>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android TextView</title>
      <link href="20181210/android-widget-textview/"/>
      <url>20181210/android-widget-textview/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Android-TextView"><a href="#Android-TextView" class="headerlink" title="Android TextView"></a>Android TextView</h1><h2 id="Autosizing-TextView"><a href="#Autosizing-TextView" class="headerlink" title="Autosizing TextView"></a>Autosizing TextView</h2><p>使用 Android 8.0（API 级别 26）及更高版本，可以让 <code>TextView</code>文本大小自动扩展或收缩，以根据其<code>TextView</code>特征和边界填充其布局 。此设置可以更轻松地使用动态内容优化不同屏幕上的文本大小。</p><p>Support Library 26.0 完全支持 <code>TextView</code>在 Android 8.0（API 级别 26）之前运行 Android 版本的设备上的自动调整功能。该库提供对 Android 4.0（API 级别 14）及更高版本的支持。该<code>android.support.v4.widget</code> 软件包含<code>TextViewCompat</code>以向后兼容方式访问功能的类</p><a id="more"></a><h3 id="设置-TextView-自动调整大小"><a href="#设置-TextView-自动调整大小" class="headerlink" title="设置 TextView 自动调整大小"></a>设置 TextView 自动调整大小</h3><p>可以使用框架或支持库以 <code>TextView</code>编程方式或以 XML 格式设置自动调整大小。要设置 XML 属性，还可以使用 Android Studio 中的“ <strong>属性”</strong>窗口。</p><p>有三种方法可以设置自动调整 <code>TextView</code>：<a href="https://developer.android.com/guide/topics/ui/look-and-feel/autosizing-textview#default">默认</a>, <a href="https://developer.android.com/guide/topics/ui/look-and-feel/autosizing-textview#granularity">粒度</a>, <a href="https://developer.android.com/guide/topics/ui/look-and-feel/autosizing-textview#preset-sizes">预设尺寸</a></p><p><strong>注</strong>：如果设置在一个 XML 文件自动调整大小，不建议使用值“WRAP_CONTENT”为 <code>layout_width</code>或<code>layout_height</code>的属性<code>TextView</code>。它可能会产生意外的结果。</p><h3 id="默认"><a href="#默认" class="headerlink" title="默认"></a>默认</h3><p>默认设置允许<code>TextView</code>在水平轴和垂直轴上均匀地自动调整刻度。</p><ul><li><p>要以 Code 方式定义默认设置，请调用 <code>setAutoSizeTextTypeWithDefaults(int autoSizeTextType) </code>方法。提供<code>AUTO_SIZE_TEXT_TYPE_NONE</code>关闭自动调整功能或<code>AUTO_SIZE_TEXT_TYPE_UNIFORM</code>均匀缩放水平轴和垂直轴。</p></li><li><p><strong>注</strong>：为统一缩放的默认尺寸<code>minTextSize = 12sp</code>， <code>maxTextSize = 112sp</code>以及 <code>granularity = 1px.</code></p></li><li><p>要在 XML 中定义默认设置，请使用<code>android</code>命名空间并将<code>autoSizeTextType</code>属性设置为<em>none</em>或 _uniform_。</p></li><li><pre><code class="xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;TextView    android:layout_width="match_parent"    android:layout_height="200dp"    android:autoSizeTextType="uniform" /&gt;<pre class="line-numbers language-none"><code class="language-none">#### 使用支持库- 要通过支持库以编程方式定义默认设置，请调用该`TextViewCompat.setAutoSizeTextTypeWithDefaults(TextView textview, int autoSizeTextType)` 方法。提供`TextView`窗口小部件的实例和其中一种文本类型，例如 `TextViewCompat.AUTO_SIZE_TEXT_TYPE_NONE`或`TextViewCompat.AUTO_SIZE_TEXT_TYPE_UNIFORM`。- 要通过支持库在 XML 中定义默认设置，请使用 `app`命名空间并将`autoSizeTextType` 属性设置为*none*或*uniform*。- ```xml  &lt;?xml version="1.0" encoding="utf-8"?&gt;  &lt;LinearLayout      xmlns:android="http://schemas.android.com/apk/res/android"      xmlns:app="http://schemas.android.com/apk/res-auto"      android:layout_width="match_parent"      android:layout_height="match_parent"&gt;    &lt;TextView        android:layout_width="match_parent"        android:layout_height="200dp"        app:autoSizeTextType="uniform" /&gt;  &lt;/LinearLayout&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></code></pre></li></ul><h3 id="粒度"><a href="#粒度" class="headerlink" title="粒度"></a>粒度</h3><p>可以定义最小和最大文本大小的范围以及指定每个步骤大小的维度。的 <code>TextView</code>均匀的最小和最大尺寸的属性之间的范围内的鳞片。每个增量按粒度属性中设置的步长进行。</p><ul><li>要以编程方式定义文本大小范围和维度，请调用该 <code>setAutoSizeTextTypeUniformWithConfiguration(int autoSizeMinTextSize, int autoSizeMaxTextSize, int autoSizeStepGranularity, int unit)</code> 方法。提供最大值，最小值，粒度值和任何<code>TypedValue</code>维度单位。</li><li>要在 XML 中定义一系列文本大小和维度，请使用<code>android</code>命名空间并设置以下属性：<ul><li>将 <a href="https://developer.android.com/reference/android/widget/TextView.html#attr_android:autoSizeText"><code>autoSizeText</code></a> 属性设置为<em>none</em>或<em>uniform</em>。<em>none</em> 是默认值，<em>uniform</em>可以 <code>TextView</code>在水平和垂直轴上<em>均匀</em>缩放。</li><li>设置<a href="https://developer.android.com/reference/android/widget/TextView.html#attr_android:autoSizeMinTextSize"><code>autoSizeMinTextSize</code></a>， <a href="https://developer.android.com/reference/android/widget/TextView.html#attr_android:autoSizeMaxTextSize"><code>autoSizeMaxTextSize</code></a>和<a href="https://developer.android.com/reference/android/widget/TextView.html#attr_android:autoSizeStepGranularity"><code>autoSizeStepGranularity</code></a> 属性以定义自动调整大小的维度 <code>TextView</code>。</li></ul></li><li><pre><code class="xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;TextView    android:layout_width="match_parent"    android:layout_height="200dp"    android:autoSizeTextType="uniform"    android:autoSizeMinTextSize="12sp"    android:autoSizeMaxTextSize="100sp"    android:autoSizeStepGranularity="2sp" /&gt;<pre class="line-numbers language-none"><code class="language-none">#### 使用支持库- 要通过支持库以编程方式定义文本大小范围和维度，请调用该`TextViewCompat.setAutoSizeTextTypeUniformWithConfiguration(int autoSizeMinTextSize, int autoSizeMaxTextSize, int autoSizeStepGranularity, int unit)` 方法。提供最大值，最小值，粒度值和任何`TypedValue`维度单位。- 要定义范围的文本大小，并通过支持库中的 XML 格式的尺寸，使用的`app`命名空间和设置 `autoSizeText`，`autoSizeMinTextSize`， `autoSizeMaxTextSize`，和 `autoSizeStepGranularity`布局 XML 文件中的属性。- ```xml  &lt;?xml version="1.0" encoding="utf-8"?&gt;  &lt;LinearLayout      xmlns:android="http://schemas.android.com/apk/res/android"      xmlns:app="http://schemas.android.com/apk/res-auto"      android:layout_width="match_parent"      android:layout_height="match_parent"&gt;    &lt;TextView        android:layout_width="match_parent"        android:layout_height="200dp"        app:autoSizeTextType="uniform"        app:autoSizeMinTextSize="12sp"        app:autoSizeMaxTextSize="100sp"        app:autoSizeStepGranularity="2sp" /&gt;  &lt;/LinearLayout&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></code></pre></li></ul><h3 id="预设尺寸"><a href="#预设尺寸" class="headerlink" title="预设尺寸"></a>预设尺寸</h3><p>预设尺寸允许您指定<code>TextView</code>自动调整文本大小时选择的所有值 。</p><ul><li>要使用预设大小以<code>TextView</code>编程方式设置自动调整大小 ，请调用该<code>setAutoSizeTextTypeUniformWithPresetSizes(int[] presetSizes, int unit)</code> 方法。为尺寸提供尺寸和任何<code>TypedValue</code> 尺寸单位的数组。</li><li>要使用预设大小设置 <code>TextView</code> XML 的自动调整大小，请使用<code>android</code>命名空间并设置以下属性：<ul><li>将<a href="https://developer.android.com/reference/android/widget/TextView.html#attr_android:autoSizeText"><code>autoSizeText</code></a> 属性设置为<em>none</em>或<em>uniform</em>。<em>none</em> 是默认值，<em>uniform</em>可以 <code>TextView</code>在水平和垂直轴上<em>均匀</em>缩放。</li><li>将<a href="https://developer.android.com/reference/android/widget/TextView.html#attr_android:autoSizePresetSizes"><code>autoSizePresetSizes</code></a> 属性设置 为预设大小的数组。要将数组作为资源访问，请在<code>res/values/arrays.xml</code> 文件中定义数组。</li></ul></li><li><pre><code class="xml">&lt;resources&gt;  &lt;array name="autosize_text_sizes"&gt;    &lt;item&gt;10sp&lt;/item&gt;    &lt;item&gt;12sp&lt;/item&gt;    &lt;item&gt;20sp&lt;/item&gt;    &lt;item&gt;40sp&lt;/item&gt;    &lt;item&gt;100sp&lt;/item&gt;  &lt;/array&gt;&lt;/resources&gt;<pre class="line-numbers language-none"><code class="language-none">- ```xml  &lt;?xml version="1.0" encoding="utf-8"?&gt;  &lt;TextView      android:layout_width="match_parent"      android:layout_height="200dp"      android:autoSizeTextType="uniform"      android:autoSizePresetSizes="@array/autosize_text_sizes" /&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></code></pre></li></ul><h4 id="使用支持库"><a href="#使用支持库" class="headerlink" title="使用支持库"></a>使用支持库</h4><ul><li>要使用预设大小<code>TextView</code>通过支持库以编程方式设置自动调整大小 ，请调用该<code>TextViewCompat.setAutoSizeTextTypeUniformWithPresetSizes(TextView textView, int[] presetSizes, int unit)</code> 方法。提供<code>TextView</code>类的实例，大小数组以及大小的任何<code>TypedValue</code>维度单位。</li><li>要使用预设大小<code>TextView</code>通过支持库设置 XML 的自动调整大小 ，请使用布局 XML 文件中的 <code>app</code>命名空间和 set <code>autoSizeText</code>和 <code>autoSizePresetSizes</code>attributes。</li><li><pre><code class="xml">&lt;resources&gt;  &lt;array name="autosize_text_sizes"&gt;    &lt;item&gt;10sp&lt;/item&gt;    &lt;item&gt;12sp&lt;/item&gt;    &lt;item&gt;20sp&lt;/item&gt;    &lt;item&gt;40sp&lt;/item&gt;    &lt;item&gt;100sp&lt;/item&gt;  &lt;/array&gt;&lt;/resources&gt;<pre class="line-numbers language-none"><code class="language-none">- ```xml  &lt;?xml version="1.0" encoding="utf-8"?&gt;  &lt;LinearLayout      xmlns:android="http://schemas.android.com/apk/res/android"      xmlns:app="http://schemas.android.com/apk/res-auto"      android:layout_width="match_parent"      android:layout_height="match_parent"&gt;    &lt;TextView        android:layout_width="match_parent"        android:layout_height="200dp"        app:autoSizeTextType="uniform"        app:autoSizePresetSizes="@array/autosize_text_sizes" /&gt;  &lt;/LinearLayout&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></code></pre></li></ul><h2 id="XML-中的字体"><a href="#XML-中的字体" class="headerlink" title="XML 中的字体"></a>XML 中的字体</h2><p>Android 8.0（API 级别 26）引入了一项新功能，即 XML 中的字体，它允许您将字体用作资源。您可以在<code>font</code>文件<code>res/font/</code>夹中添加文件以将字体捆绑为资源。这些字体在您的<code>R</code>文件中编译，并在 Android Studio 中自动提供。您可以借助新资源类型访问字体资源<code>font</code>。例如，要访问字体资源，请使用<code>@font/myfont</code>或<code>R.font.myfont</code>。</p><p>要在运行 Android 4.1（API 级别 16）及更高版本的设备上使用字体 XML 功能，请使用支持库 26.有关使用支持库的更多信息，请参阅 <a href="https://developer.android.com/guide/topics/ui/look-and-feel/fonts-in-xml#using-support-lib">使用支持库</a>部分。</p><p>要将字体添加为资源，请在 Android Studio 中执行以下步骤：</p><ol><li>右键单击 res 文件夹，然后转到“ 新建”&gt;“Android 资源目录”。将出现“ <em>新建资源目录”</em>窗口。</li><li>在“资源类型”列表中，选择“ 字体”，然后单击“ 确定”。<strong>注意</strong>：资源目录的名称必须是 <strong>font</strong></li></ol><p><img src="http://blog-1251678165.coscd.myqcloud.com/2018-12-27-055422.jpg" alt="图1添加字体资源目录"></p><ol start="3"><li>在字体文件夹中添加字体文件。下面的文件夹结构生成 <code>R.font.dancing_script</code>，<code>R.font.lobster</code>和 <code>R.font.typo_graphica</code>。</li></ol><p><img src="http://blog-1251678165.coscd.myqcloud.com/2018-12-27-055530.jpg" alt="在资源目录中添加字体文件"></p><ol start="4"><li>双击字体文件以在编辑器中预览文件的字体。</li></ol><p><img src="http://blog-1251678165.coscd.myqcloud.com/2018-12-27-055559.jpg" alt="预览字体文件"></p><h3 id="创建-font-family"><a href="#创建-font-family" class="headerlink" title="创建 font family"></a>创建 font family</h3><p>font family 是一组字体文件及其样式和重量详细信息。在 Android 中，您可以创建一个新的字体系列作为 XML 资源，并将其作为单个单元访问，而不是将每个样式和权重作为单独的资源引用。通过这样做，系统可以根据您尝试使用的文本样式选择正确的字体。</p><p>要创建字体系列，请在 Android Studio 中执行以下步骤：</p><ol><li><p>右键单击该<code>font</code>文件夹，然后转到“ <strong>新建”&gt;“字体资源文件”</strong>。将出现“ <em>新建资源文件”</em>窗口。</p></li><li><p>输入文件名，然后单击“ <strong>确定”</strong>。新的字体资源 XML 在编辑器中打开。</p></li><li><p>将每个字体文件，样式和权重属性包含在<code>&lt;font</code> 元素中。以下 XML 说明了在字体资源 XML 中添加与字体相关的属性：</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font-family</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font</span>        <span class="token attr-name"><span class="token namespace">android:</span>fontStyle</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>normal<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>fontWeight</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>400<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>font</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@font/lobster_regular<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font</span>        <span class="token attr-name"><span class="token namespace">android:</span>fontStyle</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>italic<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>fontWeight</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>400<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>font</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@font/lobster_italic<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>font-family</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="在-XML-布局中使用字体"><a href="#在-XML-布局中使用字体" class="headerlink" title="在 XML 布局中使用字体"></a>在 XML 布局中使用字体</h3><p>在<code>TextView</code>对象或样式中使用字体，可以是单个字体文件，也可以是字体系列中的字体。要<code>TextView</code>在样式中添加字体，请使用该 <code>fontFamily</code>属性。 <strong>注意：</strong>当您使用字体系列时， <code>TextView</code>交换机可以根据需要自行使用该系列中的字体文件。</p><h4 id="将字体添加到-TextView"><a href="#将字体添加到-TextView" class="headerlink" title="将字体添加到 TextView"></a>将字体添加到 TextView</h4><p>要为其设置字体<code>TextView</code>，请执行以下操作之一：</p><ul><li><p>在布局 XML 文件中，将<code>fontFamily</code>属性设置为要访问的字体文件。</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TextView</span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>fontFamily</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@font/lobster<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>Android Studio 布局预览（如图 5 最右侧窗格所示）允许您预览中的字体集<code>TextView</code>。</p><p><img src="http://blog-1251678165.coscd.myqcloud.com/2018-12-27-060116.jpg" alt="在布局预览中预览字体"></p><h4 id="将字体添加到-Style"><a href="#将字体添加到-Style" class="headerlink" title="将字体添加到 Style"></a>将字体添加到 Style</h4><p>打开<code>styles.xml</code>，并将<code>fontFamily</code> 属性设置为您要访问的字体文件。</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>customfontstyle<span class="token punctuation">"</span></span> <span class="token attr-name">parent</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@android:style/TextAppearance.Small<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>android:fontFamily<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>@font/lobster<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>item</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="在-Java-Kotlin-中使用字体"><a href="#在-Java-Kotlin-中使用字体" class="headerlink" title="在 Java/Kotlin 中使用字体"></a>在 Java/Kotlin 中使用字体</h3><p>要在 Java/Kotlin 中使用字体，请调用<code>getFont(int)</code>方法并提供要使用的字体 的资源标识符。此方法返回一个 <code>Typeface</code>对象。虽然系统从字体信息中为您选择最佳样式，但您可以使用该 <code>setTypeface(android.graphics.Typeface, int)</code> 方法设置具有特定样式的字体。</p><h4 id="Kotin"><a href="#Kotin" class="headerlink" title="Kotin"></a>Kotin</h4><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">val typeface = resources.getFont(R.font.myfont)textView.typeface = typeface<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">Typeface typeface = getResources().getFont(R.font.myfont);textView.setTypeface(typeface);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="使用支持库-1"><a href="#使用支持库-1" class="headerlink" title="使用支持库"></a>使用支持库</h3><p>Support Library 26.0 在运行 Android 4.1（API 级别 16）及更高版本的设备上提供对 XML 字体功能的支持。</p><p><strong>注意</strong>：通过支持库在 XML 布局中声明字体系列时，请使用<strong>app</strong>命名空间来确保加载字体</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font-family</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>app</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res-auto<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font</span> <span class="token attr-name"><span class="token namespace">app:</span>fontStyle</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>normal<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">app:</span>fontWeight</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>400<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">app:</span>font</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@font/myfont-Regular<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font</span> <span class="token attr-name"><span class="token namespace">app:</span>fontStyle</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>italic<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">app:</span>fontWeight</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>400<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">app:</span>font</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@font/myfont-Italic<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>font-family</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 Java/Kotlin 中使用字体，请调用 <code>ResourceCompat.getFont(Context, int)</code>方法并提供 Context 和资源标识符的实例。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Widget </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>比较合适的Hexo多设备同步方法</title>
      <link href="20181111/hexo-sync-onmultidevice/"/>
      <url>20181111/hexo-sync-onmultidevice/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="比较合适的-Hexo-多设备同步方法"><a href="#比较合适的-Hexo-多设备同步方法" class="headerlink" title="比较合适的 Hexo 多设备同步方法"></a>比较合适的 Hexo 多设备同步方法</h1><p>经常我们有一个场景：需要在公司或者家庭多个电脑完成 Hexo 的博客撰写和发布工作。这就涉及到 Hexo 多电脑的同步问题。</p><p>网上的方案基本上都是多分支方案，也就是在同一个仓库创建两个分支：</p><ol><li>Hexo 分支 – 用来保存所有 Hexo 的源文件</li><li>master 分支 – 用来保存 Hexo 生成的博客文件</li></ol><p>在创建 GitHub Pages 或者 Coding Pages 时，以 master 分支为 pages 分支。<br>Hexo 的 deploy 指向 master 分支部署 pages，git 的管理指向 Hexo 分支。</p><a id="more"></a><p>因为我的 GitHub Pages 对应的仓库是 public 的，所以会导致 Hexo 源文件暴露在公开的仓库了。这样也就会把我的博客的一些密钥、统计管理配置等暴露在公开仓库分支了。如果对这些配置的<code>_config.yml</code>进行单独管理的话，也很麻烦。</p><p>所以<strong>Hexo 最完美的多电脑同步方法</strong>是，创建两个仓库：</p><ol><li>Hexo 私有仓库 – 用来保存所有 Hexo 的源文件</li><li>master 公开仓库 – 用来保存 Hexo 生成的博客文件</li></ol><h2 id="我的-Blog-配置"><a href="#我的-Blog-配置" class="headerlink" title="我的 Blog 配置"></a>我的 Blog 配置</h2><ol><li>利用 hexo d 直接 deploy Hexo 博客到 GitHub pages</li><li>使用 hexo-theme-material 主题，并作了很多配置</li></ol><h2 id="创建远程私有仓库"><a href="#创建远程私有仓库" class="headerlink" title="创建远程私有仓库"></a>创建远程私有仓库</h2><p>我是在 Coding 上创建的（如果在 GitHub 可以创建 Private 仓库也可以在 GitHub 上创建）名字就叫 blog。</p><h2 id="建立本地-git-仓库"><a href="#建立本地-git-仓库" class="headerlink" title="建立本地 git 仓库"></a>建立本地 git 仓库</h2><p>进入你现有的本地 hexo 博客文件夹，先删除第三方主题的 git 配置，如对<code>hexo-theme-material</code>主题</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rm -fr ./themes/hexo-theme-material/.git/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后建立本地的 git 仓库</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建一个<code>.gitignore</code>文件，并放在 Hexo 的根目录，内容为：</p><pre class="line-numbers language-none"><code class="language-none">.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://blog-1251678165.cos.ap-chengdu.myqcloud.com/2018-11-11-055806.png"></p><h2 id="Push-到私有仓库"><a href="#Push-到私有仓库" class="headerlink" title="Push 到私有仓库"></a>Push 到私有仓库</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git remote add origin https://git.coding.net/&lt;yourname&gt;/blog.gitgit add .git commit -m "init my private hexo blog"git push -u origin master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>至此，就完成了本地 Hexo 源码的全备份</p><h2 id="在另一台电脑进行-Hexo-写作"><a href="#在另一台电脑进行-Hexo-写作" class="headerlink" title="在另一台电脑进行 Hexo 写作"></a>在另一台电脑进行 Hexo 写作</h2><p>首先和最开始使用 Hexo 一样，都有完成 git、node、hexo 等环境的搭建和配置</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">brew install gitbrew install nodebrew install npmnpm install hexo-cli -g<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="拉取-Hexo-blog"><a href="#拉取-Hexo-blog" class="headerlink" title="拉取 Hexo blog"></a>拉取 Hexo blog</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git clone https://git.coding.net/&lt;yourname&gt;/blog.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样你就拥有了你的所有 Hexo 源文件</p><h3 id="Hexo-编写和发布"><a href="#Hexo-编写和发布" class="headerlink" title="Hexo 编写和发布"></a>Hexo 编写和发布</h3><p>尽管拉取下来了，还需要建立一下 Hexo 的环境，这里需要格外注意的一点是：<br>千万不要用<code>hexo init</code>命令。原因是当前目录已经建立了 git 仓库环境, <code>hexo init</code>会覆盖到当前的 git 环境，重建一个新的，这样和我们的私有 Hexo 源码仓库脱离了联系。</p><p>正确的做法是：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo npm install<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因为<code>package.json</code>里面已经保存了<code>hexo</code>的必备资源包信息，<code>npm install</code>后 Hexo 环境就建立起来了。</p><p>如果需要更新 Hexo 版本或者插件版本，直接使用<code>npm update</code>即可，然后就可以看到 package.json 里面升级了哪些插件。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo npm update<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>接下来就进行正常的编写和发布就好。本地预览的命令还是：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo ghexo s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Hexo 的发布命令是<code>hexo d</code></p><p>最后执行<code>git status</code>把更改的新文件<code>git add</code>和<code>git commit</code>，最后<code>git push</code>到私有仓库，又会完成 Hexo 源码仓库的同步。</p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>从此，世界是如此的美好。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EventBus 源码解析</title>
      <link href="20180913/codeanalysis-eventbus/"/>
      <url>20180913/codeanalysis-eventbus/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="EventBus-源码解析"><a href="#EventBus-源码解析" class="headerlink" title="EventBus 源码解析"></a>EventBus 源码解析</h1><h2 id="EventBus-简介"><a href="#EventBus-简介" class="headerlink" title="EventBus 简介"></a>EventBus 简介</h2><p><a href="http://a.codekk.com/detail/Android/Trinea/EventBus%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"></a></p><p>EventBus 是 Android 端优化的 publish/subscribe 消息总线，简化了应用程序内各组件间、组件与后台线程的通信，主要由三个部分组成:</p><ul><li><p>事件 Event: 可以是任意对象，通过事件的发布者将事件进行传递</p></li><li><p>事件订阅者 Subscriber: 接收特定事件</p></li><li><p>事件发布者 Publisher: 用于通知 Subscriber 有事件发生，可以在任意线程任意位置发送事件</p><a id="more"></a><p><img src="https://blog-1251678165.cos.ap-chengdu.myqcloud.com/2018-11-13-142814.jpg"></p><p>上图解释了整个 EventBus 的大概工作流程：<code>发布者Publisher</code>将事件 Event 通过<code>post()方法</code>发送；EventBus 内部进行处理，找到订阅了该<code>事件Event</code>的<code>订阅者Subscriber</code>；然后该事件 Event 的订阅者 Subscriber 通过<code>onEvent()方法</code>接收事件进行相关处理（关于 onEvent()在 EventBus 3.0 中有改动，下面详细说明）</p></li></ul><h2 id="EventBus-简单使用"><a href="#EventBus-简单使用" class="headerlink" title="EventBus 简单使用"></a>EventBus 简单使用</h2><p>添加 EventBus 依赖到项目 <code>implementation 'org.greenrobot:eventbus:3.1.1'</code><br>构造事件（Event）对象。也就是发送消息类 每一个消息类，对应一种事件。这里我们定义两个消息发送类：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class NewsEvent {    private String message;    public NewsEvent(String message) {        this.message = message;    }    public String getMessage() {        return message;    }    public void setMessage(String message) {        this.message = message;    }}public class ToastEvent {    private String content;    public ToastEvent(String content) {        this.content = content;    }    public String getContent() {        return content;    }    public void setContent(String content) {        this.content = content;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注册/解除事件订阅（Subscriber）：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//一般在onCreate()方法中进行注册订阅。在onDestory()方法中进行解除订阅@Overrideprotected void onCreate() {    super.onCreate();    //注册事件 其中this代表订阅者    //通过register(this)来表示该订阅者进行了订阅    EventBus.getDefault().register(this);}@Overrideprotected void onDestroy() {    super.onDestroy();    //解除注册事件    EventBus.getDefault().unregister(this);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具体注册了对什么事件的订阅，这个需要 onEvent()方法来说明。在 EventBus 3.0 之前，onEvent()方法是用来接收指定事件（Event）类型对象，然后进行相关处理操作。在 EventBus 3.0 之后，onEvent()方法可以自定义方法名，不过要加入注解@Subscribe。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Subscribepublic void onToastEvent(ToastEvent event){//通过onToastEvent(ToastEvent event)表示指定对事件ToastEvent的订阅Toast.makeText(MainActivity.this,event.getContent(),Toast.LENGTH_SHORT).show();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>发送消息 订阅已经完成，那么便可以发送订阅了<code>EventBus.getDefault().post(new ToastEvent("Toast,发个提示，祝大家新年快乐！"));</code><br>那么 onToastEvent(ToastEvent event)会收到事件，并弹出提示，EventBus 的基础使用流程就是这样的。</p><h2 id="EventBus-进阶使用"><a href="#EventBus-进阶使用" class="headerlink" title="EventBus 进阶使用"></a>EventBus 进阶使用</h2><h3 id="线程模式-ThreadMode"><a href="#线程模式-ThreadMode" class="headerlink" title="线程模式 ThreadMode"></a>线程模式 ThreadMode</h3><p>当你接收的的事件后，如果处于非 UI 线程，你要更新 UI 怎么办？如果处于 UI 线程，你要进行耗时操作，怎么办?等等其他情况，通过 ThreadMode 统统帮你解决</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Subscribe(threadMode = ThreadMode.MainThread)public void  onNewsEvent(NewsEvent event){    String message = event.getMessage();    mTv_message.setText(message);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用起来很简单，通过@Subscribe(threadMode = ThreadMode.MainThread)即可指定。 下面具体介绍下 ThreadMode：</p><ol><li><strong>PostThread</strong>：事件的处理在和事件的发送在相同的进程，所以事件处理时间不应太长，不然影响事件的发送线程</li><li><strong>MainThread</strong>：事件的处理会在 UI 线程中执行。事件处理时间不能太长，这个不用说的，长了会 ANR 的</li><li><strong>BackgroundThread</strong>：如果事件是在 UI 线程中发布出来的，那么事件处理就会在子线程中运行，如果事件本来就是子线程中发布出来的，那么事件处理直接在该子线程中执行。所有待处理事件会被加到一个队列中，由对应线程依次处理这些事件，如果某个事件处理时间太长，会阻塞后面的事件的派发或处理</li><li><strong>Async</strong>：事件处理会在单独的线程中执行，主要用于在后台线程中执行耗时操作，每个事件会开启一个线程</li></ol><h3 id="priority-事件优先级"><a href="#priority-事件优先级" class="headerlink" title="priority 事件优先级"></a>priority 事件优先级</h3><p>事件的优先级类似广播的优先级，优先级越高优先获得消息，用法展示：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Subscribe(priority = 100)public void onToastEvent(ToastEvent event){    Toast.makeText(MainActivity.this, event.getContent(), Toast.LENGTH_SHORT).show();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>当多个订阅者（Subscriber）对同一种事件类型进行订阅时，即对应的事件处理方法中接收的事件类型一致，则优先级高（priority 设置的值越大），则<strong>会先接收事件进行处理；优先级低（priority 设置的值越小），则会后接收事件进行处理</strong></p><p>除此之外，EventBus 也可以终止对事件继续传递的功能，这样其他优先级比 100 低，并且订阅了该事件的订阅者就会接收不到该事件</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Subscribe(priority = 100)public void onToastEvent(ToastEvent event){    Toast.makeText(MainActivity.this, event.getContent(), Toast.LENGTH_SHORT).show();    //拦截事件    EventBus.getDefault().cancelEventDelivery(event);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="EventBus-黏性事件"><a href="#EventBus-黏性事件" class="headerlink" title="EventBus 黏性事件"></a>EventBus 黏性事件</h3><p>EventBus 除了普通事件也支持粘性事件。可以理解成：订阅在发布事件之后，但同样可以收到事件。订阅/解除订阅和普通事件一样，但是处理订阅的方法有所不同，需要注解中添加<code>sticky = true</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Subscribe(priority = 100, sticky = true)public void onToastEvent(ToastEvent event){    Toast.makeText(MainActivity.this, event.getContent(), Toast.LENGTH_SHORT).show();    //拦截事件    EventBus.getDefault().cancelEventDelivery(event);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样假设一个 ToastEvent 的事件已经发布，此时还没有注册订阅。当设置了 sticky = true，在 ToastEvent 的事件发布后，进行注册，依然能够接收到之前发布的事件。<br>不过这个时候，发布事件的方式就改变了：<code>EventBus.getDefault().postSticky(new ToastEvent("Toast,发个提示，祝大家新年快乐！"));</code><br>我们如果不再需要该粘性事件我们可以移除：<code>EventBus.getDefault().removeStickyEvent(ToastEvent.class);</code><br>或者调用移除所有粘性事件：<code>EventBus.getDefault().removeAllStickyEvents();</code></p><h3 id="EventBus-配置"><a href="#EventBus-配置" class="headerlink" title="EventBus 配置"></a>EventBus 配置</h3><p>EventBus 在 2.3 版本中添加了 EventBuilder 去配置 EventBus 的各方各面。比如：如何去构建一个在发布事件时没有订阅者时保持沉默的 EventBus。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">EventBus eventBus = EventBus.builder().logNoSubscriberMessages(false).sendNoSubscriberEvent(false).build();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>通过上述设置，当一个事件没有订阅者时，不会输出 log 信息，也不会发布一条默认信息。</p><p>配置默认的 EventBus 实例，使用 EventBus.getDefault()是一个简单的方法。获取一个单例的 EventBus 实例。EventBusBuilder 也允许使用 installDefaultEventBus 方法去配置默认的 EventBus 实例。</p><p>注意：不同的 EventBus 的对象的数据是不共享的。通过一个 EventBus 对象去发布事件，只有通过同一个 EventBus 对象订阅事件，才能接收该事件。所以以上使用 EventBus.getDefault()获得的都是同一个实例。</p><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><ol><li><p>注册订阅：<code>EventBus.getDefault().register(this);</code></p></li><li><p>事件处理</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Subscribe(threadMode = ThreadMode.MainThread)public void  onNewsEvent(NewsEvent event){    String message = event.getMessage();    mTv_message.setText(message);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>发布事件：<code>EventBus.getDefault().post(new NewsEvent("我是来自SecondActivity的消息，你好！"));</code></p></li></ol><p>以上是 EventBus 的基本使用。我们先从 getDefault 说起</p><h3 id="getDefault"><a href="#getDefault" class="headerlink" title="getDefault()"></a>getDefault()</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">static volatile EventBus defaultInstance;public static EventBus getDefault() {    if (defaultInstance == null) {        synchronized (EventBus.class) {            if (defaultInstance == null) {                defaultInstance = new EventBus();            }        }    }    return defaultInstance;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过上述代码可以得知，getDefault()中通过双检查锁（DCL）机制实现了 EventBus 的单例机制，获得了一个默认配置的 EventBus 对象</p><h3 id="register"><a href="#register" class="headerlink" title="register()"></a>register()</h3><p>在了解 register()之前，我们先要了解一下 EventBus 中的几个关键的成员变量。方便对下面内容的理解：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** Map&lt;订阅事件, 订阅该事件的订阅者集合&gt; */private final Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType;/** Map&lt;订阅者, 订阅事件集合&gt; */private final Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber;/** Map&lt;订阅事件类类型,订阅事件实例对象&gt;. */private final Map&lt;Class&lt;?&gt;, Object&gt; stickyEvents;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面看具体的 register()中执行的代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void register(Object subscriber) {    //订阅者类型    Class&lt;?&gt; subscriberClass = subscriber.getClass();    //判断该类是不是匿名类，如果是匿名累要使用反射    boolean forceReflection = subscriberClass.isAnonymousClass();    //获取订阅者全部的响应函数信息（即上面的onNewsEvent()之类的方法）    List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass, forceReflection);    //循环每一个事件响应函数，执行 subscribe()方法，更新订阅相关信息    for (SubscriberMethod subscriberMethod : subscriberMethods) {        subscribe(subscriber, subscriberMethod);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由此可见，register()第一步获取订阅者的类类型. 第二步,通过 SubscriberMethodFinder 类来解析订阅者类,获取所有的响应函数集合. 第三步,遍历订阅函数,执行 subscribe()方法，更新订阅相关信息。 关于 subscriberMethodFinder 这里就不介绍了。先跟着线索，继续看 subscribe()方法。</p><p>subscribe 函数分三步：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//第一步: 通过subscriptionsByEventType得到该事件类型所有订阅者信息队列，根据优先级将当前订阅者信息插入到订阅者队列subscriptionsByEventType中；//获取订阅的事件类型Class&lt;?&gt; eventType = subscriberMethod.eventType;//获取订阅该事件的订阅者集合CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);//把通过register()订阅的订阅者包装成Subscription 对象Subscription newSubscription = new Subscription(subscriber, subscriberMethod);//订阅者集合为空，创建新的集合，并把newSubscription 加入if (subscriptions == null) {  subscriptions = new CopyOnWriteArrayList&lt;Subscription&gt;();  subscriptionsByEventType.put(eventType, subscriptions);} else {  //集合中已经有该订阅者，抛出异常。不能重复订阅  if (subscriptions.contains(newSubscription)) {    throw new EventBusException(        "Subscriber " + subscriber.getClass() + " already registered to event " + eventType);  }}//把新的订阅者按照优先级加入到订阅者集合中。synchronized (subscriptions) {  int size = subscriptions.size();  for (int i = 0; i &lt;= size; i++) {    if (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) {      subscriptions.add(i, newSubscription);      break;    }  }}//第二步: 在typesBySubscriber中得到当前订阅者订阅的所有事件队列，将此事件保存到队列typesBySubscriber中，用于后续取消订阅//根据订阅者，获得该订阅者订阅的事件类型集合List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);//如果事件类型集合为空，创建新的集合，并加入新订阅的事件类型。if (subscribedEvents == null) {  subscribedEvents = new ArrayList&lt;Class&lt;?&gt;&gt;();  typesBySubscriber.put(subscriber, subscribedEvents);}//如果事件类型集合不为空，加入新订阅的事件类型subscribedEvents.add(eventType);//第三步: 检查这个事件是否是 Sticky 事件，如果是则从stickyEvents事件保存队列中取出该事件类型最后一个事件发送给当前订阅者//该事件是stick=true。if (subscriberMethod.sticky) {  //响应订阅事件的父类事件  if (eventInheritance) {    Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();    //循环获得每个stickyEvent事件    for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) {      Class&lt;?&gt; candidateEventType = entry.getKey();      //是该类的父类      if (eventType.isAssignableFrom(candidateEventType)) {        //该事件类型最新的事件发送给当前订阅者。        Object stickyEvent = entry.getValue();        checkPostStickyEventToSubscription(newSubscription, stickyEvent);      }    }  } else {    Object stickyEvent = stickyEvents.get(eventType);    checkPostStickyEventToSubscription(newSubscription, stickyEvent);  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>到此，便完成了订阅功能。下面是订阅的具体流程图：<br><img src="https://blog-1251678165.cos.ap-chengdu.myqcloud.com/2018-11-13-150526.jpg"></p><h3 id="unregister"><a href="#unregister" class="headerlink" title="unregister()"></a>unregister()</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public synchronized void unregister (Object subscriber){  // 获取该订阅者所有的订阅事件类类型集合.  List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber);  if (subscribedTypes != null) {    for (Class&lt;?&gt; eventType : subscribedTypes) {      unsubscribeByEventType(subscriber, eventType);    }    // 从typesBySubscriber删除该&lt;订阅者对象,订阅事件类类型集合&gt;    typesBySubscriber.remove(subscriber);  } else {    Log.e("EventBus", "Subscriber to unregister was not registered before: " + subscriber.getClass());  }}private void unsubscribeByEventType (Object subscriber, Class &lt; ?&gt;eventType){  // 获取订阅事件对应的订阅者信息集合.  List&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);  if (subscriptions != null) {    int size = subscriptions.size();    for (int i = 0; i &lt; size; i++) {      Subscription subscription = subscriptions.get(i);      // 从订阅者集合中删除特定的订阅者.      if (subscription.subscriber == subscriber) {        subscription.active = false;        subscriptions.remove(i);        i--;        size--;      }    }  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>unregister()方法比较简单，主要完成了 subscriptionsByEventType 以及 typesBySubscriber 两个集合的同步</p><h3 id="post"><a href="#post" class="headerlink" title="post()"></a>post()</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void post (Object event){  // 获取当前线程的Posting状态.  PostingThreadState postingState = currentPostingThreadState.get();  // 获取当前线程的事件队列.  List&lt;Object&gt; eventQueue = postingState.eventQueue;  //将当前事件添加到其事件队列  eventQueue.add(event);  //判断新加入的事件是否在分发中  if (!postingState.isPosting) {    postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper();    postingState.isPosting = true;    if (postingState.canceled) {      throw new EventBusException("Internal error. Abort state was not reset");    }    try {      // 循环处理当前线程eventQueue中的每一个event对象.      while (!eventQueue.isEmpty()) {        postSingleEvent(eventQueue.remove(0), postingState);      }    } finally {      // 处理完知乎重置postingState一些标识信息.      postingState.isPosting = false;      postingState.isMainThread = false;    }  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>post 函数会首先得到当前线程的 post 信息 PostingThreadState，其中包含事件队列，将当前事件添加到其事件队列中，然后循环调用 postSingleEvent 函数发布队列中的每个事件</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">private void postSingleEvent (Object event, PostingThreadState postingState) {  //分发事件的类型  Class&lt;?&gt; eventClass = event.getClass();  boolean subscriptionFound = false;  //响应订阅事件的父类事件  if (eventInheritance) {    //找出当前订阅事件类类型eventClass的所有父类的类类型和其实现的接口的类类型    List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass);    int countTypes = eventTypes.size();    for (int h = 0; h &lt; countTypes; h++) {      Class&lt;?&gt; clazz = eventTypes.get(h);      //发布每个事件到每个订阅者      subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);    }  } else {    subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);  }  //....................................}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调用 postSingleEventForEventType 函数发布每个事件到每个订阅者</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">private boolean postSingleEventForEventType (Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass) {  CopyOnWriteArrayList&lt;Subscription&gt; subscriptions;  synchronized (this) {    // 获取订阅事件类类型对应的订阅者信息集合.(register函数时构造的集合)    subscriptions = subscriptionsByEventType.get(eventClass);  }  if (subscriptions != null &amp;&amp; !subscriptions.isEmpty()) {    for (Subscription subscription : subscriptions) {      postingState.event = event;      postingState.subscription = subscription;      boolean aborted = false;      try {        // 发布订阅事件给订阅函数        postToSubscription(subscription, event, postingState.isMainThread);        aborted = postingState.canceled;      } finally {        postingState.event = null;        postingState.subscription = null;        postingState.canceled = false;      }      if (aborted) {        break;      }    }    return true;  }  return false;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调用 postToSubscription 函数向每个订阅者发布事件。 postToSubscription 函数中会判断订阅者的 ThreadMode，从而决定在什么 Mode 下执行事件响应函数。这里就不贴源码了。后续还牵着到反射以及线程调度问题，这里就不展开了。 以上就是 post 的流程，下面是具体的 post 的流程图:<br><img src="https://blog-1251678165.cos.ap-chengdu.myqcloud.com/2018-11-13-150953.jpg"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> SourceCode Analysis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Telegram 代理设置</title>
      <link href="20180514/telegram-proxy-method/"/>
      <url>20180514/telegram-proxy-method/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Telegram-代理设置"><a href="#Telegram-代理设置" class="headerlink" title="Telegram 代理设置"></a>Telegram 代理设置</h1><p>本次测试的是 Mac ShadowsocksX-NG + Telegram<br><img src="http://blog-1251678165.coscd.myqcloud.com/2018-05-14-064147.png"></p><h2 id="Shadowsocks"><a href="#Shadowsocks" class="headerlink" title="Shadowsocks"></a>Shadowsocks</h2><ol><li><a href="https://github.com/shadowsocks/ShadowsocksX-NG/releases">ShadowsocksX-NG</a></li><li>打开偏好设置，高级选项，查看 SOCKS5 端口<br><img src="http://blog-1251678165.coscd.myqcloud.com/2018-05-14-064557.png"><a id="more"></a></li></ol><h2 id="Telegram"><a href="#Telegram" class="headerlink" title="Telegram"></a>Telegram</h2><ol><li>打开 Settings–&gt;Privacy and Security–&gt;Use Proxy<br><img src="http://blog-1251678165.coscd.myqcloud.com/2018-05-14-064745.png"></li><li>复制地址和端口号<br><img src="http://blog-1251678165.coscd.myqcloud.com/2018-05-14-064948.png"></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Network </tag>
            
            <tag> Shadowsocks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git使用手册</title>
      <link href="20180112/git-manual/"/>
      <url>20180112/git-manual/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Git-使用手册"><a href="#Git-使用手册" class="headerlink" title="Git 使用手册"></a>Git 使用手册</h1><h2 id="Git-配置"><a href="#Git-配置" class="headerlink" title="Git 配置"></a>Git 配置</h2><h3 id="配置-Git-Config"><a href="#配置-Git-Config" class="headerlink" title="配置 Git Config"></a>配置 Git Config</h3><p>可以直接使用 https，方便代理，无需使用 ssh</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 配置UserName 和 Email$ git config --global user.name "lecymeng"$ git config --global user.email "1570682285@qq.com"$ mkdir .ssh$ cd ~/.ssh# 生成 RSA Key$ ssh-keygen -t rsa -C "1570682285@qq.com"Generating public/private rsa key pair.Enter file in which to save the key (/Users/weicools/.ssh/id_rsa): WeicoolsGitHubEnter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in WeicoolsGitHub.Your public key has been saved in WeicoolsGitHub.pub.weicools$ cat ~/.ssh/WeicoolsGitHub.pubxxx...xxx 1570682285@qq.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>复制 WeicoolsGitHub.pub 内容到 Git 上的 SSH key 配置中</p><h3 id="检查-Git-Config"><a href="#检查-Git-Config" class="headerlink" title="检查 Git Config"></a>检查 Git Config</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ git config --list$ git config user.name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="Git-项目创建和提交"><a href="#Git-项目创建和提交" class="headerlink" title="Git 项目创建和提交"></a>Git 项目创建和提交</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 创建一个项目hello-world$ mkdir ~/hello-world# 进入这个项目$ cd ~/hello-world# 初始化Git$ git init# new README文件$ touch README# add README文件$ git add README# 提交更新，并注释信息“first commit”$ git commit -m 'first commit'# 连接远程GitHub项目$ git remote add origin git@github.com:xxx/yyyy.git# 将本地项目更新到GitHub$ git push -u origin master# 后续提交 git push 即可$ git push<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p><a href="https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html">https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html</a></p><h2 id="Git-配置-Q-amp-A"><a href="#Git-配置-Q-amp-A" class="headerlink" title="Git 配置 Q &amp; A"></a>Git 配置 Q &amp; A</h2><h3 id="为仓库设置-Git-用户名"><a href="#为仓库设置-Git-用户名" class="headerlink" title="为仓库设置 Git 用户名"></a>为仓库设置 Git 用户名</h3><pre class="line-numbers language-zsh" data-language="zsh"><code class="language-zsh">$ git config user.name "name"$ git config user.email "email"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="绑定-Remote-Repository"><a href="#绑定-Remote-Repository" class="headerlink" title="绑定 Remote Repository"></a>绑定 Remote Repository</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ git remote set-url origin https://github.com/user/repository.git$ git branch --set-upstream-to origin/master master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="添加-Remote-Repository"><a href="#添加-Remote-Repository" class="headerlink" title="添加 Remote Repository"></a>添加 Remote Repository</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ git remote add origin https://github.com/user/repository.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="git-删除本地和远程文件"><a href="#git-删除本地和远程文件" class="headerlink" title="git 删除本地和远程文件"></a>git 删除本地和远程文件</h3><pre class="line-numbers language-zsh" data-language="zsh"><code class="language-zsh"># 删除文件：git rm 文件名# 删除文件夹：git rm -r 文件夹名# 注意# 要删除文件必须先添加到仓库才可以进行上述操作命令，因为git基于仓库进行操作# 删除文件夹时，文件夹不能为空，否则不能找到文件夹从而无法删除<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>工作过程中若误提交了文件到仓库上，比如<code>node_modules</code>,此时想只删除远程仓库文件，不删除本地文件，可使用下面命令</p><pre class="line-numbers language-zsh" data-language="zsh"><code class="language-zsh"># 只删除了仓库中的缓存，实际文件不会删除git rm --cached 文件(夹)git commit -m '备注'git push origin 分支<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Permission-denied-手动-add-RSA-密钥"><a href="#Permission-denied-手动-add-RSA-密钥" class="headerlink" title="Permission denied (手动 add RSA 密钥)"></a>Permission denied (手动 add RSA 密钥)</h3><p>如果输入 <code>$ ssh -T git@github.com</code> 出现错误提示：Permission denied (publickey). 因为新生成的 key 不能加入 ssh 就会导致连接不上 github。<br>解决办法：输入<code>$ ssh-add ~/.ssh/id_rsa</code>，再输入对应 SSH 密码即可</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ls -ah.      WeicoolsGitHub  config WeicoolsGitHub.pub  known_hosts$ ssh-add ~/.ssh/WeicoolsGitHub$ ssh -T git@github.comHi lecymeng! You've successfully authenticated, but GitHub does not provide shell access.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="恢复删除分支"><a href="#恢复删除分支" class="headerlink" title="恢复删除分支"></a>恢复删除分支</h3><p>当我们使用 git branch -D 删除一个本地分支后，怎样才能恢复呢？</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ 显示历史提交，找到分支对应的最后一笔提交的commit-idgit log -g# 以指定commit为基础创建分支$ git checkout -b {branch-name} {commit-id}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="ssh-add-相关问题"><a href="#ssh-add-相关问题" class="headerlink" title="ssh-add 相关问题"></a>ssh-add 相关问题</h3><p><a href="https://help.github.com/cn/github/authenticating-to-github/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent">生成新 SSH 密钥并添加到 ssh-agent</a><br><a href="https://help.github.com/cn/github/authenticating-to-github/error-permission-denied-publickey">错误：权限被拒绝（公钥）</a><br><a href="https://segmentfault.com/q/1010000000835302">Git 是否必须每次添加 ssh-add</a><br><a href="https://www.yangyanxing.com/article/config-local-ssh.html">配置多个 ssh 密钥对并且永久多 ssh 管理</a></p><h2 id="Fork-项目"><a href="#Fork-项目" class="headerlink" title="Fork 项目"></a>Fork 项目</h2><h3 id="在-GitHub-上-Fork"><a href="#在-GitHub-上-Fork" class="headerlink" title="在 GitHub 上 Fork"></a>在 GitHub 上 Fork</h3><p>参考 <a href="https://github.com/selfteaching/the-craft-of-selfteaching/issues/67">https://github.com/selfteaching/the-craft-of-selfteaching/issues/67</a></p><h3 id="GitHub-Fork-实践"><a href="#GitHub-Fork-实践" class="headerlink" title="GitHub Fork 实践"></a>GitHub Fork 实践</h3><p>以 <a href="https://github.com/material-components/material-components-android">material-components-android</a> 项目为例：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># Clone远程仓库$ git clone git@github.com:lecymeng/material-components-android.git# 查看远程仓库的路径$ git remote -vorigingit@github.com:lecymeng/material-components-android.git (fetch)origingit@github.com:lecymeng/material-components-android.git (push)# 设置Repository upstream$ git remote add upstream git@github.com:material-components/material-components-android.git# 查看远程仓库的路径$ git remote -vorigingit@github.com:lecymeng/material-components-android.git (fetch)origingit@github.com:lecymeng/material-components-android.git (push)upstreamgit@github.com:material-components/material-components-android.git (fetch)upstreamgit@github.com:material-components/material-components-android.git (push)# 抓取原仓库的更新git fetch upstream# 执行命令 git checkout master 切换到 master 分支git checkout master# 合并远程的master分支git merge upstream/master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="使用-SubModule"><a href="#使用-SubModule" class="headerlink" title="使用 SubModule"></a>使用 SubModule</h2><blockquote><p>参考：<br>imtianx: <a href="https://juejin.im/post/5aa11f486fb9a028e0140e34">Git 子模块</a><br>官方文档：<a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97">Git 工具 - 子模块</a></p></blockquote><p>工作中，可能会遇到<strong>在一个 Git 仓库 中添加 其他 Git 仓库的场景</strong>。比如，在项目中引用第三方库。或者在模块化开发中，某些公共的模块是需要单独维护的，使用单独的仓库比较方便，但是在项目中需要引用，就会出现这样的场景。这里使用 Git 的 <code>git submodule</code> 命令为一个 <code>git 项目</code> 添加 <code>子git项目</code></p><p>可以使用 <code>git submodule --help</code> 查看所有相关命令。 为了方便说明，这里在主项目 <code>MainProject</code> 中加两个子模块 <code>liba</code> 和 <code>libb</code> .</p><h3 id="1-添加子模块"><a href="#1-添加子模块" class="headerlink" title="1. 添加子模块"></a>1. 添加子模块</h3><p>进入 <code>MainProject</code> 使用 <strong>git submodule add</strong> 进行添加,操作命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ git clone https://github.com/imtianx/MainProject.gitcd MainProject/$ git submodule add https://github.com/imtianx/liba.git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如下图：<br><img src="https://blog-1251678165.cos.ap-chengdu.myqcloud.com/2019-03-14-071321.jpg"></p><p>使用 <code>git submodule add https://github.com/imtianx/libb.git</code> 添加 <code>libb</code> 子模块。 对于上图: 文件夹 <code>liba</code> 为新增加的子模块目录, <code>.gitmodules</code> 中存放的为子模块的信息，使用 <code>cat</code> 或 <code>vim</code> 查看内容为：</p><pre class="line-numbers language-none"><code class="language-none">[submodule "liba"]path = libaurl = https://github.com/imtianx/liba.git[submodule "libb"]path = libburl = https://github.com/imtianx/libb.git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>.gitmodules 文件</strong>：保存项目 URL 与已经拉取的本地目录之间的映射，有多个子模块则含有多条记录，会随着版本控制一起被拉去和推送的。</p></blockquote><p>此时文件目录树如下：</p><pre class="line-numbers language-none"><code class="language-none">.├── README.md├── liba│   ├── README.md│   ├── a.txt│   └── a2.txt├── libb│   ├── README.md│   ├── b.txt│   └── b2.txt└── test.text<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后，<strong>提交添加的子模块到主目录</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ git commit -m "add liba and libb submodules"[master 6b15e30] add liba and libb submodules 3 files changed, 8 insertions(+) create mode 100644 .gitmodules create mode 160000 liba create mode 160000 libb<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-更新子模块"><a href="#2-更新子模块" class="headerlink" title="2. 更新子模块"></a>2. 更新子模块</h3><p>往往子模块是单独开发的，这里以更新 <code>liba</code> 为例（为了测试，这里先在 liba 仓库添加了一个文件）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ cd liba$ git fetch$ git merge origin/master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>操作结果如下图，<strong>注意需要进入子模块目录</strong>：<br><img src="https://blog-1251678165.cos.ap-chengdu.myqcloud.com/2019-03-14-071321.jpg"></p><p>此外，还可以在主目录下 直接用下面的命令更新 <code>libb</code>子模块：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git submodule update --remote liba<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>使用下面的方式，更新 libb 的 dev 分支：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ git config -f .gitmodules submodule.libb.branch dev$ git submodule update --remote<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如下图：<br><img src="https://blog-1251678165.cos.ap-chengdu.myqcloud.com/2019-03-14-071531.jpg"></p><blockquote><p>这里对 <code>.gitmodules</code> 加了 <code>-f</code> 参数，修改提交后对所有用户有效。</p></blockquote><h3 id="3-删除子模块"><a href="#3-删除子模块" class="headerlink" title="3. 删除子模块"></a>3. 删除子模块</h3><p>在日常开发中，有添加，当然也会有删除 子模块的需求。 这里主项目包含两个子模块：<code>liba</code>、<code>libb</code>，以删除 <code>liba</code> 为例说明：</p><ul><li>使用 <code>git rm --cached liba</code> 将 liba 从版本控制中删除（本地仍保留有），若不需要可不带 <code>--cached</code>进行完全删除。</li><li>使用 <code>vim .gitmodules</code> 可打开 vim 编辑,删除对应的内容</li></ul><pre class="line-numbers language-none"><code class="language-none">[submodule "liba"]   path = liba   url = https://github.com/imtianx/liba.git   branch = dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>使用 <code>vim .git/config</code> 可打开 vim 编辑,删除对应的内容</li></ul><pre class="line-numbers language-none"><code class="language-none">[submodule "liba"]    url = https://github.com/imtianx/liba.git    active = true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>使用 <code>rm -rf .git/modules/liba</code>, 删除.git 下的缓存模块，最后提交项目。</li></ul><p>经过上面的删除后还可以进行添加子模块。</p><h3 id="4-克隆含子模块的仓库"><a href="#4-克隆含子模块的仓库" class="headerlink" title="4. 克隆含子模块的仓库"></a>4. 克隆含子模块的仓库</h3><p>若需要克隆含有子模块的仓库，直接 进行克隆是无法拉取之模块的代码，可加上 <strong>–recursive</strong> 参数，如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git clone --recursive https://github.com/imtianx/MainProject.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者使用下面的三部操作：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git clone  https://github.com/imtianx/MainProject.gitgit submodule initgit submodule update<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="Git-分支开发规范"><a href="#Git-分支开发规范" class="headerlink" title="Git 分支开发规范"></a>Git 分支开发规范</h2><blockquote><p>参考内容<br><a href="http://www.ruanyifeng.com/blog/2012/07/git.html">Git 分支管理策略</a> &gt; <a href="https://juejin.im/post/5b4328bbf265da0fa21a6820">您必须知道的 Git 分支开发规范</a> &gt; <a href="https://www.zhihu.com/question/21209619">如何写好 Git commit messages</a> &gt; <a href="https://segmentfault.com/a/1190000009048911">git commit 规范指南</a> &gt; <a href="https://stackoverflow.com/questions/3651860/which-characters-are-illegal-within-a-branch-name">Which characters are illegal within a branch name?</a></p></blockquote><p>Git 是目前最流行的源代码管理工具。 为规范开发，保持代码提交记录以及 git 分支结构清晰，方便后续维护，现规范 git 的相关操作。</p><p><img src="https://blog-1251678165.cos.ap-chengdu.myqcloud.com/PWAUoF.jpg"></p><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><h4 id="分支命名"><a href="#分支命名" class="headerlink" title="分支命名"></a>分支命名</h4><p><strong>master 分支</strong></p><ul><li>master 为主分支，也是用于部署生产环境的分支，确保 master 分支稳定性</li><li>master 分支一般由 develop 以及 hotfix 分支合并，任何时间都不能直接修改代码</li></ul><p><strong>develop 分支</strong></p><ul><li>develop 为开发分支，始终保持最新完成以及 bug 修复后的代码</li><li>一般开发的新功能时，feature 分支都是基于 develop 分支下创建的</li></ul><p><strong>feature 分支</strong></p><ul><li>开发新功能时，以 develop 为基础创建 feature 分支</li><li>分支命名: feature/ 开头的为特性分支， 命名规则: feature/user_module、 feature/cart_module</li></ul><p><strong>release 分支</strong></p><ul><li>release 为预上线分支，发布提测阶段，会 release 分支代码为基准提测</li></ul><pre class="line-numbers language-none"><code class="language-none">当有一组feature开发完成，首先会合并到develop分支，进入提测时，会创建release分支。如果测试过程中若存在bug需要修复，则直接由开发者在release分支修复并提交。当测试完成之后，合并release分支到master和develop分支，此时master为最新代码，用作上线。复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>hotfix 分支</strong></p><ul><li>分支命名: hotfix/ 开头的为修复分支，它的命名规则与 feature 分支类似</li><li>线上出现紧急问题时，需要及时修复，以 master 分支为基线，创建 hotfix 分支，修复完成后，需要合并到 master 分支和 develop 分支</li></ul><h4 id="常见任务"><a href="#常见任务" class="headerlink" title="常见任务"></a>常见任务</h4><p><strong>增加新功能</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">(dev)$: git checkout -b feature/xxx            # 从dev建立特性分支(feature/xxx)$: blabla                         # 开发(feature/xxx)$: git add xxx(feature/xxx)$: git commit -m 'commit comment'(dev)$: git merge feature/xxx --no-ff          # 把特性分支合并到dev复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>修复紧急 bug</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">(master)$: git checkout -b hotfix/xxx         # 从master建立hotfix分支(hotfix/xxx)$: blabla                         # 开发(hotfix/xxx)$: git add xxx(hotfix/xxx)$: git commit -m 'commit comment'(master)$: git merge hotfix/xxx --no-ff       # 把hotfix分支合并到master，并上线到生产环境(dev)$: git merge hotfix/xxx --no-ff          # 把hotfix分支合并到dev，同步代码复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>测试环境代码</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">(release)$: git merge dev --no-ff             # 把dev分支合并到release，然后在测试环境拉取并测试复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>生产环境上线</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">(master)$: git merge release --no-ff          # 把release测试好的代码合并到master，运维人员操作(master)$: git tag -a v0.1 -m '部署包版本名'  #给版本命名，打Tag复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://blog-1251678165.cos.ap-chengdu.myqcloud.com/9czDAj.jpg"></p><h3 id="日志规范"><a href="#日志规范" class="headerlink" title="日志规范"></a>日志规范</h3><blockquote><p>在一个团队协作的项目中，开发人员需要经常提交一些代码去修复 bug 或者实现新的 feature。而项目中的文件和实现什么功能、解决什么问题都会渐渐淡忘，最后需要浪费时间去阅读代码。但是好的日志规范 commit messages 编写有帮助到我们，它也反映了一个开发人员是否是良好的协作者。</p></blockquote><p><strong>编写良好的 Commit messages 可以达到 3 个重要的目的：</strong></p><ul><li>加快 review 的流程</li><li>帮助我们编写良好的版本发布日志</li><li>让之后的维护者了解代码里出现特定变化和 feature 被添加的原因</li></ul><p><strong>目前，社区有多种 Commit message 的写法规范。来自 Angular 规范是目前使用最广的写法，比较合理和系统化。如下图：</strong></p><p><img src="https://blog-1251678165.cos.ap-chengdu.myqcloud.com/UlbImQ.jpg"></p><h4 id="Commit-messages-的基本语法"><a href="#Commit-messages-的基本语法" class="headerlink" title="Commit messages 的基本语法"></a>Commit messages 的基本语法</h4><p>当前业界应用的比较广泛的是 <a href="https://docs.google.com/document/d/1QrDFcIiPjSLDn3EL15IJygNPiHORgU1_OOAqWjiDU5Y/edit#heading=h.greljkmo14y0">Angular Git Commit Guidelines</a></p><p>具体格式为:</p><pre class="line-numbers language-none"><code class="language-none">&lt;type&gt;: &lt;subject&gt;&lt;BLANK LINE&gt;&lt;body&gt;&lt;BLANK LINE&gt;&lt;footer&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>type: 本次 commit 的类型，诸如 bugfix docs style 等</li><li>scope: 本次 commit 波及的范围</li><li>subject: 简明扼要的阐述下本次 commit 的主旨，在原文中特意强调了几点 1. 使用祈使句，是不是很熟悉又陌生的一个词，来传送门在此 祈使句 2. 首字母不要大写 3. 结尾无需添加标点</li><li>body: 同样使用祈使句，在主体内容中我们需要把本次 commit 详细的描述一下，比如此次变更的动机，如需换行，则使用 |</li><li>footer: 描述下与之关联的 issue 或 break change，详见案例</li></ul><p><strong>Type 的类别说明：</strong></p><ul><li>feature: 添加新特性/新功能</li><li>upgrade: 功能升级或代码变更</li><li>fix: 修复 bug</li><li>docs: 仅仅修改了文档或 README</li><li>style: 仅仅修改了空格、格式缩进、或者主题 UI 变更 等等，不改变代码逻辑</li><li>refactor: 代码重构，没有加新功能或者修复 bug</li><li>perf: 增加代码进行性能测试</li><li>test: 增加测试用例</li><li>chore: 改变构建流程、或者增加依赖库、工具等</li></ul><h4 id="Commit-messages-格式要求"><a href="#Commit-messages-格式要求" class="headerlink" title="Commit messages 格式要求"></a>Commit messages 格式要求</h4><p>对于 Git Commit Message 并明确的标准，但也有一些好的原则：</p><ul><li>使提交信息业务相关</li><li>提交信息中写明类型</li><li>必要时要写描述(Decription)</li><li>提交主题尽量简短</li><li>尽量使用英文</li></ul><pre class="line-numbers language-none"><code class="language-none"># 标题行：50个字符以内，描述主要变更内容## 主体内容：更详细的说明文本，建议72个字符以内。 需要描述的信息包括:## * 为什么这个变更是必须的? 它可能是用来修复一个bug，增加一个feature，提升性能、可靠性、稳定性等等# * 他如何解决这个问题? 具体描述解决问题的步骤# * 是否存在副作用、风险?## 如果需要的化可以添加一个链接到issue地址或者其它文档<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://juejin.im/post/6847902225029660680">Git 如何写出优雅的 Commit Message</a><br><a href="https://juejin.im/post/6844903721244033038">利用 emoji 让的 git commit 生动清晰起来</a><br><a href="https://juejin.im/post/6844903606815064077">优雅的提交你的 Git Commit Message</a></p><h3 id="利用-emoji-让的-git-commit-生动清晰起来"><a href="#利用-emoji-让的-git-commit-生动清晰起来" class="headerlink" title="利用 emoji 让的 git commit 生动清晰起来"></a>利用 emoji 让的 git commit 生动清晰起来</h3><p>有一些多人合作的项目同事提了 commit，你还需要花时间去看什么提交了什么，因为什么提交。<br>有了 emoji 之后，例如看到有条虫 🐛 就知道他这次版本就是改了 bug 了。<br>非常方便快捷，话不多说，开始吧。</p><p>如何食用：commit 时填写以下图标对应代码即可，例如： <code>:bug:</code> 解决下单问题。</p><p>🎨 <span class="github-emoji"><span>🎨</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f3a8.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><pre class="line-numbers language-none"><code class="language-none">改进代码结构或者格式。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>⚡ <span class="github-emoji"><span>⚡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a1.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><pre class="line-numbers language-none"><code class="language-none">提高效率。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>🔥 <span class="github-emoji"><span>🔥</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f525.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><pre class="line-numbers language-none"><code class="language-none">删除代码或文件。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>🐛 <span class="github-emoji"><span>🐛</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f41b.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><pre class="line-numbers language-none"><code class="language-none">修复bug。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>🚑 <span class="github-emoji"><span>🚑</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f691.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><pre class="line-numbers language-none"><code class="language-none">删除代码或文件。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>🔥 <span class="github-emoji"><span>🎨</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f3a8.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><pre class="line-numbers language-none"><code class="language-none">删除代码或文件。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>✨ <span class="github-emoji"><span>✨</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2728.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><pre class="line-numbers language-none"><code class="language-none">增加新功能。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>📝 <span class="github-emoji"><span>📝</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4dd.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><pre class="line-numbers language-none"><code class="language-none">书写文档，例如修改readme.md。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>🚀 <span class="github-emoji"><span>🚀</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f680.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><pre class="line-numbers language-none"><code class="language-none">部署项目。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>💄 <span class="github-emoji"><span>💄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f484.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><pre class="line-numbers language-none"><code class="language-none">更新UI和样式文件，例如更新css（前端应该经常都要这个涂唇膏的）。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>🎉 <span class="github-emoji"><span>🎉</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f389.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><pre class="line-numbers language-none"><code class="language-none">首次提交 first commit。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>✅ <span class="github-emoji"><span>✅</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><pre class="line-numbers language-none"><code class="language-none">添加测试。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>🔒 <span class="github-emoji"><span>🔒</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f512.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><pre class="line-numbers language-none"><code class="language-none">解决安全问题。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>♻ <span class="github-emoji"><span>♻</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/267b.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><pre class="line-numbers language-none"><code class="language-none">重构代码。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>➕ <span class="github-emoji"><span>➕</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2795.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><pre class="line-numbers language-none"><code class="language-none">添加依赖。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>➖ <span class="github-emoji"><span>➖</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2796.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><pre class="line-numbers language-none"><code class="language-none">删除依赖。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>🔧 <span class="github-emoji"><span>🔧</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f527.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><pre class="line-numbers language-none"><code class="language-none">更改配置文件。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>💩 <span class="github-emoji"><span>💩</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a9.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><pre class="line-numbers language-none"><code class="language-none">编写需要改进的错误代码（这个emoji也太真实了吧）。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>➖ <span class="github-emoji"><span>➖</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2796.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><pre class="line-numbers language-none"><code class="language-none">删除依赖。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><a href="http://emojihomepage.com/">http://emojihomepage.com/</a><br><a href="https://gitmoji.carloscuesta.me/">https://gitmoji.carloscuesta.me/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Android 源码设计模式解析与实战》读书笔记 - 适配器模式</title>
      <link href="20171210/designpattern-structure-adapter/"/>
      <url>20171210/designpattern-structure-adapter/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="《Android-源码设计模式解析与实战》读书笔记-适配器模式"><a href="#《Android-源码设计模式解析与实战》读书笔记-适配器模式" class="headerlink" title="《Android 源码设计模式解析与实战》读书笔记 - 适配器模式"></a>《Android 源码设计模式解析与实战》读书笔记 - 适配器模式</h1><blockquote><p>适配器模式把一个类的接口变换成客户端所期待的另外一个接口，从而使原本因接口不匹配而无法一起工作的两个类能够在一起工作<br>适配器分为类适配器和对象适配器两张</p></blockquote><a id="more"></a><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>系统需要使用现有的类，而此类的接口不符合系统的需要，即接口不兼容</li><li>想要建立一个可重复利用的类，用于与一些彼此之间没有太大关联的类一起工作</li><li>需要一个统一的输出接口，而输入端的类型不可预知</li></ol><h2 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h2><h2 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h2><p><img src="http://blog-1251678165.coscd.myqcloud.com/2018-03-14-Adapter-of-class.uml.png" alt="类适配器"><br>类适配器是通过实现 Target 接口以及继承 Adaptee 类来实现接口转换，如目标接口需要 operator2(), 但是 Adaptee 对象只有 operator3()，因此就出现了不兼容情况。此时可以通过 Adapter 实现一个 operator2()将 Adaptee 的 operator3()转换为 Target 需要的 operator2()</p><p>角色介绍:</p><ul><li>Target: 目标角色，也就是接口所期待得到的接口。（类适配器模式，此目标不可以是类）</li><li>Adaptee: 现在需要适配的接口</li><li>Adapter: 适配器角色，核心类，把不兼容的接口转换成目标所需接口，这一角色必须是具体类</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * Created by Weicools on 2017/12/10. * &lt;p&gt; * desc: 笔记本电脑一都是需要5V电压，而生活电压一般都是220V，这个时候就产生了不兼容情况 * 需要一个适配器来把220V电压转换成5V电压 * 对应就是Target需要得到5V电压，而Adaptee正常输出220V，Adapter类则是继承Adaptee实现Target * 将220V转为5V，解决接口不兼容问题 */public class Test {    public static void main(String[] args) {        VoltAdapter adapter = new VoltAdapter();        System.out.println("输出电压: " + adapter.getVolt5());    }}/** * Created by Weicools on 2017/12/10. * &lt;p&gt; * desc: Target 角色 */public interface FiveVolt {    int getVolt5();}/** * Created by Weicools on 2017/12/10. * &lt;p&gt; * desc: Adaptee 角色 */public class Volt220 {    public int getVolt220() {        return 220;    }}/** * Created by Weicools on 2017/12/10. * &lt;p&gt; * desc: Adapter 角色 */public class VoltAdapter extends Volt220 implements FiveVolt {    @Override    public int getVolt5() {        return 5;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a>对象适配器</h2><h3 id="UML-类图-1"><a href="#UML-类图-1" class="headerlink" title="UML 类图"></a>UML 类图</h3><p><img src="http://blog-1251678165.coscd.myqcloud.com/2018-03-14-Adapter-of-object.uml.png"><br>与类适配器一样，对象适配器模式把被适配类的 API 转为目标类的 API，与类适配器模式不同的是：对象适配器模式不是使用继承关系连接到 Adaptee，而是使用代理关系，UML 类图如下:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">// 基于类适配器的示例修改Adapter/** * Created by Weicools on 2017/12/10. * &lt;p&gt; * desc: Adapter 角色 */public class VoltAdapter implements FiveVolt {    private Volt220 mVolt220;    VoltAdapter(Volt220 volt220) {        mVolt220 = volt220;    }    public int getVOlt220() {        return mVolt220.getVolt220();    }    @Override    public int getVolt5() {        return 5;    }}/** * Created by Weicools on 2017/12/10. * &lt;p&gt; * desc: 笔记本电脑一都是需要5V电压，而生活电压一般都是220V，这个时候就产生了不兼容情况 * 需要一个适配器来把220V电压转换成5V电压 * 直接将被适配的对象传到Adapter中，使用组合形式实现接口兼容效果 * 比类适配器更加灵活，适配对象的方法也不会暴露出来 */public class Test {    public static void main(String[] args) {        VoltAdapter adapter = new VoltAdapter(new Volt220());        System.out.println("输出电压: " + adapter.getVolt5());    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><ol><li>对象适配器直接将要适配的对象传到 Adapter 中，使用组合的形式实现接口兼容的效果，比类适配器更加灵活</li><li>对象适配器还不会将被适配对象的方法暴露出来，而类适配器是继承被适配的类，不够灵活。</li><li>实际开发中 Adapter 常用预进行不兼容类型的转换场景，还有一种就是输入有多种情况，而输出只有一种的时候，可以通过 Adapter 统一进行输出。</li><li>尽可能使用对象适配器，多使用组合少使用继承。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Java </tag>
            
            <tag> DesignPattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>制作多功能启动U盘, 轻松完成系统安装和维护</title>
      <link href="20171202/make-multiboot-udisk/"/>
      <url>20171202/make-multiboot-udisk/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="制作多功能启动-U-盘-轻松完成系统安装和维护"><a href="#制作多功能启动-U-盘-轻松完成系统安装和维护" class="headerlink" title="制作多功能启动 U 盘, 轻松完成系统安装和维护"></a>制作多功能启动 U 盘, 轻松完成系统安装和维护</h1><blockquote><p>本教程仅适用于 EFI 引导的电脑，安装的系统也需要支持 EFI 引导。</p></blockquote><p>平时给自己或者别人重装系统的频率还算挺高的，因为有时候要装 macOS 有时候要装 Windows，每次都要重新把安装包刷到我的 U 盘里，不但非常折腾，而且对寿命也不好。于是整理了一下把安装盘都塞到一个 U 盘里，这个 U 盘不仅可以选择启动多个系统，而且当某一个系统的安装盘需要更新的时候，并不需要抹掉整个盘，只要单独处理对应的分区就好，非常方便。启动的时候效果是这样的：</p><a id="more"></a><p><img src="http://blog-1251678165.coscd.myqcloud.com/2017-12-03-MiPro%20Boot.jpg" alt="引导画面"> 启动箱选择界面</p><pre><code>* Linpus lite (sanDisk) -- 引导试用/安装/启动 Ubuntu 16.04.3* EFI USB Device (SanDisk) -- 引导`macOS安装和启动` 以及 `Windows/Linux等支持EFI引导的系统启动`* EFI USB Device 1 (SanDisk) -- 引导Windows系统安装* EFI USB Device 2 (SanDisk) -- 引导进入WeiPE</code></pre><p>这个 U 盘包括了一个 macOS 安装器、一个 Ubuntu 16.04.3 、一个 Windows10 安装器 和一个 WinPE。接下来的教程就是教大家怎样制作一个这样的启动 U 盘并应对一些启动问题。</p><h2 id="材料准备"><a href="#材料准备" class="headerlink" title="材料准备"></a>材料准备</h2><ol><li><p>至少 16GB 的 U 盘, 32GB 最佳</p></li><li><p><a href="https://itunes.apple.com/cn/app/macos-high-sierra/id1246284741?mt=12">macOS 安装程序</a> (7GB++, 根据安装程序大小决定)</p></li><li><p><a href="http://releases.ubuntu.com/16.04/">Linux 安装镜像</a> (2GB++, 根据安装镜像大小决定)</p></li><li><p><a href="https://msdn.itellyou.cn/">Windows 安装镜像</a> (5GB++, 根据安装镜像大小决定)</p></li><li><p><a href="http://www.wepe.com.cn/download.html">WeiPE 生成的镜像</a> (300MB++, 根据安装镜像大小决定)</p></li><li><p>其他软件工具: 磁盘工具, <a href="http://www.zdfans.com/6959.html">DiskGenius</a>, <a href="http://unetbootin.github.io/">Unetbootin</a>, <a href="https://sourceforge.net/projects/cloverefiboot/?source=typ_redirect">CloverBootLoader</a></p><ul><li>U 盘建议使用 USB 3.0 的</li><li>macOS 可以直接从 AppStore 下载原版安装文件</li><li>Linux 可以去 Ubuntu 官网下载, 也可以使用其他发行版 Linux(需要支持 EFI)</li><li>Windows 原版镜像可以从 I tell you 上获取</li><li>PE 可以使用 WeiPE 或者 AOMEI PE, 本教程使用 WeiPE(PE 需要的工具基本自带)</li></ul><p><img src="http://blog-1251678165.coscd.myqcloud.com/2017-12-02-162348.png"></p></li></ol><h2 id="制作-macOS-安装盘"><a href="#制作-macOS-安装盘" class="headerlink" title="制作 macOS 安装盘"></a>制作 macOS 安装盘</h2><ol><li><p>打开磁盘工具，首先在左边选中你的 U 盘，<strong>注意是选中 U 盘而不是其中的分区</strong>，之后点击抹掉按钮，这会把整个磁盘抹成 GPT。⚠️<strong>该操作会清空 U 盘的全部内容，注意备份。</strong>⚠️（虽然一些软件可以直接转换 MBR 和 GPT，不过我还是觉得直接都抹掉比较干净）</p><p>按照下面的做法，将分区格式选为 Mac OS 扩展（日志式），方案选择 GUID 分区图。点击抹掉。有一定概率出现第一次抹掉不成功的情况，是由于系统没有正确卸载磁盘导致的，这个 Bug 很常见。如果第一次失败了，就再试一次基本上就没问题了。</p><p><img src="http://blog-1251678165.coscd.myqcloud.com/2017-12-02-162915.png"><br><img src="http://blog-1251678165.coscd.myqcloud.com/2017-12-02-162943.png"></p></li><li><p>之后还是选中 U 盘，点击分区。你现在应该看到整个硬盘使用一个分区。点击下面的加号新建一个分区，上面的硬盘会被平均分为两个。选择右边的一个（第一个分区），在右侧的详细信息中将分区的名称改为「macOS」（在之后的写入命令中我们会用到这个名称），将大小改为 7.5GB（其实可以再小一点，但是为了能够兼容之后的 macOS 更新以及能够放一些常用程序，这里 7.5 是一个比较合理的大小）</p><p><img src="http://blog-1251678165.coscd.myqcloud.com/2017-12-02-163036.png"></p><p><img src="http://blog-1251678165.coscd.myqcloud.com/2017-12-02-163210.png"></p><p><img src="http://blog-1251678165.coscd.myqcloud.com/2017-12-02-163239.png"></p></li><li><p>用命令制作安装盘<br>命令(具体可参照下图)：<code>sudo /Applications/Install\ macOS\ High\ Sierra.app/Contents/Resources/createinstallmedia --volume /Volumes/macOS --applicationpath /Applications/Install\ macOS\ High\ Sierra.app --nointeraction</code><br><img src="http://blog-1251678165.coscd.myqcloud.com/2017-12-02-QQ20171203-003628.png"><br><img src="http://blog-1251678165.coscd.myqcloud.com/2017-12-02-163919.png"><br><img src="http://blog-1251678165.coscd.myqcloud.com/2017-12-02-164734.png"></p></li><li><p>安装 Clover 引导<br><img src="http://blog-1251678165.coscd.myqcloud.com/2017-12-02-165039.png"></p><p>安装完成后放 Kexts，主题，APFS 驱动，配置 config.plist……</p></li><li><p>拷贝常用软件<br>可以往 Install macOS High Sierra 安装盘放些驱动/常用 App/工具之类的，安装完系统可以从 U 盘里面拷贝使用.</p></li></ol><h2 id="写入-Linux-Windows-PE-镜像"><a href="#写入-Linux-Windows-PE-镜像" class="headerlink" title="写入 Linux/Windows/PE 镜像"></a>写入 Linux/Windows/PE 镜像</h2><ol><li><p>进入 Windows 系统(也可以使用虚拟机，系统可能会提示分区损坏，取消掉不要格式化，这是因为 Windows 读不了 HFS+ 的分区), 准备好工具: <a href="http://www.zdfans.com/6959.html">DiskGenius</a>, <a href="http://unetbootin.github.io/">Unetbootin</a>, 镜像：<a href="http://releases.ubuntu.com/16.04/">Linux 安装镜像</a>, <a href="https://msdn.itellyou.cn/">Windows 安装镜像</a>, <a href="http://www.wepe.com.cn/download.html">WeiPE 生成的镜像</a></p></li><li><p>打开 DiskGenius, 删除在 macOS 上分出来的区<code>Others</code>, 然后未分区的位置新建分区如下图：按照镜像大小 new 出三个 FAT32 分区，分别是 LINUX, WIN10, WEIPE。(卷标自己命名，新建分区时以 GB 为单位只能新建出整数大小，可以在新建完这个分区后对其调整)<br><img src="http://blog-1251678165.coscd.myqcloud.com/2017-12-03-u-disk-1-delete.png"><br><img src="http://blog-1251678165.coscd.myqcloud.com/2017-12-03-u-disk-2-newLinuxPart.png"><br><img src="http://blog-1251678165.coscd.myqcloud.com/2017-12-03-u-disk-3-chang-size.png"><br><img src="http://blog-1251678165.coscd.myqcloud.com/2017-12-03-u-disk-4-newWinPart.png"></p></li><li><p>新建完分区后。使用 Unetbootin 把对应的系统镜像写入到对应分区中：⚠️<strong>千万不要选错，把别的分区抹掉就要重来了。</strong>⚠️<br><img src="http://blog-1251678165.coscd.myqcloud.com/2017-12-03-u-disk-5-copyUbuntu.png"><br><img src="http://blog-1251678165.coscd.myqcloud.com/2017-12-03-u-disk-6-copyWin10.png"><br><img src="http://blog-1251678165.coscd.myqcloud.com/2017-12-03-Windows10%20make.png"></p><p>对于 WEIPE，官网下载得到的是 WeiPE.exe 文件，打开并选择<code>生成ISO文件</code>，得到 ISO 文件后，直接<code>双击打开</code>，<code>全选里面的文件拷贝到PE分区</code> 或者 用<code>Unetbootin写入</code>也一样。<br><img src="http://blog-1251678165.coscd.myqcloud.com/2017-12-03-u-disk-WEIPE-1.png"><br><img src="http://blog-1251678165.coscd.myqcloud.com/2017-12-03-u-disk-WEIPE-2.png"><br><img src="http://blog-1251678165.coscd.myqcloud.com/2017-12-03-u-disk-WEIPE-3.png"></p></li><li><p>最终得到的效果如下(不要在意 U 盘和盘符，我用两个 U 盘分别做了一次，截图乱了点 ╮(￣ ▽ ￣)╭)，重启按 F12(通常是 F12)进入启动项选择界面即可选择对应的启动项。<br><img src="http://blog-1251678165.coscd.myqcloud.com/2017-12-03-u-disk-newThreePart.png"><br><img src="http://blog-1251678165.coscd.myqcloud.com/2017-12-03-u-disk-final.png"><br><img src="http://blog-1251678165.coscd.myqcloud.com/2017-12-03-MiPro%20Boot.jpg" alt="引导画面"></p></li></ol><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q &amp; A"></a>Q &amp; A</h2><ol><li>安装盘有了新版本怎么办？<ul><li>只要抹掉该分区，重新按照之前的步骤刷入即可。Windows 也是同理，不过要在 Windows 中就格式化对应分区重新写入。</li></ul></li><li>有安装盘的那些分区可以自己存文件么？<ul><li>当然可以，可用空间里面随便存，不会浪费。比如 Install macOS High Sierra 的盘可以放些驱动/常用 App 之类的，安装完系统可以从 U 盘里面拷贝使用，WIN10 分区可以放些 PE 没有的一些工具，也可以存自己日常的一些文件，不过最好新建文件夹来存储。<br><img src="http://blog-1251678165.coscd.myqcloud.com/2017-12-03-032556.png"><br><img src="http://blog-1251678165.coscd.myqcloud.com/2017-12-03-032634.png"></li></ul></li><li>推出 U 盘的时候总是无法推出怎么办？<ul><li>因为四个区的关系，在较慢的 U 盘上推出的时候会非常的卡，这是正常现象，多等一会就好了。</li></ul></li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://sspai.com/post/41960">制作一个四合一维护 U 盘，重装系统还能有多方便？</a></li><li><a href="http://www.ruanyifeng.com/blog/2013/02/booting.html">计算机是如何启动的 - 阮一峰</a></li><li><a href="https://www.zhihu.com/question/21672895">UEFI 和 BIOS 引导有什么不同 - 知乎</a></li><li><a href="https://decio.eu/2014/01/16/correct-name-and-icons-in-startup-manager/">Correct name and icons in Startup Manager </a></li></ul></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> macOS </tag>
            
            <tag> Linux </tag>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>暗影精灵2Plus GTX1060独显亮度调节实现</title>
      <link href="20170826/hp2plus-gtx1060-brightness/"/>
      <url>20170826/hp2plus-gtx1060-brightness/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="暗影精灵-2Plus-GTX1060-独显亮度调节实现"><a href="#暗影精灵-2Plus-GTX1060-独显亮度调节实现" class="headerlink" title="暗影精灵 2Plus GTX1060 独显亮度调节实现"></a>暗影精灵 2Plus GTX1060 独显亮度调节实现</h1><blockquote><p>Foreword：本来打算毕业工作了再换本的，但是实在受不了之前那个低压 U 本 Yoga13 了，开个 IDE 和模拟器就快炸了，玩个 LOL 一打团就变 PPT 玩个蛇皮；然后然后看到**<code>暗影精灵2Plus</code><strong>七代 U 版本比首发价还低 1000 就忍不住剁手了 🤣，总体体验：性能不用说，i7+GTX1060 甜品显卡基本都可以玩，72％色域 IPS 屏幕也是很棒，缺点 17.3 寸比较重、台达电源 230W 好大一块砖、键盘方向键反人类 🙃<br><img src="https://blog-bak-1251678165.cos.ap-beijing.myqcloud.com/2017-08-27-023638.jpg" alt="Order"><br>回到主题：这本惠普自己把</strong><code>核显HD630屏蔽</code><strong>了，Windows 设备管理器都看不到（Windows 上不插电源没法玩游戏），Hackintosh 岂不是可以直接用 GTX1060 了 😉 美滋滋，虽然是用上了但是</strong><code>亮度调节</code>**一直不行，直到昨天才搞定。</p></blockquote><a id="more"></a><ol><li>本次参考的教程：<ul><li><a href="http://bbs.pcbeta.com/viewthread-1742873-9-1.html">【笔记本 GTX1060】现在弄好了调节亮度啦-远景论坛-微软极客社区</a></li><li><a href="http://bbs.pcbeta.com/viewthread-1714158-1-1.html">蓝天 p6xxrx 准系统 EFI 10.12 （神舟战神 z7s3）-远景论坛-微软极客社区</a></li><li><a href="http://bbs.pcbeta.com/viewthread-1663916-1-1.html">GTX970M-原生亮度调节-远景论坛-微软极客社区</a></li><li><a href="http://bbs.pcbeta.com/viewthread-1473634-1-1.html">轻松注入 EDID 参数-远景论坛-微软极客社区</a></li></ul></li><li>使用到的工具：<ul><li><a href="https://bitbucket.org/blackosx/darwindumper/downloads/">DarwinDumper_v3.0.3</a></li><li><a href="http://bbs.pcbeta.com/forum.php?mod=viewthread&amp;tid=1525657">注入 EDID 的利器：FixEDID 2.3.2(12 楼已有热心会员做的汉化版)</a></li><li><a href="https://bitbucket.org/RehabMan/os-x-maciasl-patchmatic/downloads/">MaciASL DSDT 和 SSDT 工具</a></li><li><a href="https://bitbucket.org/RehabMan/acpica/downloads/">Acpica iasl 反编译脚步工具</a></li><li><a href="http://www.insanelymac.com/forum/files/file/397-easykext-pro-a-minimal-and-super-fast-kext-installer/">EasyKext Pro 驱动安装和权限修复</a></li></ul></li></ol><h2 id="一-注入-EDID"><a href="#一-注入-EDID" class="headerlink" title="一.注入 EDID"></a>一.注入 EDID</h2><ol><li><p>打开 DarwinDumper_v3.0.3 直接点击 Run（也可只选 EDID）<br><img src="https://blog-bak-1251678165.cos.ap-beijing.myqcloud.com/2017-08-27-031521.jpg" alt="DarwinDumper_v3.0.3"><br><img src="https://blog-bak-1251678165.cos.ap-beijing.myqcloud.com/2017-08-27-031613.jpg" alt="Report"></p><blockquote><p>之前我用教程带的 DarwinDumper2.8.8 生成的 bin 文件在 FixEDID2.3 导入报错，2.3 版本目测选 hex 文件会有问题，坑啊 🙃，还好去找到了最新的版本 3.0.3 用起来没啥问题</p></blockquote></li><li><p>打开 FixEDID 2.3.2，打开 EDID 文件选择刚才生成的 EDID.bin，其他需要勾选的图上已做标注：选择显示器型号，下面两个都选 AppleBlacklightDisplay，然后点击 make 得到三个东西：DisplayVendorID-xxx 文件夹、DisplayMergeNub.kext、EDID-xxx.bin。然后需要做的是<code>把驱动安装到S/L/E并修复缓存</code> 或者 <code>把DisplayVendorID-xxx文件夹放到/System/Library/Displays/Contents/Resources/Overrides目录下</code> 推荐使用驱动注入，重新启动看看显示器情况。<br><img src="https://blog-bak-1251678165.cos.ap-beijing.myqcloud.com/2017-08-26-155155.jpg" alt="FixEDID"></p><blockquote><p>坑点：把 FixEDID 中显示器型号都试了一遍，生成的驱动安装到 S/L/E 均无效，功能扩展显示<code>签名验证错误</code><br><img src="https://blog-bak-1251678165.cos.ap-beijing.myqcloud.com/2017-08-26-134239.jpg" alt="Kextsign"><br>无奈只能选择把 <strong>显示器的 Overrides 文件</strong> 扔到 <code>/System/Library/Displays/Contents/Resources/Overrides</code> ，这种方式也存在不少问题，多数型号开机卡住（强制关机然后-V 模式可进入），部分是没有任何效果，只有 MacBook Pro 16:10 可行，当时效果如下：<br><img src="https://blog-bak-1251678165.cos.ap-beijing.myqcloud.com/2017-08-26-154719.jpg" alt="MBP"><br>17.3 寸显示器显示成了 13.3 寸 🙃</p></blockquote></li></ol><h2 id="二-DSDT-部分"><a href="#二-DSDT-部分" class="headerlink" title="二.DSDT 部分"></a>二.DSDT 部分</h2><ol><li><p>打补丁：Brightness fix（加入 PLNF 代码，记得先把已存在的 PLNF 重命名）<br><img src="https://blog-bak-1251678165.cos.ap-beijing.myqcloud.com/2017-08-26-103057.jpg" alt="Brightness"></p></li><li><p>最关键地方：打开 IORegistryExplorer 搜索 display，查看 AppleDisplay 所在位置<br><img src="https://blog-bak-1251678165.cos.ap-beijing.myqcloud.com/2017-08-23-040403.jpg" alt="AppleDisplay"><br>打开 MaciASL，选择相应 DSDT 文件，在 DSDT 下的 PEG0 下 PEGP 总加入_DSM 方法，注入代码如下:</p><pre class="line-numbers language-none"><code class="language-none">Method (_DSM, 4, NotSerialized)  // _DSM: Device-Specific Method{   If (LEqual (Arg2, Zero))   {       Return (Buffer (One)       {            0x03       })   }   Return (Package (0x16)   {       "@1,AAPL,boot-display",       Buffer (One)       {            0x01       },       "@1,backlight-control",       Buffer (0x04)       {            0x01, 0x00, 0x00, 0x00       },       "@1,built-in",       Buffer (One)       {            0x01       },       "@0,connector-type",       Buffer (0x04)       {            0x00, 0x08, 0x00, 0x00       },       "@1,connector-type",       Buffer (0x04)       {            0x00, 0x04, 0x00, 0x00       },       "@2,connector-type",       Buffer (0x04)       {            0x00, 0x04, 0x00, 0x00       },       "@3,connector-type",       Buffer (0x04)       {            0x00, 0x04, 0x00, 0x00       },       "@4,connector-type",       Buffer (0x04)       {            0x00, 0x04, 0x00, 0x00       },       "@5,connector-type",       Buffer (0x04)       {            0x00, 0x04, 0x00, 0x00       },       "@1,pwm-info",       Buffer (0x14)       {           /* 0000 */  0x01, 0x14, 0x00, 0x64, 0xA8, 0x61, 0x00, 0x00,           /* 0008 */  0x1E, 0x02, 0x00, 0x00, 0x2C, 0x00, 0x00, 0x00,           /* 0010 */  0x00, 0x04, 0x00, 0x00       },       "hda-gfx",       Buffer (0x0A)       {           "onboard-1"       }   })}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：”@1,AAPL,boot-display”, “@1,backlight-control”,”@1,built-in”,”@1,pwm-info”这几个地方，@1 是显示器所在位置，根据 IORegistryExplorer 显示：我的是在 NVDA,Display-B@1。<br><img src="https://blog-bak-1251678165.cos.ap-beijing.myqcloud.com/2017-08-27-DSDT%20AppleDisplay.png" alt="DSDT AppleDisplay"><br>插入完代码保存 DSDT，把它放到<code>/EFI/CLOVER/ACPI/patched</code>，Clover 中勾选注入即可，重启即可看到加载的是 AppleBlacklightDisplay<br><img src="https://blog-bak-1251678165.cos.ap-beijing.myqcloud.com/2017-08-27-043716.jpg" alt="AppleBlacklightDisplay"></p></blockquote></li></ol><h2 id="三-替换驱动"><a href="#三-替换驱动" class="headerlink" title="三.替换驱动"></a>三.替换驱动</h2><ol><li>10.12.4 下可不用替换 AppleBacklight.kext，但是 10.12.5/10.12.6 需要替换，10.13 未知，驱动分享链接: <a href="https://pan.baidu.com/s/1mhPjxqS">https://pan.baidu.com/s/1mhPjxqS</a> 密码: 6666</li><li>使用 EasyKext 安装修复缓存即可。</li></ol><h2 id="四-效果展示"><a href="#四-效果展示" class="headerlink" title="四.效果展示"></a>四.效果展示</h2><p>完成上面三步，基本上就是 OK 了~重启电脑试试吧 😉😉😉！！！（我的亮度直接是可保存的，若不可以请参考：<a href="http://bbs.pcbeta.com/viewthread-1538926-1-1.html">[分享] 解决开机第二阶段花屏和 Clover 脚本不生成 nvram.plist 导致不能保存亮度的问题</a>）</p><p><img src="https://blog-bak-1251678165.cos.ap-beijing.myqcloud.com/2017-08-27-043359.jpg" alt="概览"><br><img src="https://blog-bak-1251678165.cos.ap-beijing.myqcloud.com/2017-08-27-043512.jpg" alt="显示器图形卡"><br><img src="https://blog-bak-1251678165.cos.ap-beijing.myqcloud.com/2017-08-27-043606.jpg" alt="亮度调节1"><br><img src="https://blog-bak-1251678165.cos.ap-beijing.myqcloud.com/2017-08-27-044609.jpg" alt="亮度调节2"><br><img src="https://blog-bak-1251678165.cos.ap-beijing.myqcloud.com/2017-08-27-044641.jpg" alt="亮度调节3"></p><blockquote><p><strong>差不多就结束了吧，踩得坑还是不少，尤其是注入 EDID，之前一直不行所有放弃放弃……，但是看到论坛有不少人都可以实现独显亮度调节，忍不住又回来重试了好几遍，折腾啊……</strong>🙃🙃🙃</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> macOS </tag>
            
            <tag> Hackintosh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Android 源码设计模式解析与实战》读书笔记 - 责任链模式</title>
      <link href="20170318/designpattern-behavior-chain-of-responsibility/"/>
      <url>20170318/designpattern-behavior-chain-of-responsibility/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="《Android-源码设计模式解析与实战》读书笔记-责任链模式"><a href="#《Android-源码设计模式解析与实战》读书笔记-责任链模式" class="headerlink" title="《Android 源码设计模式解析与实战》读书笔记 - 责任链模式"></a>《Android 源码设计模式解析与实战》读书笔记 - 责任链模式</h1><blockquote><p>锁链这种链式结构，每个节点都可以被拆开再连接，因此链式结构也具有很好的灵活性，在编程领域，将每一个节点看作一个对象，每个对象有不同的处理逻辑，将一个请求从链式的首端出发，沿着路径依次传递到每个节点对象，直到有对象处理这个请求为止。<br>定义: 责任链模式是行为型设计模式之一，它使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。</p></blockquote><a id="more"></a><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>多个对象可以处理同一请求，但具体由哪个对象处理则在运行时动态决定。</li><li>在请求处理者不明确的情况下向多个对象中的一个提交请求。</li><li>需要动态指定一组对象处理请求。</li></ol><h2 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h2><p><img src="http://blog-1251678165.coscd.myqcloud.com/2018-03-18-Chain.png"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * Created by Weicools on 2017/3/18. * &lt;p&gt; * desc: 抽象处理角色，申明一个请求处理方法 * 并在其中保持一个对下一个处理节点Handler的引用 */public abstract class Handler {    //下一个节点处理者    protected Handler successor;    public abstract void handleRequest(String condition);}/** * Created by Weicools on 2017/3/18. * &lt;p&gt; * desc: 具体处理者角色，对请求进行处理，如果不能处理就转发给下一个处理 */public class ConcreteHandlerA extends Handler {    @Override    public void handleRequest(String condition) {        if (condition.equals("ConcreteHandlerA")) {            System.out.println("ConcreteHandlerA handled");        } else {            successor.handleRequest(condition);        }    }}/** * Created by Weicools on 2017/3/18. * &lt;p&gt; * desc: 具体处理者角色，对请求进行处理，如果不能处理就转发给下一个处理 */public class ConcreteHandlerB extends Handler {    @Override    public void handleRequest(String condition) {        if (condition.equals("ConcreteHandlerB")) {            System.out.println("ConcreteHandlerB handled");        } else {            successor.handleRequest(condition);        }    }}/** * Created by Weicools on 2017/3/18. * &lt;p&gt; * desc: */public class Client {    public static void main(String[] args) {        ConcreteHandlerA handlerA = new ConcreteHandlerA();        ConcreteHandlerB handlerB = new ConcreteHandlerB();        handlerA.successor = handlerB;        handlerB.successor = handlerA;        handlerA.handleRequest("ConcreteHandleB");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h2><blockquote><p>这个例子我觉得很贴切。我们在公司有各种原因需要报销费用，首先我们要找我们的上级领导去审批，报销额度如果在领导的权限范围内，那就审批通过，否则领导在找自己的上级去审批，以此类推。</p></blockquote><h3 id="抽象领导类"><a href="#抽象领导类" class="headerlink" title="抽象领导类"></a>抽象领导类</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public abstract class Leader {    /**     * 上级领导处理者     */    protected Leader nextHandler;    /**     * 处理报账请求     *     * @param money 能批复的报账额度     *     */    public final void handleRequest(int money){        System.out.println(getLeader());        if(money &lt;=limit()){            handle(money);        }else{            System.out.println("报账额度不足，提交领导");            if(null != nextHandler){                nextHandler.handleRequest(money);            }        }    }    /**     * 自身能批复的额度权限     *     * @return 额度     */    public abstract int limit();    /**     * 处理报账行为     *     * @param money 具体金额     */    public abstract void handle(int money);    /**     * 获取处理者     *     * @return 处理者     */    public abstract String getLeader();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="组长（额度-1000）："><a href="#组长（额度-1000）：" class="headerlink" title="组长（额度 1000）："></a>组长（额度 1000）：</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class GroupLeader extends Leader{    @Override    public int limit() {        return 1000;    }    @Override    public void handle(int money) {        System.out.println("组长批复报销"+ money +"元");    }    @Override    public String getLeader() {        return "当前是组长";    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="主管（额度-5000）："><a href="#主管（额度-5000）：" class="headerlink" title="主管（额度 5000）："></a>主管（额度 5000）：</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Director extends Leader{    @Override    public int limit() {        return 5000;    }    @Override    public void handle(int money) {        System.out.println("主管批复报销"+ money +"元");    }    @Override    public String getLeader() {        return "当前是主管";    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="经理（额度-10000）："><a href="#经理（额度-10000）：" class="headerlink" title="经理（额度 10000）："></a>经理（额度 10000）：</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Manager extends Leader{    @Override    public int limit() {        return 10000;    }    @Override    public void handle(int money) {        System.out.println("经理批复报销"+ money +"元");    }    @Override    public String getLeader() {        return "当前是经理";    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="老板（额度无上限）"><a href="#老板（额度无上限）" class="headerlink" title="老板（额度无上限）:"></a>老板（额度无上限）:</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Boss extends Leader{    @Override    public int limit() {        return Integer.MAX_VALUE;    }    @Override    public void handle(int money) {        System.out.println("老板批复报销"+ money +"元");    }    @Override    public String getLeader() {        return "当前是老板";    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="发起申请："><a href="#发起申请：" class="headerlink" title="发起申请："></a>发起申请：</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Client {    public static void main(String[] args) {        //构造各个领导对象        GroupLeader groupLeader = new GroupLeader();        Director director = new Director();        Manager manager = new Manager();        Boss boss = new Boss();        //设置上级领导处理者对象        groupLeader.nextHandler = director;        director.nextHandler = manager;        manager.nextHandler = boss;        //发起报账申请        groupLeader.handleRequest(8000);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="结果："><a href="#结果：" class="headerlink" title="结果："></a>结果：</h3><pre class="line-numbers language-none"><code class="language-none">当前是组长报账额度不足，提交领导当前是主管报账额度不足，提交领导当前是经理经理批复报销8000元123456<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>责任链模式非常灵活，请求的发起可以从责任链的任何一个节点开始，也可以改变内部的传递规则。比如主管不在，我们完全可以跨过主管直接从组长那里转到经理。</p><blockquote><p>对于责任链中的一个处理者对象，有两个行为。一是处理请求，二是将请求传递到下一节点，不允许某个处理者对象在处理了请求后又将请求传送给上一个节点的情况。<br>对于一条责任链来说，一个请求最终只有两种情况。一是被某个处理对象所处理，另一个是所有对象均未对其处理，对于前一种情况我们称为<strong>纯的责任链模式</strong>，后一种为<strong>不纯的责任链</strong>。实际中大多为不纯的责任链。</p></blockquote><h2 id="Android-源码中的责任链模式"><a href="#Android-源码中的责任链模式" class="headerlink" title="Android 源码中的责任链模式"></a>Android 源码中的责任链模式</h2><ul><li>View 事件的分发处理</li></ul><p>ViewGroup 事件投递的递归调用就类似于一条责任链，一旦其寻找到责任者，那么将由责任者持有并消费掉该次事件，具体体现在 View 的 onTouchEvent 方法中返回值的设置，如果返回 false，那么意味着当前的 View 不会是该次的责任人，将不会对其持有；如果返回 true，此时 View 会持有该事件并不再向外传递。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>优点<ul><li>可以对请求者和处理者的关系解耦，提高代码的灵活性。</li></ul></li><li>缺点<ul><li>每次都需要对链中请求处理者遍历，如果处理者太多那么遍历必定会影响性能，特别是在一些递归调用者中，要慎用。</li></ul></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Java </tag>
            
            <tag> DesignPattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Android 源码设计模式解析与实战》读书笔记 - 命令模式</title>
      <link href="20170318/designpattern-behavior-command/"/>
      <url>20170318/designpattern-behavior-command/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="《Android-源码设计模式解析与实战》读书笔记-命令模式"><a href="#《Android-源码设计模式解析与实战》读书笔记-命令模式" class="headerlink" title="《Android 源码设计模式解析与实战》读书笔记 - 命令模式"></a>《Android 源码设计模式解析与实战》读书笔记 - 命令模式</h1><blockquote><p>命令模式是行为型模式之一。总体来说并不难理解，只是比较繁琐，他会将简单的调用关系解耦成多个部分，增加类的复杂度，但是即便如此，命令模式的结构依然清晰。<br>定义: 将一个请求封装成一个对象，从而让用户使用不同的请求把客户端参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。</p></blockquote><a id="more"></a><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul><li>（1）需要抽出待执行的动作，然后以参数的形式提供出来。</li><li>（2）在不同的时刻指定、排列和执行请求。一个命令对象可以有与初始请求无关的生存期。</li><li>（3）需要支持操作取消。</li><li>（4）支持修改日志功能，这样当系统崩溃时，这些修改可以被重做一遍。</li><li>（5）需要支持事务操作。</li></ul><h2 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h2><p><img src="http://blog-1251678165.coscd.myqcloud.com/2018-03-18-Command.png"></p><h2 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h2><blockquote><p>以推箱子游戏为例，一般游戏中会有五个按钮，分别是左移、右移、下移、上移和撤销。那么玩游戏的人就是客户端，五个按钮就是调用者，执行具体按钮命令的方法是命令角色。</p></blockquote><h3 id="接收者角色：推箱子游戏"><a href="#接收者角色：推箱子游戏" class="headerlink" title="接收者角色：推箱子游戏"></a>接收者角色：推箱子游戏</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class PushBox {    /**     * 执行向左命令     */    public void toLeft(){        System.out.println("向左");    }    /**     * 执行向右命令     */    public void toRight(){        System.out.println("向右");    }    /**     * 执行向下命令     */    public void toDown(){        System.out.println("向下");    }    /**     * 执行向上命令     */    public void toUp(){        System.out.println("向上");    }    /**     * 执行撤销命令     */    public void revoke(){        System.out.println("撤销");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="命令者抽象"><a href="#命令者抽象" class="headerlink" title="命令者抽象"></a>命令者抽象</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface Command {    /**     * 命令执行方法     */    void execute();    /**     * 获取命令类型     */    void getCommand();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="具体命令者，左移命令类"><a href="#具体命令者，左移命令类" class="headerlink" title="具体命令者，左移命令类"></a>具体命令者，左移命令类</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class LeftCommand implements Command{    //持有一个接受推箱子游戏对象的引用    private PushBox pushBox;    public LeftCommand(PushBox pushBox){        this.pushBox = pushBox;    }    @Override    public void execute() {        //调用具体命令        pushBox.toLeft();    }    @Override    public void getCommand() {        System.out.print("向左--&gt;");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="具体命令者，右移命令类"><a href="#具体命令者，右移命令类" class="headerlink" title="具体命令者，右移命令类"></a>具体命令者，右移命令类</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class RightCommand implements Command{    //持有一个接受推箱子游戏对象的引用    private PushBox pushBox;    public RightCommand(PushBox pushBox){        this.pushBox = pushBox;    }    @Override    public void execute() {        //调用具体命令        pushBox.toRight();    }    @Override    public void getCommand() {        System.out.print("向右--&gt;");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="具体命令者，上移命令类"><a href="#具体命令者，上移命令类" class="headerlink" title="具体命令者，上移命令类"></a>具体命令者，上移命令类</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class UpCommand implements Command{    //持有一个接受推箱子游戏对象的引用    private PushBox pushBox;    public UpCommand(PushBox pushBox){        this.pushBox = pushBox;    }    @Override    public void execute() {        //调用具体命令        pushBox.toUp();    }    @Override    public void getCommand() {        System.out.print("向上--&gt;");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="具体命令者，下移命令类"><a href="#具体命令者，下移命令类" class="headerlink" title="具体命令者，下移命令类"></a>具体命令者，下移命令类</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class DownCommand implements Command{    //持有一个接受推箱子游戏对象的引用    private PushBox pushBox;    public DownCommand(PushBox pushBox){        this.pushBox = pushBox;    }    @Override    public void execute() {        //调用具体命令        pushBox.toDown();    }    @Override    public void getCommand() {        System.out.print("向下--&gt;");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="具体命令者，撤销命令类"><a href="#具体命令者，撤销命令类" class="headerlink" title="具体命令者，撤销命令类"></a>具体命令者，撤销命令类</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class RevokeCommand implements Command{    //持有一个接受推箱子游戏对象的引用    private PushBox pushBox;    public RevokeCommand(PushBox pushBox){        this.pushBox = pushBox;    }    @Override    public void execute() {        //调用具体命令        pushBox.revoke();;    }    @Override    public void getCommand() {    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="请求者类，命令由按钮发起"><a href="#请求者类，命令由按钮发起" class="headerlink" title="请求者类，命令由按钮发起"></a>请求者类，命令由按钮发起</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Buttons {    private LeftCommand leftCommand; //向左移动的命令对象引用    private RightCommand rightCommand; //向右移动的命令对象引用    private UpCommand upCommand; //向上移动的命令对象引用    private DownCommand downCommand; //向下移动的命令对象引用    private RevokeCommand revokeCommand; //撤销命令对象引用    private ArrayList&lt;Command&gt; commandList = new ArrayList&lt;Command&gt;();//用于记录命令动作    /**     * 获取执行命令     */    public void getCommandList(){        for(Command c : commandList){            c.getCommand();        }        System.out.println("");    }    /**     * 设置向左移动的命令对象     *     * @param leftCommand 向左移动的命令对象     */    public void setLeftCommand(LeftCommand leftCommand){        this.leftCommand = leftCommand;    }    /**     * 设置向右移动的命令对象     *     * @param rightCommand 向右移动的命令对象     */    public void setRightCommand(RightCommand rightCommand){        this.rightCommand = rightCommand;    }    /**     * 设置向上移动的命令对象     *     * @param upCommand 向上移动的命令对象     */    public void setUpCommand(UpCommand upCommand){        this.upCommand = upCommand;    }    /**     * 设置向下移动的命令对象     *     * @param downCommand 向下移动的命令对象     */    public void setDownCommand(DownCommand downCommand){        this.downCommand = downCommand;    }    /**     * 设置撤销命令对象     *     * @param revokeCommand 撤销命令对象     */    public void setRevokeCommand(RevokeCommand revokeCommand){        this.revokeCommand = revokeCommand;    }    /**     * 按下向左按钮     */    public void toLeft(){        leftCommand.execute();        commandList.add(leftCommand);    }    /**     * 按下向右按钮     */    public void toRight(){        rightCommand.execute();        commandList.add(rightCommand);    }    /**     * 按下向上按钮     */    public void toUp(){        upCommand.execute();        commandList.add(upCommand);    }    /**     * 按下向下按钮     */    public void toDown(){        downCommand.execute();        commandList.add(downCommand);    }    /**     * 按下撤销按钮     */    public void toRevoke(){        revokeCommand.execute();        commandList.remove(commandList.size()-1);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="客户端调用"><a href="#客户端调用" class="headerlink" title="客户端调用"></a>客户端调用</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Client {    public static void main(String[] args) {        //首先创建游戏        PushBox pushBox = new PushBox();        //根据游戏构造5种命令        LeftCommand leftCommand = new LeftCommand(pushBox);        RightCommand rightCommand = new RightCommand(pushBox);        UpCommand upCommand = new UpCommand(pushBox);        DownCommand downCommand = new DownCommand(pushBox);        RevokeCommand revokeCommand = new RevokeCommand(pushBox);        //按钮可以执行不同命令        Buttons buttons = new Buttons();        buttons.setLeftCommand(leftCommand);        buttons.setRightCommand(rightCommand);        buttons.setUpCommand(upCommand);        buttons.setDownCommand(downCommand);        buttons.setRevokeCommand(revokeCommand);        //执行操作        buttons.toLeft();        buttons.toDown();        buttons.toDown();        buttons.toRight();        buttons.getCommandList();        buttons.toRevoke();        buttons.toUp();        buttons.toLeft();        buttons.toDown();        buttons.toUp();        buttons.getCommandList();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h3><pre class="line-numbers language-none"><code class="language-none">向左向下向下向右向左--&gt;向下--&gt;向下--&gt;向右--&gt;撤销向上向左向下向上向左--&gt;向下--&gt;向下--&gt;向上--&gt;向左--&gt;向下--&gt;向上--&gt;1234567891011<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这么长的代码之后是不是觉得很烦琐，明明可以很简单的实现，如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Client {    public static void main(String[] args) {        //首先创建游戏        PushBox pushBox = new PushBox();        pushBox.toDown();        pushBox.toRight();        pushBox.toUp();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实设计模式有一个重要的原则：对修改关闭对扩展开放。如果使用如上的简单方式，那么以后的修改只能去修改 PushBox 类，然后修改 Client 类，这显然违反了这一原则。如果使用命令模式，那么 Client 类无需修改，只需要修改 PushBox 类的内部操作，Client 类无需知道具体的内部实现。</p><blockquote><p>设计模式的使用之前也有提到，主要是要看当前场景的复杂度和以后的需求进行扩展、维护等方面，完全使用设计模式也是不提倡的，这就需要设计者权衡利弊了。</p></blockquote><h2 id="Android-源码中的命令模式实现"><a href="#Android-源码中的命令模式实现" class="headerlink" title="Android 源码中的命令模式实现"></a>Android 源码中的命令模式实现</h2><ol><li>PackageHandler</li></ol><p>PackageManagerService 中，其对包的相关消息处理右其内部类 PackageHandler 承担，其将需要处理的请求作为对象通过消息传递给相关的方法，而对于包的安装、移动以及包大小的测量则分别封装为<strong>HandlerParams</strong>的具体子类<strong>InstallParams</strong>、<strong>MoveParams</strong>和<strong>MeasureParams</strong>。源码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">private abstract class HandlerParams {        private static final int MAX_RETRIES = 4;        /**         * Number of times startCopy() has been attempted and had a non-fatal         * error.         */        private int mRetries = 0;        final boolean startCopy() {            boolean res;            try {                if (DEBUG_INSTALL) Slog.i(TAG, "startCopy");                if (++mRetries &gt; MAX_RETRIES) {                    Slog.w(TAG, "Failed to invoke remote methods on default container service. Giving up");                    mHandler.sendEmptyMessage(MCS_GIVE_UP);                    handleServiceError();                    return false;                } else {                    handleStartCopy();                    res = true;                }            } catch (RemoteException e) {                if (DEBUG_INSTALL) Slog.i(TAG, "Posting install MCS_RECONNECT");                mHandler.sendEmptyMessage(MCS_RECONNECT);                res = false;            }            handleReturnCode();            return res;        }        final void serviceError() {            if (DEBUG_INSTALL) Slog.i(TAG, "serviceError");            handleServiceError();            handleReturnCode();        }        abstract void handleStartCopy() throws RemoteException;        abstract void handleServiceError();        abstract void handleReturnCode();    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出<strong>HandlerParams</strong>也是一个抽象命令者。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>优点<ul><li>命令模式的封装性很好，更弱的耦合性，更灵活的控制性以及更好的扩展性。</li></ul></li><li>缺点<ul><li>类的膨胀，大量衍生类的创建。</li></ul></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Java </tag>
            
            <tag> DesignPattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Android 源码设计模式解析与实战》读书笔记 - 迭代器模式</title>
      <link href="20170318/designpattern-behavior-iterator/"/>
      <url>20170318/designpattern-behavior-iterator/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Ï</p><h1 id="《Android-源码设计模式解析与实战》读书笔记-迭代器模式"><a href="#《Android-源码设计模式解析与实战》读书笔记-迭代器模式" class="headerlink" title="《Android 源码设计模式解析与实战》读书笔记 - 迭代器模式"></a>《Android 源码设计模式解析与实战》读书笔记 - 迭代器模式</h1><blockquote><p>迭代器模式，又叫做游标模式，是行为型设计模式之一。我们知道对容器对象的访问必然会涉及遍历算法，我们可以将遍历的方法封装在容器中，或者不提供遍历方法，让使用容器的人自己去实现去吧。这两种情况好像都能够解决问题。<br>然而在前一种情况，容器承受了过多的功能，它不仅要负责自己“容器”内的元素维护（添加、删除等等），而且还要提供遍历自身的接口；而且由于遍历状态保存的问题，不能对同一个容器对象同时进行多个遍历。第二种方式倒是省事，却又将容器的内部细节暴露无遗。<br>正因于此，迭代器模式应运而生，在客户访问类与容器体之间插入一个第三者–迭代器，很好的解决了上述弊端。<br>定义：提供一种方法顺序访问一个容器对象中的各个元素，而又不需要暴露该对象的内部表示。</p></blockquote><a id="more"></a><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>遍历一个容器对象时。</p><h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><p><img src="http://blog-1251678165.coscd.myqcloud.com/2018-03-18-Iterator.png"></p><h2 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h2><blockquote><p>用书中的例子：小民和小辉分别在公司两个事业部，某天老板安排任务让他们俩统计一下各自部门的员工数据。</p></blockquote><h3 id="员工实体类："><a href="#员工实体类：" class="headerlink" title="员工实体类："></a>员工实体类：</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Employee {    private String name;// 姓名    private int age;// 年龄    private String sex;// 性别    private String position;// 职位    public Employee(String name, int age, String sex, String position) {        super();        this.name = name;        this.age = age;        this.sex = sex;        this.position = position;    }    // 简化代码，省略setter和getter方法    @Override    public String toString() {        return "Employee{" + "name='" + name + '\'' + ", age=" + age + ", sex="                + sex + ", position='" + position + '\'' + "}";    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="小辉部门："><a href="#小辉部门：" class="headerlink" title="小辉部门："></a>小辉部门：</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class CompanyHui {private Employee[] array = new Employee[3];    public CompanyHui(){        array[0] = new Employee("辉哥", 28, "男", "程序猿");        array[1] = new Employee("小红", 23, "男", "程序猿");        array[2] = new Employee("小辉", 25, "男", "程序猿");    }    public Employee[] getEmployees(){        return array;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="小民部门："><a href="#小民部门：" class="headerlink" title="小民部门："></a>小民部门：</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class CompanyMin {    private List&lt;Employee&gt; list = new ArrayList&lt;&gt;();    public CompanyMin(){        list.add(new Employee("小民", 26, "男", "程序猿"));        list.add(new Employee("小芸", 22, "女", "测试"));        list.add(new Employee("小方", 18, "女", "测试"));        list.add(new Employee("可儿", 21, "女", "设计"));        list.add(new Employee("朗情", 19, "女", "设计")); //吐槽一下，为什么就小民一个男的，小辉部门全男的。    }    public List&lt;Employee&gt; getEmployees(){        return list;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Boss查看："><a href="#Boss查看：" class="headerlink" title="Boss查看："></a>Boss查看：</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Boss {    public static void main(String[] args) {        CompanyHui hui = new CompanyHui();        Employee[] huiList = hui.getEmployees();        for(int i = 0; i &lt; huiList.length; i++){            System.out.println(huiList[i]);        }        CompanyMin min = new CompanyMin();        List minList = min.getEmployees();        for(int i = 0; i &lt; minList.size(); i++){            System.out.println(minList.get(i).toString());        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="结果："><a href="#结果：" class="headerlink" title="结果："></a>结果：</h3><pre class="line-numbers language-none"><code class="language-none">Employee{name='辉哥', age=28, sex=男, position='程序猿'}Employee{name='小红', age=23, sex=男, position='程序猿'}Employee{name='小辉', age=25, sex=男, position='程序猿'}Employee{name='小民', age=26, sex=男, position='程序猿'}Employee{name='小芸', age=22, sex=女, position='测试'}Employee{name='小方', age=18, sex=女, position='测试'}Employee{name='可儿', age=21, sex=女, position='设计'}Employee{name='朗情', age=19, sex=女, position='设计'}12345678<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样看似也没有问题，但是如果有多个部门，每个部门有各自的实现，那么我们就要在Boss类中增加一遍遍历逻辑，这样Boss类的功能会越来越多，同时暴露了内部细节。那么我们需要定义一个迭代器接口：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface Iterator {    /**     * 是否还有下一个元素      *      * @return true表示有，false表示没有     */    boolean hasNext();    /**     * 返回当前元素，并将位置移至下一位     */    Object next();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>小民的迭代器：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MinIterator implements Iterator{    private List&lt;Employee&gt; list;    private int position;    public MinIterator(List&lt;Employee&gt; list){        this.list = list;    }    @Override    public boolean hasNext() {        return !(position &gt; list.size() - 1 || list.get(position) == null);    }    @Override    public Object next() {        Employee e = list.get(position);        position++;        return e;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>小辉的迭代器：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class HuiIterator implements Iterator{    private Employee[] array;    private int position;    public HuiIterator(Employee[] array){        this.array = array;    }    @Override    public boolean hasNext() {        return !(position &gt; array.length - 1 || array[position] == null);    }    @Override    public Object next() {        Employee e = array[position];        position++;        return e;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>定义容器类的接口</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface Company {    /**     * 返回一个迭代器对象     *      * @return 迭代器对象     */    Iterator iterator();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改一下之前的两个容器类：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class CompanyHui implements Company{    private Employee[] array = new Employee[3];    public CompanyHui(){        array[0] = new Employee("辉哥", 28, "男", "程序猿");        array[1] = new Employee("小红", 23, "男", "程序猿");        array[2] = new Employee("小辉", 25, "男", "程序猿");    }    public Employee[] getEmployees(){        return array;    }    @Override    public Iterator iterator() {        return new HuiIterator(array);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class CompanyMin implements Company{    private List&lt;Employee&gt; list = new ArrayList&lt;&gt;();    public CompanyMin(){        list.add(new Employee("小民", 26, "男", "程序猿"));        list.add(new Employee("小芸", 22, "女", "测试"));        list.add(new Employee("小方", 18, "女", "测试"));        list.add(new Employee("可儿", 21, "女", "设计"));        list.add(new Employee("朗情", 19, "女", "设计"));    }    public List&lt;Employee&gt; getEmployees(){        return list;    }    @Override    public Iterator iterator() {        return new MinIterator(list);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Boss查看：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Boss {    public static void main(String[] args) {        CompanyHui hui = new CompanyHui();        check(hui.iterator());        CompanyMin min = new CompanyMin();        check(min.iterator());    }    private static void check(Iterator iterator){        while (iterator.hasNext()) {            System.out.println(iterator.next().toString());        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果不变，就不重复写了。</p><h2 id="Android源码中的模式实现"><a href="#Android源码中的模式实现" class="headerlink" title="Android源码中的模式实现"></a>Android源码中的模式实现</h2><h3 id="Cursor"><a href="#Cursor" class="headerlink" title="Cursor"></a>Cursor</h3><p>当我们使用SQLiteDatabase的query方法查询数据库时，会返回一个Cursor游标对象，该游标的实质就是一个具体的迭代器，我们可以使用它来遍历数据库查询所得的结果集。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>迭代器模式发展至今，几乎所有的高级语言都有相应的内置实现，对于开发者而言，已经极少会自己去实现迭代器了，所以本章内容更多的是了解而非应用。</p></blockquote><ol><li><p>优点</p><ul><li>符合面向对象设计原则中的单一职责原则。</li><li>支持对容器对象的多种遍历。弱化了容器类与遍历算法之间的关系。</li></ul></li><li><p>缺点</p><ul><li>类文件的增加。</li><li>会出现ConcurrentModificationException异常。</li><li>遍历过程是一个单向且不可逆的遍历。</li></ul></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://dev.yesky.com/474/2168474.shtml">深入浅出Java设计模式之迭代器模式</a></li><li><a href="http://blog.csdn.net/lirunfa/article/details/7353857">ConcurrentModificationException异常</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Java </tag>
            
            <tag> DesignPattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Android 源码设计模式解析与实战》读书笔记 - 状态模式</title>
      <link href="20170318/designpattern-behavior-state/"/>
      <url>20170318/designpattern-behavior-state/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="《Android-源码设计模式解析与实战》读书笔记-状态模式"><a href="#《Android-源码设计模式解析与实战》读书笔记-状态模式" class="headerlink" title="《Android 源码设计模式解析与实战》读书笔记 - 状态模式"></a>《Android 源码设计模式解析与实战》读书笔记 - 状态模式</h1><blockquote><p>定义：状态模式中的行为是由状态来决定，不同的状态下有不同的行为。当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。</p></blockquote><a id="more"></a><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为。</li><li>代码中包含大量与对象状态有关的条件语句，例如，一个操作中含有大量的多分支语句，且这些分支依赖于该对象的状态。<br><img src="http://blog-1251678165.coscd.myqcloud.com/2018-03-18-State.png"></li></ol><h2 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h2><blockquote><p>实现效果：首先将电视的状态分为开机与关机状态，开机时可以通过遥控器实现频道切换和调节音量，但是关机时，这些操作都会失效。</p></blockquote><h3 id="普通的实现方法："><a href="#普通的实现方法：" class="headerlink" title="普通的实现方法："></a>普通的实现方法：</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class TVController {    //开机状态    private final static int POWER_ON = 1;    //关机状态    private final static int POWER_OFF = 2;    //默认状态    private int mState = POWER_OFF;    public void powerOn(){        if(mState ==POWER_OFF){            System.out.println("电视开机了");        }        mState = POWER_ON;    }    public void powerOff(){        if(mState ==POWER_ON){            System.out.println("电视关机了");        }        mState = POWER_OFF;    }    public void nextChannel(){        if(mState ==POWER_ON){            System.out.println("下一频道");        }else{            System.out.println("没有开机");        }    }    public void prevChannel(){        if(mState ==POWER_ON){            System.out.println("上一频道");        }else{            System.out.println("没有开机");        }    }    public void turnUp(){        if(mState ==POWER_ON){            System.out.println("调高音量");        }else{            System.out.println("没有开机");        }    }    public void turnDown(){        if(mState ==POWER_ON){            System.out.println("调低音量");        }else{            System.out.println("没有开机");        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，每次执行通过判断当前状态来进行操作，部分的代码重复，假设状态和功能增加，就会越来越难以维护。这时可以使用状态模式，如下：</p><h3 id="电视的操作"><a href="#电视的操作" class="headerlink" title="电视的操作"></a>电视的操作</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * 电视状态接口，定义了电视的操作函数 * * */public interface TVState {    public void nextChannel();    public void prevChannel();    public void turnUp();    public void turnDown();}12345678910111213<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="关机状态"><a href="#关机状态" class="headerlink" title="关机状态"></a>关机状态</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * * 关机状态，操作无结果 * * */public class PowerOffState implements TVState{    @Override    public void nextChannel() {    }    @Override    public void prevChannel() {    }    @Override    public void turnUp() {    }    @Override    public void turnDown() {    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="开机状态"><a href="#开机状态" class="headerlink" title="开机状态"></a>开机状态</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * * 开机状态，操作有效 * * */public class PowerOnState implements TVState{    @Override    public void nextChannel() {        System.out.println("下一频道");    }    @Override    public void prevChannel() {        System.out.println("上一频道");    }    @Override    public void turnUp() {        System.out.println("调高音量");    }    @Override    public void turnDown() {        System.out.println("调低音量");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="电源操作接口"><a href="#电源操作接口" class="headerlink" title="电源操作接口"></a>电源操作接口</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * 电源操作接口 * * */public interface PowerController {    public void powerOn();    public void powerOff();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="电视遥控器"><a href="#电视遥控器" class="headerlink" title="电视遥控器"></a>电视遥控器</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * 电视遥控器 * * */public class TVController implements PowerController{    TVState mTVState;    public void setTVState(TVState mTVState){        this.mTVState = mTVState;    }    @Override    public void powerOn() {        setTVState(new PowerOnState());        System.out.println("开机了");    }    @Override    public void powerOff() {        setTVState(new PowerOffState());        System.out.println("关机了");    }    public void nextChannel(){        mTVState.nextChannel();    }    public void prevChannel(){        mTVState.prevChannel();    }    public void turnUp(){        mTVState.turnUp();    }    public void turnDown(){        mTVState.turnDown();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="调用："><a href="#调用：" class="headerlink" title="调用："></a>调用：</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Client {    public static void main(String[] args) {        TVController tvController = new TVController();        //设置开机状态        tvController.powerOn();        //下一频道        tvController.nextChannel();        //调高音量        tvController.turnUp();        //关机        tvController.powerOff();        //调低音量，此时不会生效        tvController.turnDown();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><pre class="line-numbers language-none"><code class="language-none">开机了下一频道调高音量关机了1234<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，状态模式将这些行为封装到状态类中，在进行操作时将这些功能转发给状态对象，不同的状态有不同的实现，去除了重复了 if-else 语句，这正是状态模式的精髓所在。</p><h2 id="与策略模式的区别"><a href="#与策略模式的区别" class="headerlink" title="与策略模式的区别"></a>与策略模式的区别</h2><p>状态模式与策略模式的结构几乎是一样的，就像是孪生兄弟。但是他们的目地、本质不一样。状态模式的行为是平行的、不可替换的，策略模式的行为是彼此独立的、可相互替换的。状态模式，通常是自我控制状态的改变。而策略模式，是由外部指定使用什么样的策略。</p><h2 id="Android-实战中的使用"><a href="#Android-实战中的使用" class="headerlink" title="Android 实战中的使用"></a>Android 实战中的使用</h2><ol><li>登录系统，根据用户是否登录，判断事件的处理方式。</li><li>Wi-Fi 管理，在不同的状态下，WiFi 的扫描请求处理不一。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>优点<ul><li>将所有与一个特定的状态相关的行为都放入一个状态对象中，它提供了一个更好的方法来组织与特定状态相关的代码，将繁琐的状态判断转换成结构清晰的状态类族，在避免代码膨胀的同时也保证了可扩展性与可维护性。</li></ul></li><li>缺点<ul><li>状态模式的使用必然会增加系统类和对象的个数。</li></ul></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Java </tag>
            
            <tag> DesignPattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Android 源码设计模式解析与实战》读书笔记 - 策略模式</title>
      <link href="20170318/designpattern-behavior-stragety/"/>
      <url>20170318/designpattern-behavior-stragety/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="《Android-源码设计模式解析与实战》读书笔记-策略模式"><a href="#《Android-源码设计模式解析与实战》读书笔记-策略模式" class="headerlink" title="《Android 源码设计模式解析与实战》读书笔记 - 策略模式"></a>《Android 源码设计模式解析与实战》读书笔记 - 策略模式</h1><blockquote><p>通常如果一个问题有多个解决方案时，最简单的就是利用 if-else 或者 switch-case 方式根据不同的情景选择不同的解决方案，但是这样耦合性太高 、代码臃肿、难以维护等。这时就可以使用策略模式来解决。<br>定义：策略模式定义了一系列的算法，并将每一个算法封装起来，而且使他们还可以相互替换。策略模式让算法独立于使用它的客户而独立变化。</p></blockquote><a id="more"></a><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>针对同一类型问题的多种处理方式，仅仅是具体行为有差别时。</li><li>需要安全地封装多种同一类型的操作时。</li><li>出现同一抽象类有多个子类，而又需要使用 if-else 或者 switch-case 来选择具体子类时。</li></ol><h2 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h2><p><img src="http://blog-1251678165.coscd.myqcloud.com/2018-03-18-Stragety-2.png"></p><h2 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h2><blockquote><p>需求：计算图书价格，初级会员没有折扣，中级会员打 9 折，高级会员打 8 折。如果一般写法，应该是 if-else 判断他是什么级别的会员，在计算相应的折扣。下面使用策略模式来进行实现。</p></blockquote><h3 id="抽象折扣类"><a href="#抽象折扣类" class="headerlink" title="抽象折扣类"></a>抽象折扣类</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface MemberStrategy {    /**     * 计算图书的价格     * @param booksPrice    图书的原价     * @return    计算出打折后的价格     */    public double calcPrice(double booksPrice);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="初级会员折扣类"><a href="#初级会员折扣类" class="headerlink" title="初级会员折扣类"></a>初级会员折扣类</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class PrimaryMemberStrategy implements MemberStrategy{    /**     * 初级会员折扣     */    @Override    public double calcPrice(double booksPrice) {        System.out.println("对于初级会员的没有折扣");        return booksPrice;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="中级会员折扣类"><a href="#中级会员折扣类" class="headerlink" title="中级会员折扣类"></a>中级会员折扣类</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class IntermediateMemberStrategy implements MemberStrategy{    /**     * 中级会员折扣     */    @Override    public double calcPrice(double booksPrice) {        System.out.println("对于中级会员的折扣为10%");        return booksPrice * 0.9;    }}12345678910<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="高级会员折扣类"><a href="#高级会员折扣类" class="headerlink" title="高级会员折扣类"></a>高级会员折扣类</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class AdvancedMemberStrategy implements MemberStrategy{    /**     * 高级会员折扣     */    @Override    public double calcPrice(double booksPrice) {        System.out.println("对于高级会员的折扣为20%");        return booksPrice * 0.8;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="价格类"><a href="#价格类" class="headerlink" title="价格类"></a>价格类</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Price {    //持有一个具体的策略对象    private MemberStrategy strategy;    /**     * 构造函数，传入一个具体的策略对象     * @param strategy    具体的策略对象     */    public Price(MemberStrategy strategy){        this.strategy = strategy;    }    /**     * 计算图书的价格     * @param booksPrice    图书的原价     * @return    计算出打折后的价格     */    public double quote(double booksPrice){        return this.strategy.calcPrice(booksPrice);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Client {    public static void main(String[] args) {        //选择并创建需要使用的策略对象        MemberStrategy strategy1 = new AdvancedMemberStrategy();        //创建环境        Price price = new Price(strategy1);        //计算价格        double quote = price.quote(300);        System.out.println("图书的最终价格为：" + quote);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><pre class="line-numbers language-none"><code class="language-none">对于高级会员的折扣为20%图书的最终价格为：240.012<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="策略模式和工厂模式的区别"><a href="#策略模式和工厂模式的区别" class="headerlink" title="策略模式和工厂模式的区别"></a>策略模式和工厂模式的区别</h2><table><thead><tr><th>工厂模式</th><th>策略模式</th></tr></thead><tbody><tr><td>创建型的设计模式</td><td>行为型的设计模式</td></tr><tr><td>关注对象创建</td><td>关注行为的选择</td></tr><tr><td>黑盒子（无需知道具体的实现过程）</td><td>白盒子（知道具体的实现过程）</td></tr></tbody></table><h2 id="Android-源码中的策略模式实现"><a href="#Android-源码中的策略模式实现" class="headerlink" title="Android 源码中的策略模式实现"></a>Android 源码中的策略模式实现</h2><p>时间插值器（TimeInterpolator）</p><p>LinearInterpolator、AccelerateInterpolator、CycleInterpolator 等实现 Interpolator，通过 getInterpolator（float input）获取当前的时间百分比，以此来计算动画的属性值。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>策略模式主要用来分离算法，在相同的行为抽象下有不同的具体实现策略。这个模式很好地演示了开闭原则，也就是定义抽象，注入不同的实现，从而达到很好的可扩展性。</p><ol><li>优点：<ul><li>结构清晰明了、使用简单直观。</li><li>耦合度相对而言较低，扩展方便。</li><li>操作封装也更为彻底，数据更为安全。</li></ul></li><li>缺点：<ul><li>随着策略的增加，子类也会变得繁多。</li></ul></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="http://www.cnblogs.com/java-my-life/archive/2012/05/10/2491891.html">《JAVA 与模式》之策略模式</a></li><li><a href="http://www.cnblogs.com/me115/p/3790615.html">策略模式和工厂模式的区别</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Java </tag>
            
            <tag> DesignPattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Android 源码设计模式解析与实战》读书笔记 - 模板方法模式</title>
      <link href="20170318/designpattern-behavior-template-method/"/>
      <url>20170318/designpattern-behavior-template-method/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="《Android-源码设计模式解析与实战》读书笔记-模板方法模式"><a href="#《Android-源码设计模式解析与实战》读书笔记-模板方法模式" class="headerlink" title="《Android 源码设计模式解析与实战》读书笔记 - 模板方法模式"></a>《Android 源码设计模式解析与实战》读书笔记 - 模板方法模式</h1><blockquote><p>模板方法模式是结构最简单的行为型设计模式，也是所有模式中最为常见的几个模式之一，是基于继承的代码复用的基本技术。在其结构中只存在父类与子类之间的继承关系。<br>定义：定义一个操作中的算法的框架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p></blockquote><a id="more"></a><h2 id="模板方法模式中的方法"><a href="#模板方法模式中的方法" class="headerlink" title="模板方法模式中的方法"></a>模板方法模式中的方法</h2><p><img src="http://blog-1251678165.coscd.myqcloud.com/2018-03-18-Template.png"></p><h3 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h3><p>一个模板方法是定义在抽象类中的，把基本操作方法组合在一起形成一个总算法或一个总行为的方法。这个模板方法定义在抽象类中，并由子类不加以修改地完全继承下来。所以模板方法大多会定义为<strong>final 类型</strong>，指明主要的逻辑功能在子类中不能被重写。模板方法是一个具体方法，它给出了一个顶层逻辑框架，而逻辑的组成步骤在抽象类中可以是具体方法，也可以是抽象方法。由于模板方法是具体方法，因此模板方法模式中的抽象层只能是抽象类，而不是接口。</p><h3 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h3><p>（1）抽象方法：一个抽象方法由<strong>抽象类声明，由具体子类实现</strong>。在 Java 语言里抽象方法以 abstract 关键字标示。<br>（2）钩子方法：一个钩子方法由抽象类<strong>声明并实现</strong>，而子类会加以扩展。子类可以通过扩展钩子方法来影响模板方法的逻辑。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>（1）多个子类有公有的方法，并且逻辑基本相同。=<br>（2）重要、复杂的算法，可以把核心算法设计为模板方法，周边的相关细节功能由各个子类实现。<br>（3）重构时，模板方法是一个经常使用的模式，把相同的代码抽取到父类中，然后通过钩子方法约束其行为。</p><h2 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h2><blockquote><p>以电脑开机为例，假设现在有两台电脑，一台 Windows 系统电脑，一台 Mac 系统电脑。但是开机流程基本一致：步骤为开启电源、系统检查、加载系统、检查是否需要登录。</p></blockquote><h3 id="抽象的-Computer"><a href="#抽象的-Computer" class="headerlink" title="抽象的 Computer"></a>抽象的 Computer</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * 抽象的 Computer */public abstract class AbstractComputer {    //下面是抽象方法，子类可以覆盖,不允许外部直接调用这些方法，所以用protected    /**     * 开启电源     */    protected abstract void powerOn();    /**     * 检查硬件     */    protected abstract void checkHardware();    /**     * 载入操作系统     */    protected abstract void loadOS();    /**     * 登录     */    protected abstract void login();    //下面是钩子方法，声明并实现    /**     * 是否需要登录     *     * @return true为需要登录     */    protected boolean isLogin(){        return true;    }    //下面是模板方法，定义为final，子类不能覆盖此方法    /**     * 启动计算机方法，步骤为开启电源、系统检查、加载系统、检查是否登录。     */    public final void startUp(){        System.out.println("--------开机 START--------");        powerOn();        checkHardware();        loadOS();        if(isLogin()){            login();        }        System.out.println("-------- 开机 END --------");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Windows-系统电脑（不需登录）："><a href="#Windows-系统电脑（不需登录）：" class="headerlink" title="Windows 系统电脑（不需登录）："></a>Windows 系统电脑（不需登录）：</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * Windows系统电脑 */public class WindowsComputer extends AbstractComputer{    @Override    protected void powerOn() {        System.out.println("Windows电脑开启电源");    }    @Override    protected void checkHardware() {        System.out.println("Windows电脑检查硬件");    }    @Override    protected void loadOS() {        System.out.println("Windows电脑载入操作系统");    }    @Override    protected void login() {    }    @Override    protected boolean isLogin() {        return false;//返回false，不需登录    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Mac-系统电脑（需登录）："><a href="#Mac-系统电脑（需登录）：" class="headerlink" title="Mac 系统电脑（需登录）："></a>Mac 系统电脑（需登录）：</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * Mac系统电脑 */public class MacComputer extends AbstractComputer{    @Override    protected void powerOn() {        System.out.println("Mac电脑开启电源");    }    @Override    protected void checkHardware() {        System.out.println("Mac电脑检查硬件");    }    @Override    protected void loadOS() {        System.out.println("Mac电脑载入操作系统");    }    @Override    protected void login() {        System.out.println("Mac电脑登录");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="调用："><a href="#调用：" class="headerlink" title="调用："></a>调用：</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Client {    public static void main(String[] args) {        AbstractComputer comp = new WindowsComputer();        comp.startUp();        comp = new MacComputer();        comp.startUp();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="结果："><a href="#结果：" class="headerlink" title="结果："></a>结果：</h3><pre class="line-numbers language-none"><code class="language-none">--------开机 START--------Windows电脑开启电源Windows电脑检查硬件Windows电脑载入操作系统-------- 开机 END ----------------开机 START--------Mac电脑开启电源Mac电脑检查硬件Mac电脑载入操作系统Mac电脑登录-------- 开机 END --------1234567891011<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Android-源码中的模板方法模式"><a href="#Android-源码中的模板方法模式" class="headerlink" title="Android 源码中的模板方法模式"></a>Android 源码中的模板方法模式</h2><h3 id="AsyncTask"><a href="#AsyncTask" class="headerlink" title="AsyncTask"></a>AsyncTask</h3><p>在使用 AsyncTask 时，我们都知道把耗时操作放到 doInBackground(Params… params)中，在 doInBackground 之前，如果想做一些初始化操作，可以把实现写在 onPreExecute 中，当 doInBackground 执行完后会执行 onPostExecute 方法，而我们只需要构建 AsyncTask 对象，然后执行 execute 方法。</p><h3 id="Activity-的生命周期"><a href="#Activity-的生命周期" class="headerlink" title="Activity 的生命周期"></a>Activity 的生命周期</h3><p>ActivityThread 的 main 函数被调用后，依次执行 Activity 的 onCreate、onStart、onResume 函数，用户通常在 Activity 的子类中覆写 onCreate 方法，并且在该方法中调用 setContentView 来设置布局。</p><h2 id="与其他模式区别"><a href="#与其他模式区别" class="headerlink" title="与其他模式区别"></a>与其他模式区别</h2><ul><li>（1）工厂方法是模板方法的一种特殊版本。</li><li>（2）策略模式和模板方法模式都是封装算法，一个用组合，一个用继承。</li><li>（3）策略模式和模板模式通常可以互相替换。它们都像试卷，策略模式是选择题，模板模式是填空题。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>模板方法模式用 4 个字概括就是：流程封装。也就是把某个固定的流程封装到一个 final 方法中，并且让子类能够定制这个流程中的某些或者所有步骤，这就要求父类提取公用的代码，提升代码的复用率，同时带来了更好的可扩展性。</p></blockquote><ol><li><p>优点</p><ul><li>（1）封装不变部分，扩展可变部分。</li><li>（2）提取公共部分代码，便于维护。</li></ul></li><li><p>缺点</p><ul><li>需要为每一个基本方法的不同实现提供一个子类，如果父类中可变的基本方法太多，将会导致类的个数增加，系统更加庞大，设计也更加抽象，此时，可结合桥接模式来进行设计。</li></ul></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="http://www.cnblogs.com/lzhp/p/3404514.html"> 模板方法模式（Head first 设计模式——7）</a></li><li><a href="http://blog.csdn.net/zhengzhb/article/details/7405608"> 模板方法模式</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Java </tag>
            
            <tag> DesignPattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Android 源码设计模式解析与实战》读书笔记 - 组合模式</title>
      <link href="20170318/designpattern-structure-composite/"/>
      <url>20170318/designpattern-structure-composite/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="《Android-源码设计模式解析与实战》读书笔记-组合模式"><a href="#《Android-源码设计模式解析与实战》读书笔记-组合模式" class="headerlink" title="《Android 源码设计模式解析与实战》读书笔记 - 组合模式"></a>《Android 源码设计模式解析与实战》读书笔记 - 组合模式</h1><blockquote><p>组合模式也称为部分-整体模式，结构型设计模式之一。组合模式比较简单，它将一组相似的对象当作一个对象处理，并根据树状结构来组合对象<br>定义：将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。</p></blockquote><a id="more"></a><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>表示对象的部分-整体层次结构时。</li><li>从一个整体中能够独立出部分模块或功能的场景。</li></ol><h2 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h2><h3 id="安全组合模式"><a href="#安全组合模式" class="headerlink" title="安全组合模式"></a>安全组合模式</h3><p><img src="http://blog-1251678165.coscd.myqcloud.com/2018-03-18-composite.png" alt="Composite"></p><ul><li>（1）<code>Component</code>：抽象根节点，为组合中的对象声明接口。在适当的情况下，实现所有类共有接口的缺省行为。声明一个接口用于访问和管理 Component 的子节点。可在递归结构中定义一个接口，用于访问一个父节点，并在合适的情况下实现它。</li><li>（2）<code>Composite</code>：定义有子节点的那些枝干节点行为，存储子节点，在 Component 接口中实现与子节点有关的操作。</li><li>（3）<code>Leaf</code>：在组合中表示叶子节点对象，叶子节点没有子节点，在组合中定义节点对象的行为。</li><li>（4）<code>Client</code>：通过 Component 接口操纵组合节点的对象。</li></ul><blockquote><p>如图这种将组合所使用的方法全部定义在抽象类的方式称为<strong>透明的组合模式</strong>，如果将 Component 中的 Add、Remove、GetChild 去除，只在 Composite 中单独添加，这种方式称为<strong>安全的组合模式</strong>。然而后者违背了依赖倒置原则。</p></blockquote><p>通用组合摸底代码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * Created by Weicools on 2017/3/17. * &lt;p&gt; * desc: 抽象根节点，为组合中的对象声明接口。在适当的情况下，实现所有类共有接口的缺省行为 */public abstract class Component {    protected String name;    public Component(String name) {        this.name = name;    }    /**     * 需要子类实现     */    public abstract void doSomething();}/** * Created by Weicools on 2017/3/17. * &lt;p&gt; * desc: 具体分支节点，定义有子节点行为 */public class Composite extends Component {    /**     * 存储节点容器     */    private List&lt;Component&gt; mComponentList = new ArrayList&lt;&gt;();    public Composite(String name) {        super(name);    }    @Override    public void doSomething() {        System.out.println(name);        if (mComponentList != null) {            for (Component component : mComponentList) {                component.doSomething();            }        }    }    /**     * 添加子节点     * @param component 子节点     */    public void addChild(Component component) {        mComponentList.add(component);    }    /**     * 移除子节点     * @param component 子节点     */    public void removeChild(Component component) {        mComponentList.remove(component);    }    /**     * 获取子节点     * @param index 子节点下标     * @return 子节点     */    public Component getChildren(int index) {        return mComponentList.get(index);    }}/** * Created by Weicools on 2017/3/18. * &lt;p&gt; * desc: 具体叶子节点，叶子节点没有子节点，在组合中定义节点对象的行为 */public class Leaf extends Component {    public Leaf(String name) {        super(name);    }    @Override    public void doSomething() {        System.out.println(name);    }}/** * Created by Weicools on 2017/3/18. * &lt;p&gt; * desc: 通过Component接口操纵组合节点的对象 */public class Client {    public static void main(String[] args) {        //构造一个根节点        Composite root = new Composite("Root");        //构造两个分支子节点        Composite branch1 = new Composite("Branch1");        Composite branch2 = new Composite("Branch2");        //构造两个叶子节点        Leaf leaf1 = new Leaf("Leaf1");        Leaf leaf2 = new Leaf("Leaf2");        //将叶子节点添加到分支子节点        branch1.addChild(leaf1);        branch2.addChild(leaf2);        //将分支子节点添加到根节点        root.addChild(branch1);        root.addChild(branch2);        root.doSomething();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="透明组合模式"><a href="#透明组合模式" class="headerlink" title="透明组合模式"></a>透明组合模式</h3><p>上面安全组合模式与依赖倒置原则相违背，所定义的抽象 Component 在这里的作用不大，既然是面向接口编程，那么更多的应该是完善接口设计，对上面的接口做一些修改：<br><img src="http://blog-1251678165.coscd.myqcloud.com/2018-03-18-composite-transparent.png"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * Created by Weicools on 2017/3/17. * &lt;p&gt; * desc: 抽象根节点，为组合中的对象声明接口。在适当的情况下，实现所有类共有接口的缺省行为 */public abstract class Component {    protected String name;    public Component(String name) {        this.name = name;    }    /**     * 具体由子类实现     */    public abstract void doSomething();    /**     * 添加子节点     *     * @param child 子节点     */    public abstract void addChild(Component child);    /**     * 移除子节点     *     * @param child 子节点     */    public abstract void removeChild(Component child);    /**     * 获取子节点     *     * @param index 子节点下标     * @return 子节点     */    public abstract Component getChildren(int index);}/** * Created by Weicools on 2017/3/17. * &lt;p&gt; * desc: 具体分支节点，定义有子节点行为 */public class Composite extends Component {    /**     * 存储节点容器     */    private List&lt;Component&gt; mComponentList = new ArrayList&lt;&gt;();    public Composite(String name) {        super(name);    }    @Override    public void doSomething() {        System.out.println(name);        if (mComponentList != null) {            for (Component component : mComponentList) {                component.doSomething();            }        }    }    @Override    public void addChild(Component component) {        mComponentList.add(component);    }    @Override    public void removeChild(Component component) {        mComponentList.remove(component);    }    @Override    public Component getChildren(int index) {        return mComponentList.get(index);    }}/** * Created by Weicools on 2017/3/18. * &lt;p&gt; * desc: 具体叶子节点，叶子节点没有子节点，某些操作抛出异常 */public class Leaf extends Component {    public Leaf(String name) {        super(name);    }    @Override    public void doSomething() {        System.out.println(name);    }    @Override    public void addChild(Component child) {        throw new UnsupportedOperationException("叶子节点没有子节点");    }    @Override    public void removeChild(Component child) {        throw new UnsupportedOperationException("叶子节点没有子节点");    }    @Override    public Component getChildren(int index) {        throw new UnsupportedOperationException("叶子节点没有子节点");    }}/** * Created by Weicools on 2017/3/18. * &lt;p&gt; * desc: 通过Component接口操纵组合节点的对象 */public class Client {    public static void main(String[] args) {        //构造一个根节点        Composite root = new Composite("Root");        //构造两个分支子节点        Composite branch1 = new Composite("Branch1");        Composite branch2 = new Composite("Branch2");        //构造两个叶子节点        Leaf leaf1 = new Leaf("Leaf1");        Leaf leaf2 = new Leaf("Leaf2");        //将叶子节点添加到分支子节点        branch1.addChild(leaf1);        branch2.addChild(leaf2);        //将分支子节点添加到根节点        root.addChild(branch1);        root.addChild(branch2);        root.doSomething();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h2><blockquote><p>以文件系统为例，文件系统包含文件和文件夹，而文件夹也可以包含文件。</p></blockquote><h3 id="文件和文件夹的抽象类：（Component）"><a href="#文件和文件夹的抽象类：（Component）" class="headerlink" title="文件和文件夹的抽象类：（Component）"></a>文件和文件夹的抽象类：（Component）</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * Created by Weicools on 2017/3/18. * &lt;p&gt; * desc: 表示文件和文件夹的抽象类(Component角色) */public abstract class Dir {    //申明List成员变量存储文件夹下所有元素    protected List&lt;Dir&gt; mDirList = new ArrayList&lt;&gt;();    //文件名或者文件夹名称    private String name;    public Dir(String name) {        this.name = name;    }    /**     * 添加一个文件或者文件夹     *     * @param dir 文件或者文件夹     */    public abstract void addDir(Dir dir);    /**     * 删除文件或者文件夹     *     * @param dir 文件或者文件夹     */    public abstract void removeDir(Dir dir);    /**     * 情况文件夹下所有元素     */    public abstract void clear();    /**     * 输出文件夹目录结构     */    public abstract void print();    /**     * 获取文件夹下所有的文件和子文件夹     *     * @return 文件和子文件夹     */    public abstract List&lt;Dir&gt; getFiles();    public String getName() {        return name;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="表示文件夹的类：（Composite）"><a href="#表示文件夹的类：（Composite）" class="headerlink" title="表示文件夹的类：（Composite）"></a>表示文件夹的类：（Composite）</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * Created by Weicools on 2017/3/18. * &lt;p&gt; * desc: 文件夹类(Composite角色) */public class Folder extends Dir {    public Folder(String name) {        super(name);    }    @Override    public void addDir(Dir dir) {        mDirList.add(dir);    }    @Override    public void removeDir(Dir dir) {        mDirList.remove(dir);    }    @Override    public void clear() {        mDirList.clear();    }    @Override    public void print() {        System.out.print(getName() + "(");        Iterator&lt;Dir&gt; iterator = mDirList.iterator();        while (iterator.hasNext()) {            Dir dir = iterator.next();            dir.print();            if (iterator.hasNext()) {                System.out.print(", ");            }        }        System.out.print(")");    }    @Override    public List&lt;Dir&gt; getFiles() {        return mDirList;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="表示文件夹的类：（Leaf）"><a href="#表示文件夹的类：（Leaf）" class="headerlink" title="表示文件夹的类：（Leaf）"></a>表示文件夹的类：（Leaf）</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * Created by Weicools on 2017/3/18. * &lt;p&gt; * desc: 文件类(Leaf角色) */public class File extends Dir {    public File(String name) {        super(name);    }    @Override    public void addDir(Dir dir) {        throw new UnsupportedOperationException("文件不支持该操作");    }    @Override    public void removeDir(Dir dir) {        throw new UnsupportedOperationException("文件不支持该操作");    }    @Override    public void clear() {        throw new UnsupportedOperationException("文件不支持该操作");    }    @Override    public void print() {        System.out.print(getName());    }    @Override    public List&lt;Dir&gt; getFiles() {        throw new UnsupportedOperationException("文件不支持该操作");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="客户测试类："><a href="#客户测试类：" class="headerlink" title="客户测试类："></a>客户测试类：</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * Created by Weicools on 2017/3/18. * &lt;p&gt; * desc: 测试 */public class Client {    public static void main(String[] args) {        //构造一个目录表示SD卡根目录        Dir sdCard = new Folder("Storage");        //SD卡下有一个文件"设计模式.pdf"        sdCard.addDir(new File("设计模式.pdf"));        //SD卡下有3个子文件夹"ADM", "Android", "Books"        Dir adm = new Folder("ADM");        adm.addDir(new File("google.html"));        sdCard.addDir(adm);        Dir an = new Folder("Android");        an.addDir(new File("cache.txt"));        sdCard.addDir(an);        Dir books = new Folder("Books");        books.addDir(new File("跳槽指南.md"));        sdCard.addDir(books);        sdCard.print();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="输出结果："><a href="#输出结果：" class="headerlink" title="输出结果："></a>输出结果：</h3><pre class="line-numbers language-none"><code class="language-none">Storage(设计模式.pdf, ADM(google.html), Android(cache.txt), Books(跳槽指南.md))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="Android-源码中的模式实现"><a href="#Android-源码中的模式实现" class="headerlink" title="Android 源码中的模式实现"></a>Android 源码中的模式实现</h2><ul><li>View 和 ViewGroup 的嵌套组合</li></ul><p>View 和 ViewGroup 的结构很像上面的 UML 类图，不过 View 的视图层级使用的是安全的组合模式。ViewGroup 有对 View 的 addView、removeView、getChildAt 等方法，想必大家也很熟悉。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>优点</p><ul><li>（1）组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，他让高层模块忽略了层次的差异，方便对整个层次结构进行控制。</li><li>（2）简化了高层模块的代码。</li><li>（3）在组合模式中增加新的枝干构件和叶子构件都很方便，无须对现有类库进行修改，符合“开闭原则”。</li><li>（4）对树形结构的控制变得简单。</li></ul></li><li><p>缺点</p><ul><li>组合模式不容易限制组合中的构件。因为大多数情况下，它们都来自于相同的抽象层，此时，必须进行类型检查来实现，这个实现过程较为复杂。</li></ul></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Java </tag>
            
            <tag> DesignPattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Android 源码设计模式解析与实战》读书笔记 - 桥接模式</title>
      <link href="20170318/designpattern-structure-bridge/"/>
      <url>20170318/designpattern-structure-bridge/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="《Android-源码设计模式解析与实战》读书笔记-桥接模式"><a href="#《Android-源码设计模式解析与实战》读书笔记-桥接模式" class="headerlink" title="《Android 源码设计模式解析与实战》读书笔记 - 桥接模式"></a>《Android 源码设计模式解析与实战》读书笔记 - 桥接模式</h1><blockquote><p>桥接模式也称为桥梁模式，是结构型设计模式之一。桥接模式中体现了“单一职责原则”、“开闭原则”、“里氏替换原则”、“依赖倒置原则”等，同时它也是很实用的一种模式。<br><strong>定义</strong>：将抽象部分 与 实现部分 分离，使它们都可以独立地进行变化。</p></blockquote><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul><li>（1）如果一个系统需要在构建的抽象化角色和具体角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系。</li><li>（2）对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，也可以考虑使用桥接模式。</li><li>（3）一个类存在两个独立变化的维度，且这两个维度都需要扩展。</li></ul><h2 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h2><p><img src="http://blog-1251678165.coscd.myqcloud.com/2018-03-18-Bridge.png" alt="Bridge"></p><ul><li>（1）<code>Abstraction</code>：抽象部分，该类保持一个对实现部分对象的引用，抽象部分中的方法需要调用实现部分的对象来实现，该类一般为抽象类。</li><li>（2）<code>RefinedAbstraction</code>：优化抽象部分，抽象部分的具体实现，该类一般是对抽象部分的方法进行完善和扩展。</li><li>（3）<code>Implementor</code>：实现部分。可以为接口或抽象类，其方法不一定要与抽象部分中的一致，一般情况下是由现实部分提供基本操作，而抽象部分定义的则是基于实现部分这些基本操作的业务方法。</li><li>（4）<code>ConcreteImplementorA</code>、<code>ConcreteImplementorB</code>：实现部分的具体实现。完善实现部分中的方法定义的具体逻辑。</li></ul><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">/** * Created by Weicools on 2017/3/18. * &lt;p&gt; * desc: 实现部分的抽象接口 */public interface Implementor {    /**     * 实现部分的接口方法     */    void operationImpl();}/** * Created by Weicools on 2017/3/18. * &lt;p&gt; * desc: 实现部分的具体实现 */public class ConcreteImplementorA implements Implementor {    @Override    public void operationImpl() {        // 实现部分的具体实现    }}/** * Created by Weicools on 2017/3/18. * &lt;p&gt; * desc: 抽象部分的抽象类 */public abstract class Abstraction {    //实现部分的引用    private Implementor mImplementor;    /**     * 通过实现部分的对象引用构造抽象部分的对象     * @param implementor 实现部分对象引用     */    public Abstraction(Implementor implementor) {        mImplementor = implementor;    }    /**     * 调用实现部分的具体方法实现     */    public void operation() {        mImplementor.operationImpl();    }}/** * Created by Weicools on 2017/3/18. * &lt;p&gt; * desc: 抽象部分的子类 */public class RefineAbstraction extends Abstraction {    /**     * 通过实现部分的对象引用构造抽象部分的对象     *     * @param implementor 实现部分对象引用     */    public RefineAbstraction(Implementor implementor) {        super(implementor);    }    public void refineOperation() {        //对Abstraction方法进行扩展    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h2><blockquote><p>以去咖啡店喝咖啡为例，我们假定咖啡有大杯加糖、大杯不加糖、小杯加糖和小杯不加糖四种<br>这四种实质上就是两种变化：一是大杯小杯，二是加糖不加糖</p></blockquote><h3 id="给咖啡添加东西的抽象类：（Implementor）"><a href="#给咖啡添加东西的抽象类：（Implementor）" class="headerlink" title="给咖啡添加东西的抽象类：（Implementor）"></a>给咖啡添加东西的抽象类：（Implementor）</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * Created by Weicools on 2017/3/18. * &lt;p&gt; * desc: */public abstract class CoffeeAdditives {    /**     * 需要往咖啡中加什么     * @return 具体添加的东西     */    public abstract String addSomething();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="加糖类实现：（ConcreteImplementorA）"><a href="#加糖类实现：（ConcreteImplementorA）" class="headerlink" title="加糖类实现：（ConcreteImplementorA）"></a>加糖类实现：（ConcreteImplementorA）</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * Created by Weicools on 2017/3/18. * &lt;p&gt; * desc: */public class AddSugar extends CoffeeAdditives {    @Override    public String addSomething() {        return "加糖";    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="原味类实现：（ConcreteImplementorB）"><a href="#原味类实现：（ConcreteImplementorB）" class="headerlink" title="原味类实现：（ConcreteImplementorB）"></a>原味类实现：（ConcreteImplementorB）</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * Created by Weicools on 2017/3/18. * &lt;p&gt; * desc: */public class Ordinary extends CoffeeAdditives {    @Override    public String addSomething() {        return "原味";    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="咖啡类：（Abstraction）"><a href="#咖啡类：（Abstraction）" class="headerlink" title="咖啡类：（Abstraction）"></a>咖啡类：（Abstraction）</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * Created by Weicools on 2017/3/18. * &lt;p&gt; * desc: */public abstract class Coffee {    protected CoffeeAdditives mAdditives;    public Coffee(CoffeeAdditives additives) {        mAdditives = additives;    }    /**     * 咖啡杯大小由子类决定     */    public abstract void makeCoffee();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="大杯咖啡：（RefinedAbstraction）"><a href="#大杯咖啡：（RefinedAbstraction）" class="headerlink" title="大杯咖啡：（RefinedAbstraction）"></a>大杯咖啡：（RefinedAbstraction）</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * Created by Weicools on 2017/3/18. * &lt;p&gt; * desc: */public class LargeCoffee extends Coffee {    public LargeCoffee(CoffeeAdditives additives) {        super(additives);    }    @Override    public void makeCoffee() {        System.out.println("大杯的" + mAdditives.addSomething() + "咖啡");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="小杯咖啡：（RefinedAbstraction）"><a href="#小杯咖啡：（RefinedAbstraction）" class="headerlink" title="小杯咖啡：（RefinedAbstraction）"></a>小杯咖啡：（RefinedAbstraction）</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * Created by Weicools on 2017/3/18. * &lt;p&gt; * desc: */public class SmallCoffee extends Coffee {    public SmallCoffee(CoffeeAdditives additives) {        super(additives);    }    @Override    public void makeCoffee() {        System.out.println("小杯的" + mAdditives.addSomething() + "咖啡");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * Created by Weicools on 2017/3/18. * &lt;p&gt; * desc: */public class Test {    public static void main(String[] args) {        AddSugar sugar = new AddSugar();        Ordinary ordinary = new Ordinary();        //大杯加糖        LargeCoffee largeSugarCoffee = new LargeCoffee(sugar);        largeSugarCoffee.makeCoffee();        //大杯原味        LargeCoffee largeOrdinaryCoffee = new LargeCoffee(ordinary);        largeOrdinaryCoffee.makeCoffee();        //小杯加糖        SmallCoffee smallSugarCoffee = new SmallCoffee(sugar);        smallSugarCoffee.makeCoffee();        //小杯原味        SmallCoffee smallOrdinaryCoffee = new SmallCoffee(ordinary);        smallOrdinaryCoffee.makeCoffee();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="结果："><a href="#结果：" class="headerlink" title="结果："></a>结果：</h3><pre class="line-numbers language-none"><code class="language-none">大杯的加糖咖啡大杯的原味咖啡小杯的加糖咖啡小杯的原味咖啡<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Android-源码中的桥接模式"><a href="#Android-源码中的桥接模式" class="headerlink" title="Android 源码中的桥接模式"></a>Android 源码中的桥接模式</h3><ul><li>桥接模式在 Android 中应用广泛，比如：在 View 的视图顶层中，CheckBox、CompoundButton、Button、TextView 和 View 之间构成一个继承关系的视图层级，每一层级都仅仅是对一种类型控件的实现，它们定义了该类控件所拥有的基本属性和行为，但是真正将他们绘制到屏幕的部分是由与 View 相关的功能实现类 DisplayList、HardwareLayer、Canvas 负责。</li><li>另外还有比较典型的 Window 与 WindowManager<br><img src="http://blog-1251678165.coscd.myqcloud.com/2018-03-18-Window%26WindowManager.png"></li></ul><p>主要代码如下：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public abstract class Window {   //部分省略   /**     * Set the window manager for use by this Window to, for example,     * display panels.  This is &lt;em&gt;not&lt;/em&gt; used for displaying the     * Window itself -- that must be done by the client.     *     * @param wm The window manager for adding new windows.     */    public void setWindowManager(WindowManager wm, IBinder appToken, String appName) {        setWindowManager(wm, appToken, appName, false);    }    /**     * Set the window manager for use by this Window to, for example,     * display panels.  This is &lt;em&gt;not&lt;/em&gt; used for displaying the     * Window itself -- that must be done by the client.     *     * @param wm The window manager for adding new windows.     */    public void setWindowManager(WindowManager wm, IBinder appToken, String appName,            boolean hardwareAccelerated) {        mAppToken = appToken;        mAppName = appName;        mHardwareAccelerated = hardwareAccelerated                || SystemProperties.getBoolean(PROPERTY_HARDWARE_UI, false);        if (wm == null) {            wm = (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);        }        //*将Window与WindowManager绑定        mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(this);    }    //部分省略 }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>Window：<a href="https://developer.android.com/reference/android/view/Window.html">https://developer.android.com/reference/android/view/Window.html</a><br>WindowManager：<a href="https://developer.android.com/reference/android/view/WindowManager.html">https://developer.android.com/reference/android/view/WindowManager.html</a></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>优点<ul><li>（1）分离抽象与现实、灵活的扩展以及对客户来说透明的实现。</li><li>（2）桥接模式可以取代多层继承，大大减少了子类的个数。</li></ul></li><li>缺点<ul><li>不容易设计，对开发者来说要有一定的经验要求。理解很容易，设计却不容易。</li></ul></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Java </tag>
            
            <tag> DesignPattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Android 源码设计模式解析与实战》读书笔记 - 外观模式</title>
      <link href="20170318/designpattern-structure-facade/"/>
      <url>20170318/designpattern-structure-facade/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="《Android-源码设计模式解析与实战》读书笔记-外观模式"><a href="#《Android-源码设计模式解析与实战》读书笔记-外观模式" class="headerlink" title="《Android 源码设计模式解析与实战》读书笔记 - 外观模式"></a>《Android 源码设计模式解析与实战》读书笔记 - 外观模式</h1><blockquote><p>外观模式(Facade)是结构型设计模式之一，它在开发中的运用频率非常高，尤其是在 SDK 模块上，是我们封装 API 的常用手段。我们经常使用的三方 SDK 基本都使用的外观模式，这样可以对用户屏蔽很多实现细节，降低用户使用成本。</p></blockquote><a id="more"></a><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><p>要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。外观模式提供一个高层次的接口，使得子系统更易于使用。</p><h2 id="2-使用场景"><a href="#2-使用场景" class="headerlink" title="2.使用场景"></a>2.使用场景</h2><ul><li>为复杂子系统提供一个简单接口，对外隐藏子系统的具体实现、隔离变化。</li><li>当你需要构建一个层次结构的子系统时，使用外观模式定义子系统中每层的入口点。如果子系统之间是相互依赖的，你可以让它们仅通过外观接口进行通信，从而简化了它们之间的依赖关系。</li></ul><h2 id="3-UML-类图"><a href="#3-UML-类图" class="headerlink" title="3.UML 类图"></a>3.UML 类图</h2><p><img src="http://blog-1251678165.coscd.myqcloud.com/2018-03-17-Facade-Pattern-1.png"></p><ul><li><code>Facade</code>：系统对外的统一接口，系统内部系统地工作。</li><li><code>其他分支</code>：子系统接口。</li></ul><p>可以看出外观模式结构很简单，但是如果没有封装，那么用户就要操作几个子系统的交互逻辑，容易出现错误。</p><h2 id="4-简单实例"><a href="#4-简单实例" class="headerlink" title="4.简单实例"></a>4.简单实例</h2><blockquote><p>手机集合了电话功能、短信功能、拍照和 GPS 等功能。那么以手机为例，简单的用外观模式实现一下。</p></blockquote><h3 id="Phone-接口与-PhoneImpl："><a href="#Phone-接口与-PhoneImpl：" class="headerlink" title="Phone 接口与 PhoneImpl："></a>Phone 接口与 PhoneImpl：</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * Created by Weicools on 2017/3/17. * &lt;p&gt; * desc: */public interface Phone {    /**     * 打电话     */    void call();    /**     * 挂断     */    void hangUp();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * Created by Weicools on 2017/3/17. * &lt;p&gt; * desc: 电话模块实现 */public class PhoneImpl implements Phone {    @Override    public void call() {        System.out.println("打电话");    }    @Override    public void hangUp() {        System.out.println("挂断电话");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Camera-接口与-Camera-的实现类："><a href="#Camera-接口与-Camera-的实现类：" class="headerlink" title="Camera 接口与 Camera 的实现类："></a>Camera 接口与 Camera 的实现类：</h3><pre class="line-numbers language-none"><code class="language-none">/** * Created by Weicools on 2017/3/17. * &lt;p&gt; * desc: */public interface Camera {    /**     * 打开相机     */    void open();    /**     * 拍照     */    void takePicture();    /**     * 关闭相机     */    void close();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * Created by Weicools on 2017/3/17. * &lt;p&gt; * desc: 相机模块实现 */public class SonyCamera implements Camera {    @Override    public void open() {        System.out.println("打开相机");    }    @Override    public void takePicture() {        System.out.println("拍个照片");    }    @Override    public void close() {        System.out.println("关闭相机");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="外观类-MobileFacade："><a href="#外观类-MobileFacade：" class="headerlink" title="外观类 MobileFacade："></a>外观类 MobileFacade：</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * Created by Weicools on 2017/3/17. * &lt;p&gt; * desc: 外观类 */public class MobileFacade {    private Phone mPhone = new PhoneImpl();    private Camera mCamera = new SonyCamera();    public void call() {        mPhone.call();    }    public void videoChat() {        System.out.println("视频正在连接……");        mCamera.open();        mPhone.call();    }    public void hangUp() {        mPhone.hangUp();    }    public void takePicture() {        mCamera.open();        mCamera.takePicture();    }    public void closeCamera() {        mCamera.close();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * Created by Weicools on 2018/3/17. * &lt;p&gt; * desc: */public class Client {    public static void main(String[] args) {        MobileFacade mobileFacade = new MobileFacade();        mobileFacade.videoChat();        mobileFacade.takePicture();        mobileFacade.closeCamera();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-none"><code class="language-none">打开相机拍照--&gt; 视频聊天接通中打开相机打电话12345<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-Android-源码中的外观模式"><a href="#5-Android-源码中的外观模式" class="headerlink" title="5.Android 源码中的外观模式"></a>5.Android 源码中的外观模式</h2><p><code>Context</code> 是 Android 开发中的最重要一个，是程序的运行环境，它封装了很多重要操作，例如: startActivity(), startService(), sendBroadcast(), bindService().</p><p><code>Context</code> 是一个抽象类，它的真正实现是<code>ContextImpl</code> 类，通过查看<code>ContextImpl</code> 源码我们可以看到<code>ContextImpl</code>内部封装了很多不同子系统的操作。例如：Activity 的跳转、发送广播、启动服务和设置壁纸等，这些工作不是在<code>ContextImpl</code> 中实现，而是交给了具体的子系统进行处理。通过<code>Context</code> 这个抽象类定义了一组接口，<code>ContextImpl</code>实现。这样用户通常情况下就不需要对每个子系统进行了解。这样对用户屏蔽了具体的实现细节，降低了使用成本。</p><h2 id="6-Summary"><a href="#6-Summary" class="headerlink" title="6.Summary"></a>6.Summary</h2><ol><li><p>优点</p><ul><li>对客户程序隐藏子系统的细节，因而减少了客户对于子系统的耦合，能够拥抱变化。</li><li>外观类对子系统的接口封装，使得系统更易于使用。</li></ul></li><li><p>缺点</p><ul><li>外观类接口膨胀。由于子系统的接口都有外观类统一对外暴露，使得外观类的 API 接口较多，在一定程度上增加了用户使用成本。</li><li>外观类没有遵循开闭原则，当业务出现变更时，可能需要直接修改外观类。</li></ul></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Java </tag>
            
            <tag> DesignPattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Android 源码设计模式解析与实战》读书笔记 - 装饰着模式</title>
      <link href="20170318/designpattern-structure-decorator/"/>
      <url>20170318/designpattern-structure-decorator/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="《Android-源码设计模式解析与实战》读书笔记-装饰着模式"><a href="#《Android-源码设计模式解析与实战》读书笔记-装饰着模式" class="headerlink" title="《Android 源码设计模式解析与实战》读书笔记 - 装饰着模式"></a>《Android 源码设计模式解析与实战》读书笔记 - 装饰着模式</h1><blockquote><p>装饰模式也称为包装模式，是结构型设计模式之一。它使用一种对客户端透明的方式来动态扩展对象的功能，是一种用于替代继承技术的一种方案。<br>定义：动态的给对象添加一些额外的职责，就增加功能来说，它比生成子类更加灵活。</p></blockquote><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul><li>需要透明且动态地扩展类的功能时。且在不影响其他对象的情况下。</li><li>当不能采用继承对系统进行扩展时可以使用装饰模式。比如 final 类。</li></ul><h2 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h2><p><img src="http://blog-1251678165.coscd.myqcloud.com/2018-03-18-decorator.png" alt="decorator"></p><ul><li><code>Component</code>：抽象组件。可以是一个接口或抽象类，其充当的就是被装饰的原始对象。</li><li><code>ConcreteComponent</code>：组件具体实现类，该类是 Component 类的基本实现，也是我们装饰的具体对象。</li><li><code>Decorator</code>：抽象装饰者，其职责就是装饰我们的组件对象，通过其子类扩展该方法以达到装饰的目的。其内部一定要有一个指向组件对象的引用。在大多数情况下，该类为抽象类，需要根据不同的装饰逻辑实现不同的具体子类。</li><li><code>ConcreteDecoratorA</code>、<code>ConcreteDecoratorB</code>：装饰着具体实现类。负责向构件添加新的职责。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * Created by Weicools on 2017/3/18. * &lt;p&gt; * desc: 抽象组件类，可以是抽象类也可以是接口 */public abstract class Component {    /**     * 抽象组件的抽象方法     */    public abstract void operator();}/** * Created by Weicools on 2017/3/18. * &lt;p&gt; * desc: 具体组件实现类 */public class ConcreteComponent extends Component {    @Override    public void operator() {        // 具体逻辑    }}/** * Created by Weicools on 2017/3/18. * &lt;p&gt; * desc: 抽象装饰者 */public abstract class Decorator extends Component {    private Component mComponent;    public Decorator(Component component) {        mComponent = component;    }    @Override    public void operator() {        mComponent.operator();    }}/** * Created by Weicools on 2017/3/18. * &lt;p&gt; * desc: 装饰者具体实现类 */public class ConcreteDecoratorA extends Decorator {    public ConcreteDecoratorA(Component component) {        super(component);    }    @Override    public void operator() {        operatorA();        super.operator();        operatorB();    }    public void operatorA() {    }    public void operatorB() {    }}/** * Created by Weicools on 2017/3/18. * &lt;p&gt; * desc: 装饰者具体实现类 */public class ConcreteDecoratorB extends Decorator {    public ConcreteDecoratorB(Component component) {        super(component);    }    @Override    public void operator() {        super.operator();        operatorA();        operatorB();    }    public void operatorA() {    }    public void operatorB() {    }}/** * Created by Weicools on 2017/3/18. * &lt;p&gt; * desc: 客户调用 */public class Client {    public static void main(String[] args) {        //被装饰的组件对象        Component component = new ConcreteComponent();        //根据组件对象构造装饰者A并调用，相当于给组件对象增加装饰着A的功能        Decorator decoratorA = new ConcreteDecoratorA(component);        decoratorA.operator();        //根据组件对象构造装饰者B并调用，相当于给组件对象增加装饰着B的功能        Decorator decoratorB = new ConcreteDecoratorA(component);        decoratorB.operator();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h2><blockquote><p>以一个男孩穿衣装扮为例。实现给男孩在家与出门的穿衣装扮。</p></blockquote><h3 id="抽象组件类（Component）："><a href="#抽象组件类（Component）：" class="headerlink" title="抽象组件类（Component）："></a>抽象组件类（Component）：</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * Created by Weicools on 2017/3/18. * &lt;p&gt; * desc: */public abstract class Person {    /**     * 穿着     */    public abstract void dressed();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="具体实现类（ConcreteComponent）：表示要装扮的-Boy"><a href="#具体实现类（ConcreteComponent）：表示要装扮的-Boy" class="headerlink" title="具体实现类（ConcreteComponent）：表示要装扮的 Boy"></a>具体实现类（ConcreteComponent）：表示要装扮的 Boy</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * Created by Weicools on 2017/3/18. * &lt;p&gt; * desc: */public class Boy extends Person {    @Override    public void dressed() {        System.out.println("Boy穿了内衣内裤");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="抽象装饰类（Decorator）：PersonCloth-表示人所穿着的衣服"><a href="#抽象装饰类（Decorator）：PersonCloth-表示人所穿着的衣服" class="headerlink" title="抽象装饰类（Decorator）：PersonCloth 表示人所穿着的衣服"></a>抽象装饰类（Decorator）：PersonCloth 表示人所穿着的衣服</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * Created by Weicools on 2017/3/18. * &lt;p&gt; * desc: */public abstract class PersonCloth extends Person {    protected Person mPerson;    public PersonCloth(Person person) {        mPerson = person;    }    @Override    public void dressed() {        //调用Person的dressed()方法        mPerson.dressed();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="穿贵的衣服："><a href="#穿贵的衣服：" class="headerlink" title="穿贵的衣服："></a>穿贵的衣服：</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * Created by Weicools on 2017/3/18. * &lt;p&gt; * desc: */public class ExpensiveCloth extends PersonCloth {    public ExpensiveCloth(Person person) {        super(person);    }    private void dressJean() {        System.out.println("穿条牛仔裤");    }    private void dressLeather() {        System.out.println("穿件皮衣");    }    @Override    public void dressed() {        super.dressed();        dressJean();        dressLeather();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="穿便宜的衣服："><a href="#穿便宜的衣服：" class="headerlink" title="穿便宜的衣服："></a>穿便宜的衣服：</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * Created by Weicools on 2017/3/18. * &lt;p&gt; * desc: */public class CheapCloth extends PersonCloth {    public CheapCloth(Person person) {        super(person);    }    private void dressShirt() {        System.out.println("穿件短袖");    }    private void dressShort() {        System.out.println("穿条短裤");    }    @Override    public void dressed() {        super.dressed();        dressShirt();        dressShort();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="装扮："><a href="#装扮：" class="headerlink" title="装扮："></a>装扮：</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * Created by Weicools on 2017/3/18. * &lt;p&gt; * desc: */public class Test {    public static void main(String[] args) {        Person person = new Boy();        PersonCloth cheapCloth = new CheapCloth(person);        cheapCloth.dressed();        System.out.println("*************");        PersonCloth expensiveCloth = new ExpensiveCloth(person);        expensiveCloth.dressed();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="结果："><a href="#结果：" class="headerlink" title="结果："></a>结果：</h3><pre class="line-numbers language-none"><code class="language-none">Boy穿了内衣内裤穿件短袖穿条短裤*************Boy穿了内衣内裤穿条牛仔裤穿件皮衣<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Android-源码中的实现"><a href="#Android-源码中的实现" class="headerlink" title="Android 源码中的实现"></a>Android 源码中的实现</h2><ul><li><p>Context</p></li><li><p><code>Context</code>类在 Android 中被称为“上帝对象”，它的本质就是一个抽象类，在装饰模式中相当于抽象组件，而在内部定义了大量的抽象方法，比如我们经常用到的<code>startActivity</code>方法。</p></li><li><p>而真正实现是在<code>ContextImpl</code>中完成，那么<code>ContextImpl</code> 就是抽象组件的具体实现类。</p></li><li><p><code>Activity</code>从类的层次来看本质是图个 Context，但是<code>Activity</code>并非直接继承<code>Context</code>，而是继承<code>ContextThemeWrapper</code>, <code>ContextThemeWrapper</code>有是继承<code>ContextWrapper</code>，因为<code>ContextWrapper</code> 继承于<code>Context</code>，所以<code>ContextWrapper</code> 就是装饰者，<code>ContextWrapper</code>中持有<code>Context</code>的引用。</p></li></ul><blockquote><p>Context：<a href="https://developer.android.com/reference/android/content/Context.html">https://developer.android.com/reference/android/content/Context.html</a><br>ContextWrapper：<a href="https://developer.android.com/reference/android/content/ContextWrapper.html">https://developer.android.com/reference/android/content/ContextWrapper.html</a><br>ContextThemeWrapper：<a href="https://developer.android.com/reference/android/view/ContextThemeWrapper.html">https://developer.android.com/reference/android/view/ContextThemeWrapper.html</a><br>Activity：<a href="https://developer.android.com/reference/android/app/Activity.html">https://developer.android.com/reference/android/app/Activity.html</a></p></blockquote><h2 id="与其他模式区别"><a href="#与其他模式区别" class="headerlink" title="与其他模式区别"></a>与其他模式区别</h2><ol><li>与<a href="http://blog.csdn.net/qq_17766199/article/details/50492805">代理模式</a>的区别<ul><li>（1）装饰模式是以对客户端透明的方式扩展对象的功能，是继承方案的一个替代；而代理模式则是给一个对象提供一个代理对象，并有代理对象来控制对原有对象的引用。</li><li>（2）装饰模式应该为所装饰的对象增强功能；代理模式是对代理对象施加控制，不对对象本身功能进行增强。</li></ul></li><li>与<a href="http://blog.csdn.net/qq_17766199/article/details/50514877">适配器模式</a>的区别<ul><li>适配器模式是用新接口来调用原接口，原接口对新系统是不可见的；装饰模式增强了其他对象的功能而同时又不改变它的接口。</li></ul></li></ol><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><blockquote><p>在实际开发中我们应该写过如下代码：其实这些新增方法的调用就类似装饰模式中的装饰者的职责，只不过这里我们没有保持对组件类的引用。</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Overrideprotected void onCreate(Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    setContentView(R.layout.activity_main);    //初始化数据    initData();    //初始化控件    initViews();    //初始化事件    initEvent();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>优点<ul><li>（1）对于扩展一个对象的功能，装饰模式比继承更加灵活性，不会导致类的个数急剧增加。</li><li>（2）可以通过一种动态的方式在运行时选择不同的具体装饰类，从而实现不同的行为。</li><li>（3）可以对一个对象进行多次装饰，通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合，得到功能更为强大的对象。</li><li>（4）具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，原有类库代码无须改变，符合“开闭原则”。</li></ul></li><li>缺点<ul><li>（1）使用装饰模式进行系统设计时将产生很多小对象，这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同，大量小对象的产生势必会占用更多的系统资源，在一定程序上影响程序的性能。</li><li>（2）对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为繁琐。</li></ul></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Java </tag>
            
            <tag> DesignPattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Android 源码设计模式解析与实战》读书笔记 - 代理模式</title>
      <link href="20170317/designpattern-structure-proxy/"/>
      <url>20170317/designpattern-structure-proxy/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="《Android-源码设计模式解析与实战》读书笔记-代理模式"><a href="#《Android-源码设计模式解析与实战》读书笔记-代理模式" class="headerlink" title="《Android 源码设计模式解析与实战》读书笔记 - 代理模式"></a>《Android 源码设计模式解析与实战》读书笔记 - 代理模式</h1><blockquote><p>代理模式也称委托模式，是结构型设计模式之一。是应用广泛的模式之一。<br>定义：为其他对象提供一种代理以控制对这个对象的访问。</p></blockquote><h2 id="1-使用场景"><a href="#1-使用场景" class="headerlink" title="1.使用场景"></a>1.使用场景</h2><p>当无法或不想直接访问某个对象或访问某个对象存在困难时可以通过一个代理对象来间接访问，为了保证客户端使用的透明性，委托对象与代理对象需要实现相同的接口。</p><h2 id="2-UML-类图"><a href="#2-UML-类图" class="headerlink" title="2.UML 类图"></a>2.UML 类图</h2><p><img src="http://blog-1251678165.coscd.myqcloud.com/2018-03-17-Proxy-Pattern-1.png" alt="Proxy"><br>各个角色介绍：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * Created by Weicools on 2017/3/17. * &lt;p&gt; * desc: 抽象主题类，主要职责是申明真实与代理主题的共同接口方法 * 可以是抽象类也可以是接口 */public abstract class Subject {    public abstract void visit();}/** * Created by Weicools on 2017/3/17. * &lt;p&gt; * desc: 真实主题类，也称被代理类 */public class RealSubject extends Subject {    @Override    public void visit() {        System.out.println("Real subject");    }}/** * Created by Weicools on 2017/3/17. * &lt;p&gt; * desc: 代理类，持有真实主题的引用，它实现的接口方法中调用真实主题的方法 */public class ProxySubject extends Subject {    private Subject mRealSubject;    ProxySubject(Subject subject) {        mRealSubject = subject;    }    @Override    public void visit() {        System.out.println("Proxy subject");        // 调用真实主题方法        mRealSubject.visit();    }}/** * Created by Weicools on 2017/3/17. * &lt;p&gt; * desc: */public class Client {    public static void main(String[] args) {        Subject subject = new ProxySubject(new RealSubject());        subject.visit();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-简单示例"><a href="#3-简单示例" class="headerlink" title="3.简单示例"></a>3.简单示例</h2><blockquote><p>书中例子：以小民诉讼的流程举例。那么需要代理律师代理，诉讼简单流程：提交申请–&gt;进行举证–&gt;开始辩护–&gt;诉讼完成。</p></blockquote><h3 id="诉讼接口类："><a href="#诉讼接口类：" class="headerlink" title="诉讼接口类："></a>诉讼接口类：</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * Created by Weicools on 2018/3/17. * &lt;p&gt; * desc: 诉讼接口类 */public interface ILawsuit {    /**     * 提交申请     */    void submit();    /**     * 禁行举证     */    void burden();    /**     * 开始辩护     */    void defend();    /**     * 诉讼完成     */    void finish();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="具体诉讼人-Weicools："><a href="#具体诉讼人-Weicools：" class="headerlink" title="具体诉讼人 Weicools："></a>具体诉讼人 Weicools：</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * Created by Weicools on 2017/3/17. * &lt;p&gt; * desc: 具体诉讼人 */public class Weicools implements ILawsuit {    @Override    public void submit() {        System.out.println("老板拖欠工资，特此申请仲裁！");    }    @Override    public void burden() {        System.out.println("这是合同书和过去一年的银行工资流水。");    }    @Override    public void defend() {        System.out.println("证据确凿，不需要做任何辩护！");    }    @Override    public void finish() {        System.out.println("诉讼成功，判决老板七天内结算工资！");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="代理律师："><a href="#代理律师：" class="headerlink" title="代理律师："></a>代理律师：</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * Created by Weicools on 2017/3/17. * &lt;p&gt; * desc: 代理律师 */public class ProxyLayer implements ILawsuit {    private ILawsuit mLawsuit;    public ProxyLayer(ILawsuit lawsuit) {        mLawsuit = lawsuit;    }    @Override    public void submit() {        mLawsuit.submit();    }    @Override    public void burden() {        mLawsuit.burden();    }    @Override    public void defend() {        mLawsuit.defend();    }    @Override    public void finish() {        mLawsuit.finish();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="开始仲裁："><a href="#开始仲裁：" class="headerlink" title="开始仲裁："></a>开始仲裁：</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * Created by Weicools on 2017/3/17. * &lt;p&gt; * desc: */public class Test {    public static void main(String[] args) {        ILawsuit weico = new Weicools();        ILawsuit layer = new ProxyLayer(weico);        layer.submit();        layer.burden();        layer.defend();        layer.finish();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="结果："><a href="#结果：" class="headerlink" title="结果："></a>结果：</h3><pre class="line-numbers language-none"><code class="language-none">老板拖欠工资，特此申请仲裁！这是合同书和过去一年的银行工资流水。证据确凿，不需要做任何辩护！诉讼成功，判决老板七天内结算工资！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>同样我们也可以代理其他人，只需要实现 ILawsuit 即可。上面的代理模式也叫静态代理，也就是在代码运行前代理类的 class 文件就已经存在。那么相反，当然也会有动态代理，通过反射机制动态生成代理类，也就是在编码阶段不需要知道代理谁。</p><h2 id="4-动态代理实现"><a href="#4-动态代理实现" class="headerlink" title="4.动态代理实现"></a>4.动态代理实现</h2><p>Java 提供了一个便捷的动态代理接口 InvocationHandler，我们来实现它：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * Created by Weicools on 2017/3/17. * &lt;p&gt; * desc: 动态代理类 */public class DynamicPorxy implements InvocationHandler {    // 被代理类的引用    private Object mObject;    public DynamicPorxy(Object o) {        mObject = o;    }    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {        return method.invoke(mObject, args);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里我们通过 invoke 方法来调用具体的被代理方法，增加 DynamicTest 类测试：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * Created by Weicools on 2017/3/17. * &lt;p&gt; * desc: 动态代理测试 */public class DynamicTest {    public static void main(String[] args) {        //构造出诉讼人小民        ILawsuit weicools = new Weicools();        //1.静态代理        //构造一个代理律师，并将小民传递进去        //ILawsuit lawyer = new Lawyer(xiaomin);        //2.动态代理        //构造一个动态代理        DynamicProxy proxy = new DynamicProxy(weicools);        //获取被代理类小民的ClassLoader        ClassLoader loader = weicools.getClass().getClassLoader();        //动态构造一个代理者律师        ILawsuit lawyer = (ILawsuit) Proxy.newProxyInstance(loader, new Class[]{ ILawsuit.class }, proxy);        //律师提交申请        lawyer.submit();        //律师进行举证        lawyer.burden();        //律师代替weicools辩护        lawyer.defend();        //完成诉讼        lawyer.finish();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果不变，由此可以看出动态代理通过一个代理类来处理 N 多个被代理类，其实质是对代理者与被代理者解耦。相对而言静态代理则只能为给定接口下的实现类做代理，如果接口不同那么就需要重新定义不同的代理类，较为复杂，但是静态代理更符合面向对象原则。具体使用哪种方式，根据个人喜好。</p><h2 id="5-Android-源码中的代理模式实现"><a href="#5-Android-源码中的代理模式实现" class="headerlink" title="5.Android 源码中的代理模式实现"></a>5.Android 源码中的代理模式实现</h2><h3 id="ActivityManagerProxy-代理类"><a href="#ActivityManagerProxy-代理类" class="headerlink" title="ActivityManagerProxy 代理类"></a>ActivityManagerProxy 代理类</h3><p>ActivityManager 是 Android 中管理和维护 Activity 的相关信息的类，为了隔离它与 ActivityManagerService，有效降低二者的耦合，在这中间使用了 ActivityManagerProxy 代理类，其抽象主题类是 IActivityManager 接口，所有对 ActivityManagerService 的访问都转换成对代理类的访问，这样 ActivityManager 就与 ActivityManagerService 解耦了。<br><img src="http://blog-1251678165.coscd.myqcloud.com/2018-03-17-Activity-Manaher.png"></p><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h2><ol><li><p>优点</p><ul><li>（1）对代理者与被代理者进行解耦。</li><li>（2）代理对象在客户端和目标对象之间起到一个中介的作用，这样可以起到对目标对象的保护。</li></ul></li><li><p>缺点</p><ul><li>基本没有缺点，真要说缺点就是设计模式的通病：对类的增加。</li></ul></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Java </tag>
            
            <tag> DesignPattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Android 源码设计模式解析与实战》读书笔记 - 观察者模式</title>
      <link href="20170312/designpattern-behavior-observer/"/>
      <url>20170312/designpattern-behavior-observer/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="《Android-源码设计模式解析与实战》读书笔记-观察者模式"><a href="#《Android-源码设计模式解析与实战》读书笔记-观察者模式" class="headerlink" title="《Android 源码设计模式解析与实战》读书笔记 - 观察者模式"></a>《Android 源码设计模式解析与实战》读书笔记 - 观察者模式</h1><blockquote><p>观察者模式是一个使用率非常高的模式，它最常用在 GUI 系统、订阅–发布系统。因为这个模式的一个重要作用就是解耦，将被观察者和观察者解耦，使得它们之间的依赖性更小，甚至做到毫无依赖。比如安卓的开源项目 EventBus、Otto、AndroidEventBus 等事件总线类的和 RxJava 响应式编程其核心都是使用观察者模式。<br>观察者模式是定义对象间一对多的依赖关系，使得每当一个对象状态改变时可以通知 依赖于它的所有对象进行更新。</p></blockquote><a id="more"></a><h2 id="1-使用场景"><a href="#1-使用场景" class="headerlink" title="1.使用场景"></a>1.使用场景</h2><ol><li>关联行为场景，需要注意的是，关联行为是可拆分的，而不是“组合”关系。</li><li>事件多级触发场景。</li><li>跨系统的消息交换场景，如消息队列、事件总线的处理机制。</li></ol><h2 id="2-UML-类图"><a href="#2-UML-类图" class="headerlink" title="2.UML 类图"></a>2.UML 类图</h2><p><img src="http://blog-1251678165.coscd.myqcloud.com/2018-03-16-Observer.jpg"><br>UML 类图介绍：</p><ol><li>Subject：抽象主题，也就是被观察者角色(Observable)，抽象主题把所有观察者对象的引用保存到一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供接口可以删除和增加观察者对象</li><li>ConcreteSubject：具体主题，将有关状态存入具体的观察者对象，在具体主题的内部发生改变时，给所有注册过的观察者发送通知。</li><li>Observer：抽象观察者，它定义了一个更新接口，使得在得到被观察者的更改通知时更新自身状态。</li><li>ConcreteObserver：具体观察者，实现抽象观察者角色所定义的更新接口，在被观察者的状态发生变化时更新自身状态。</li></ol><h2 id="3-实现示例"><a href="#3-实现示例" class="headerlink" title="3.实现示例"></a>3.实现示例</h2><ul><li><strong>实现用户追番</strong></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * Created by Weicools on 2017/3/16. * &lt;p&gt; * desc: 抽象观察者类，为所有具体观察者定义一个接口，在得到通知时更新自己 */public interface Observer {    /**     * 更新消息     * @param message 消息     */    void update(String message);}/** * Created by Weicools on 2017/3/16. * &lt;p&gt; * desc: 具体的观察者类，也就是订阅者 */public class User implements Observer {    private String mName;    public User(String name) {        mName = name;    }    @Override    public void update(String message) {        System.out.println(mName + ": 订阅的" + message + "更新了");    }}/** * Created by Weicools on 2017/3/16. * &lt;p&gt; * desc: 抽象被观察者类 */public abstract class Subject {    /**     * 推送消息     * @param message 内容     */    public abstract void pushMsg(String message);    /**     * 订阅     * @param observer 订阅者     */    public abstract void addObserver(Observer observer);}/** * Created by Weicools on 2017/3/16. * &lt;p&gt; * desc: 具体的被观察者类，也就是订阅的节目 */public class Animation extends Subject {    private List&lt;Observer&gt; mObserverList = new ArrayList&lt;&gt;();//储存订阅者    @Override    public void pushMsg(String message) {        for (Observer observer : mObserverList) {            observer.update(message);        }    }    @Override    public void addObserver(Observer observer) {        mObserverList.add(observer);    }}/** * Created by Weicools on 2017/3/16. * &lt;p&gt; * desc: */public class Test {    public static void main(String[] args) {        // 观察者, 即订阅用户        User user1 = new User("XXX");        User user2 = new User("YYY");        User user3 = new User("ZZZ");        // 被观察者, 用户订阅的……        Animation animation = new Animation();        animation.addObserver(user1);        animation.addObserver(user2);        animation.addObserver(user3);        animation.pushMsg("境界的彼方");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">// 输出XXX: 订阅的境界的彼方更新了YYY: 订阅的境界的彼方更新了ZZZ: 订阅的境界的彼方更新了<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>由上面的代码可以看出实现了一对多的消息推送，推送消息都是依赖 Observer 和 Observable 这些抽象类，而 User 和 Teleplay 完全没有耦合，保证了订阅系统的灵活性和可扩展性。</p><h2 id="4-Android-源码中的观察者模式"><a href="#4-Android-源码中的观察者模式" class="headerlink" title="4.Android 源码中的观察者模式"></a>4.Android 源码中的观察者模式</h2><h3 id="BaseAdapter"><a href="#BaseAdapter" class="headerlink" title="BaseAdapter"></a>BaseAdapter</h3><p>在 ListView 的适配器中我们都是继承 BaseAdapter。下面来简单分析分析。BaseAdapter 部分代码：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public abstract class BaseAdapter implements ListAdapter, SpinnerAdapter {    //数据集观察者    private final DataSetObservable mDataSetObservable = new DataSetObservable();    public boolean hasStableIds() {        return false;    }    public void registerDataSetObserver(DataSetObserver observer) {        mDataSetObservable.registerObserver(observer);    }    public void unregisterDataSetObserver(DataSetObserver observer) {        mDataSetObservable.unregisterObserver(observer);    }    /**     * 当数据集变化时，通知所有观察者     */    public void notifyDataSetChanged() {        mDataSetObservable.notifyChanged();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看看 mDataSetObservable.notifyChanged()方法：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class DataSetObservable extends Observable&lt;DataSetObserver&gt; {    /**     * Invokes {@link DataSetObserver#onChanged} on each observer.     * Called when the contents of the data set have changed.  The recipient     * will obtain the new contents the next time it queries the data set.     */    public void notifyChanged() {        synchronized(mObservers) {            // since onChanged() is implemented by the app, it could do anything, including            // removing itself from {@link mObservers} - and that could cause problems if            // an iterator is used on the ArrayList {@link mObservers}.            // to avoid such problems, just march thru the list in the reverse order.            for (int i = mObservers.size() - 1; i &gt;= 0; i--) {                mObservers.get(i).onChanged();            }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出在 mDataSetObservable.notifyChanged()中遍历所有观察者，并调用他们的 onChanged()，从而告知观察者需要做什么。</p><p>那么观察者怎么来的，那就是 setAdapter 方法，代码如下：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">@Overridepublic void setAdapter(ListAdapter adapter) {    if (mAdapter != null &amp;&amp; mDataSetObserver != null) {        mAdapter.unregisterDataSetObserver(mDataSetObserver);    }    resetList();    mRecycler.clear();    if (mHeaderViewInfos.size() &gt; 0|| mFooterViewInfos.size() &gt; 0) {        mAdapter = new HeaderViewListAdapter(mHeaderViewInfos, mFooterViewInfos, adapter);    } else {        mAdapter = adapter;    }    mOldSelectedPosition = INVALID_POSITION;    mOldSelectedRowId = INVALID_ROW_ID;    // AbsListView#setAdapter will update choice mode states.    super.setAdapter(adapter);    if (mAdapter != null) {        mAreAllItemsSelectable = mAdapter.areAllItemsEnabled();        mOldItemCount = mItemCount;        mItemCount = mAdapter.getCount();        checkFocus();        mDataSetObserver = new AdapterDataSetObserver();        mAdapter.registerDataSetObserver(mDataSetObserver);//注册观察者        ......省略    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>AdapterDataSetObserver 定义在 ListView 的父类 AbsListView 中，是一个数据集观察者，代码：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">class AdapterDataSetObserver extends AdapterView&lt;ListAdapter&gt;.AdapterDataSetObserver {    @Override    public void onChanged() {        super.onChanged();        if (mFastScroller != null) {            mFastScroller.onSectionsChanged();        }    }    @Override    public void onInvalidated() {        super.onInvalidated();        if (mFastScroller != null) {            mFastScroller.onSectionsChanged();        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>它由继承自 AbsListView 的父类 AdapterView 的 AdapterDataSetObserver, 代码如下 :</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">class AdapterDataSetObserver extends DataSetObserver {    private Parcelable mInstanceState = null;    // 上文有说道，调用Adapter的notifyDataSetChanged的时候会调用所有观察者的onChanged方法,核心实现就在这里    @Override    public void onChanged() {        mDataChanged = true;        mOldItemCount = mItemCount;        // 获取Adapter中数据的数量        mItemCount = getAdapter().getCount();        // Detect the case where a cursor that was previously invalidated has        // been repopulated with new data.        if (AdapterView.this.getAdapter().hasStableIds() &amp;&amp; mInstanceState != null                &amp;&amp; mOldItemCount == 0 &amp;&amp; mItemCount &gt; 0) {            AdapterView.this.onRestoreInstanceState(mInstanceState);            mInstanceState = null;        } else {            rememberSyncState();        }        checkFocus();        // 重新布局ListView、GridView等AdapterView组件        requestLayout();    }    // 代码省略    public void clearSavedState() {        mInstanceState = null;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当 ListView 的数据发生变化时，调用 Adapter 的 notifyDataSetChanged 函数，这个函数又会调用 DataSetObservable 的 notifyChanged 函数，这个函数会调用所有观察者 (AdapterDataSetObserver) 的 onChanged 方法，这就是一个观察者模式！</p><h2 id="5-Summary"><a href="#5-Summary" class="headerlink" title="5.Summary"></a>5.Summary</h2><ol><li>优点<ul><li>观察者和被观察者之间是抽象耦合，将观察者与被观察者完全隔离，只依赖于 Observer 和 Observable 抽象，应对业务变化。</li><li>增强系统的灵活性和可扩展性。</li></ul></li><li>缺点<ul><li>在应用观察者模式时需要考虑一下开发效率和运行效率的问题，程序中包括一个被观察者、多个观察者，开发、调试等内容会比较复杂，而且在 Java 中消息的通知一般是顺序执行，那么一个观察者卡顿，会影响整体的执行效率，在这种情况下，一般会采用异步实现。</li></ul></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Java </tag>
            
            <tag> DesignPattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="20170218/designpattern/"/>
      <url>20170218/designpattern/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p><img src="http://blog-1251678165.coscd.myqcloud.com/2018-03-17-Design-Pattern.png"></p><blockquote><p>😎😂 表示重要程度</p></blockquote><h2 id="创建型模式-Creational-Pattern"><a href="#创建型模式-Creational-Pattern" class="headerlink" title="创建型模式(Creational Pattern)"></a>创建型模式(Creational Pattern)</h2><p>创建型模式对类的实例化过程进行抽象，能够将软件模块中的对象创建和对象使用分离。为了使软件的结构更加清晰，外界对于这些对象只需要知道它们共同的接口，而不清楚其具体的实现细节，使整个系统的设计更加符合单一职责原则。</p><p>创建型模式在创建什么(What)，由谁创建(Who)，何时创建(When)等方面都为软件设计者提供了尽可能大的灵活性。创建型模式隐藏了类的实例的创建细节，通过隐藏对象如何被创建和组合在一起达到使整个系统独立的目的。</p><h3 id="1-单例模式-Singleton-Pattern"><a href="#1-单例模式-Singleton-Pattern" class="headerlink" title="1.单例模式(Singleton Pattern)"></a>1.单例模式(Singleton Pattern)</h3><h3 id="2-简单工程模式-Simple-Factory-Pattern"><a href="#2-简单工程模式-Simple-Factory-Pattern" class="headerlink" title="2.简单工程模式(Simple Factory Pattern)"></a>2.简单工程模式(Simple Factory Pattern)</h3><h3 id="3-工厂方法模式-Factory-Method-Pattern"><a href="#3-工厂方法模式-Factory-Method-Pattern" class="headerlink" title="3.工厂方法模式(Factory Method Pattern)"></a>3.工厂方法模式(Factory Method Pattern)</h3><h3 id="4-抽象工厂模式-Abstract-Factory-Pattern"><a href="#4-抽象工厂模式-Abstract-Factory-Pattern" class="headerlink" title="4.抽象工厂模式(Abstract Factory Pattern)"></a>4.抽象工厂模式(Abstract Factory Pattern)</h3><h3 id="5-建造者模式-Builder-Pattern"><a href="#5-建造者模式-Builder-Pattern" class="headerlink" title="5.建造者模式(Builder Pattern)"></a>5.建造者模式(Builder Pattern)</h3><h3 id="6-原型模式-Prototype-Pattern"><a href="#6-原型模式-Prototype-Pattern" class="headerlink" title="6.原型模式(Prototype Pattern)"></a>6.原型模式(Prototype Pattern)</h3><h2 id="结构型模式-Structural-Pattern"><a href="#结构型模式-Structural-Pattern" class="headerlink" title="结构型模式(Structural Pattern)"></a>结构型模式(Structural Pattern)</h2><ol><li>结构型模式描述如何将类或者对 象结合在一起形成更大的结构，就像搭积木，可以通过 简单积木的组合形成复杂的、功能更为强大的结构。</li><li>结构型模式可以分为类结构型模式和对象结构型模式：<ul><li>类结构型模式关心类的组合，由多个类可以组合成一个更大的系统，在类结构型模式中一般只存在继承关系和实现关系。</li><li>对象结构型模式关心类与对象的组合，通过关联关系使得在一 个类中定义另一个类的实例对象，然后通过该对象调用其方法。 根据“合成复用原则”，在系统中尽量使用关联关系来替代继 承关系，因此大部分结构型模式都是对象结构型模式。</li></ul></li></ol><h3 id="1-适配器模式-Adapter-Pattern"><a href="#1-适配器模式-Adapter-Pattern" class="headerlink" title="1.适配器模式(Adapter Pattern)"></a>1.适配器模式(Adapter Pattern)</h3><h3 id="2-桥接模式-Bridge-Pattern"><a href="#2-桥接模式-Bridge-Pattern" class="headerlink" title="2.桥接模式(Bridge Pattern)"></a>2.桥接模式(Bridge Pattern)</h3><h3 id="3-装饰模式-Decorator-Pattern"><a href="#3-装饰模式-Decorator-Pattern" class="headerlink" title="3.装饰模式(Decorator Pattern)"></a>3.装饰模式(Decorator Pattern)</h3><h3 id="4-外观模式-Facade-Pattern"><a href="#4-外观模式-Facade-Pattern" class="headerlink" title="4.外观模式(Facade Pattern)"></a>4.外观模式(Facade Pattern)</h3><h3 id="5-享元模式-Flyweight-Pattern"><a href="#5-享元模式-Flyweight-Pattern" class="headerlink" title="5.享元模式(Flyweight Pattern)"></a>5.享元模式(Flyweight Pattern)</h3><h3 id="6-代理模式-Proxy-Pattern"><a href="#6-代理模式-Proxy-Pattern" class="headerlink" title="6.代理模式(Proxy Pattern)"></a>6.代理模式(Proxy Pattern)</h3><h3 id="7-组合模式-Composite-Pattern"><a href="#7-组合模式-Composite-Pattern" class="headerlink" title="7.组合模式(Composite Pattern)"></a>7.组合模式(Composite Pattern)</h3><h2 id="行为型模式-Behavioral-Pattern"><a href="#行为型模式-Behavioral-Pattern" class="headerlink" title="行为型模式(Behavioral Pattern)"></a>行为型模式(Behavioral Pattern)</h2><ol><li>行为型模式是对在不同的对象之间划分责任和算法的抽象化。</li><li>行为型模式不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用。</li><li>通过行为型模式，可以更加清晰地划分类与对象的职责，并研究系统在运行时实例对象 之间的交互。在系统运行时，对象并不是孤立的，它们可以通过相互通信与协作完成某些复杂功能，一个对象在运行时也将影响到其他对象的运行。</li><li>行为型模式分为类行为型模式和对象行为型模式两种：<ul><li>类行为型模式：类的行为型模式使用继承关系在几个类之间分配行为，类行为型模式主要通过多态等方式来分配父类与子类的职责。</li><li>对象行为型模式：对象的行为型模式则使用对象的聚合关联关系来分配行为，对象行为型模式主要是通过对象关联等方式来分配两个或多个类的职责。根据“合成复用原则”，系统中要尽量使用关联关系来取代继承关系，因此大部分行为型设计模式都属于对象行为型设计模式</li></ul></li></ol><h3 id="1-观察者模式-Observer-Pattern"><a href="#1-观察者模式-Observer-Pattern" class="headerlink" title="1.观察者模式(Observer Pattern)"></a>1.观察者模式(Observer Pattern)</h3><h3 id="2-策略模式-Strategy-Pattern"><a href="#2-策略模式-Strategy-Pattern" class="headerlink" title="2.策略模式(Strategy Pattern)"></a>2.策略模式(Strategy Pattern)</h3><h3 id="3-状态模式-State-Pattern"><a href="#3-状态模式-State-Pattern" class="headerlink" title="3.状态模式(State Pattern)"></a>3.状态模式(State Pattern)</h3><h3 id="4-命令模式-Command-Pattern"><a href="#4-命令模式-Command-Pattern" class="headerlink" title="4.命令模式(Command Pattern)"></a>4.命令模式(Command Pattern)</h3><h3 id="5-中介者模式-Mediator-Pattern"><a href="#5-中介者模式-Mediator-Pattern" class="headerlink" title="5.中介者模式(Mediator Pattern)"></a>5.中介者模式(Mediator Pattern)</h3><h3 id="6-迭代器模式-Iterator-Pattern"><a href="#6-迭代器模式-Iterator-Pattern" class="headerlink" title="6.迭代器模式(Iterator Pattern)"></a>6.迭代器模式(Iterator Pattern)</h3><h3 id="7-备忘录模式-Memento-Pattern"><a href="#7-备忘录模式-Memento-Pattern" class="headerlink" title="7.备忘录模式(Memento Pattern)"></a>7.备忘录模式(Memento Pattern)</h3><h3 id="8-模板方法模式-Template-Method-Pattern"><a href="#8-模板方法模式-Template-Method-Pattern" class="headerlink" title="8.模板方法模式(Template Method Pattern)"></a>8.模板方法模式(Template Method Pattern)</h3><h3 id="9-访问者模式-Visitor-Pattern"><a href="#9-访问者模式-Visitor-Pattern" class="headerlink" title="9.访问者模式(Visitor Pattern)"></a>9.访问者模式(Visitor Pattern)</h3><h3 id="10-解释器模式-Interpreter-Pattern"><a href="#10-解释器模式-Interpreter-Pattern" class="headerlink" title="10.解释器模式(Interpreter Pattern)"></a>10.解释器模式(Interpreter Pattern)</h3><h3 id="11-责任链模式-Chain-of-Responsibility"><a href="#11-责任链模式-Chain-of-Responsibility" class="headerlink" title="11.责任链模式(Chain of Responsibility)"></a>11.责任链模式(Chain of Responsibility)</h3>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> DesignPattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Base</title>
      <link href="20161023/android-base/"/>
      <url>20161023/android-base/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Android-Base"><a href="#Android-Base" class="headerlink" title="Android Base"></a>Android Base</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ol><li><p>Android四大组件</p><ul><li>Activity：Android程序与用户交互的窗口，Android构造块中最基本的一种，它需要为保持各界面状态做许多持久化的事情</li><li>Service：后台服务于Activity，封装有完整的功能逻辑实现，接受上层指令，完成相关事物，定义好需要接受的Intent，提供同步和异步的接口</li><li>Content Provider：Android提供的第三方应用数据的访问方案，可以派生Content Provider类，对外提供数据</li><li>Broadcast Receiver：接受一种或者多种Intent作触发事件，接受相关消息，做一些简单处理，转换成一条Notification<a id="more"></a></li></ul></li><li><p>Android五种布局</p><ul><li>FrameLayout：所有控件一次放在右上角，可重叠</li><li>LinearLayout：可设置垂直布局（android:orientation=”vertical”）和水平布局（android:orientation=”horizontal” ）</li><li>AbsoluteLayout：使用X,Y坐标制定元素位置（旋转屏幕时容易出现问题，多个元素计算麻烦）</li><li>RelativeLayout：以某个元素作为参照物，来定位控件位置</li><li>TableLayout：包含TableRow，TableRow里面可以定义具体元素</li></ul></li><li><p>Activity生命周期<br>生命周期方法：onCreate(),onStart(),onResume(),onRestart(),onPause(),onStop(),onDestroy()</p><ul><li>启动Activity：onCreate()-&gt;onStart()-&gt;onResume()</li><li>Activity进入后台（当前Activity转到新的Activity界面或者按Home键返回主屏）：onPause()-&gt;onStop()</li><li>Activity返回前台：onRestart()-&gt;onStart()-&gt;onResume()</li><li>Activity进入后台且系统内存不足，系统会杀死后台的Activity（此时这个Activity引用仍然处在任务栈中，只是这个时候引用指向的对象已经为null）若再次回到这个Activity,则会走onCreate()–&gt;onStart()—&gt;onResume()(将重新走一次Activity的初始化生命周期)</li><li>锁屏：onPause()-&gt;onStop()</li><li>解锁：onStart()-&gt;onResume()<br><img src="https://blog-bak-1251678165.cos.ap-beijing.myqcloud.com/2016-10-23-Activity%20life.png" alt="activity"></li></ul></li><li><p>Activity启动模式<br>使用android:launchMode=”standard|singleInstance|singleTask|singleTop”来控制Activity任务栈</p><ul><li>任务栈属于后进先出的结构，位于栈顶的Activity处于焦点状态，当按下back按钮时，栈内的Activity会分别出栈并且调用onDestroy()方法，如果栈内没有Activity那么系统就会回收这个栈，每个APP默认只有一个栈</li><li>standard：标准模式，每次启动Activity都会创建一个新的Activity实例，并且压入任务栈栈顶，而不管这个Activity是否已经存在Activity的启动过程onCreate()-&gt;onStart()-&gt;onResume()都会执行</li><li>singleTop：栈顶复用模式，如果新的Activity已经位于栈顶位置那么就不在创建这个Activity，同时Activity的onNewIntent()方法会被回调。例如A-B-C-D和A-B-D-C在创建D时分别变成A-B-C-D和A-B-D-C-D</li><li>singleTask：栈内复用模式，创建Activity时，系统会先确认它所需的任务栈是否已经创建，否则先创建任务栈然后放入Activity，如果栈内已经有这个Activity实例，那么这个Activity会被调到栈顶，onNewIntent()方法会被回调，并且singleTask会清理在当前Activity上面的所有Activity.(clear top)</li><li>singleInstance：加强版singleTask模式，Activity只能单独存在一个任务栈内，由于栈内复用特性，后续请求都不会创建新的Activity除非这个任务栈被销毁</li></ul></li><li><p>Activity缓存方法<br>问题描述：有a和b两个Activity，当从a进入b一段时间后，可能系统把a回收，这时按back执行的不是a的onRestart()而是onCreate()，a会被重新创建一次，原来a中的临时数据就可能丢失了</p><ul><li><p>这时可以使用Activity中的onSaveInstanceState()回调方法保持临时数据和状态，这个方法一定会在活动被回收前调用，方法中有一个Bundle参数，putString()，putInt()需要传入两个参数，一个键和一个值。数据保存后会在onCreate()中恢复</p></li><li><p>onSaveInstanceState的调用遵循一个重要原则，即当系统“未经你许可”时销毁了你的activity，则onSaveInstanceState会被系统调用，这是系统的责任，因为它必须要提供一个机会让你保存你的数据</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Overrideprotected void onCreate(Bundle savedInstanceState) {   super.onCreate(savedInstanceState);   setContentView(R.layout.activity_main);   //这里，当Acivity第一次被创建的时候为空   //所以我们需要判断一下   if( savedInstanceState != null ){       savedInstanceState.getString("anAnt");   }}@Overrideprotected void onSaveInstanceState(Bundle outState) {   super.onSaveInstanceState(outState);   outState.putString("anAnt","Android");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>Fragment生命周期和Activity生命周期关系<br><img src="https://blog-bak-1251678165.cos.ap-beijing.myqcloud.com/2016-10-23-FragmentFlowchartDiagram.jpg" alt="FragmentActivity"></p></li><li><p>为什么在Service创建子线程而不是在Activity</p><ul><li>Activity很难对Thread进行控制，当Activity被销毁后，就没有办法可以在获取之前创建的子线程实例，而且在一个Activity中创建的子线程，另一个Activity无法对其进行任何操作</li><li>但是Service不同，所以得Activity都可以与Service关联，可以很方便的操作其中的方法，即使Activity被销毁之后只要重新与Service建立关联就又可以获取到原有Service中的Bundle实例</li></ul></li><li><p>Intent使用方法</p><ul><li>通过Intent/Bundle的API文档，可知Intent/Bundle支持传递基本数据类型的数据和基本类型的数组数据以及String/CharSequence类型数据和String/CharSequence类型的数组数据；另外还可以传递Parcelabe(包裹化，邮包)和Serializable序列化类型数据以及他们的数组/列表数据</li></ul></li><li><p>Fragment生命周期<br><img src="https://blog-bak-1251678165.cos.ap-beijing.myqcloud.com/2016-10-23-FragmentLife.png" alt="Fragmentlife"></p></li><li><p>Service两种启动方法</p><ul><li>1）在Context中通过public boolean bindService(Intent service, ServiceConnection conn, int flags)方法来进行Service与Context的关联启动，并且Service的生命周期依附于Context</li><li>2）通过public ComponentName startService(Intent service)方法去启动一个Service，此时Service生命周期与Context无关</li><li><blockquote><p>要注意，无论何时都需要在xml里注册Service</p></blockquote></li></ul><pre class="line-numbers language-none"><code class="language-none">&lt;service        android:name=".packnameName.youServiceName"        android:enabled="true" /&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>广播注册方式&amp;区别</p><ul><li>在android中，我们如果想接收到广播信息，必须自定义我们的广播接收者。要写一个类来继承BroadcastReceiver，并且重写其onReceive()方法，实现接收到特定广播所要做的事情</li></ul><pre class="line-numbers language-none"><code class="language-none">public class MyBroadCastReceiver extends BroadcastReceiver   {     @Override     public void onReceive(Context context, Intent intent)      {          //在这里可以写相应的逻辑来实现一些功能       //可以从Intent中获取数据、还可以调用BroadcastReceiver的getResultData()获取数据   }   }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>1）静态注册：在AndroidManifest.xml文件的<application>节点中进行注册，当APP退出后Receiver仍然可以接受广播并进行相应处理</application></li></ul><pre class="line-numbers language-none"><code class="language-none"> &lt;receiver android:name=".MyBroadCastReceiver"&gt;      &lt;!-- android:priority属性是设置此接收者的优先级（从-1000到1000） --&gt;    &lt;intent-filter android:priority="20"&gt;        &lt;actionandroid:name="android.provider.Telephony.SMS_RECEIVED"/&gt;      &lt;/intent-filter&gt;  &lt;/receiver&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>2）动态注册：在代码中动态注册，APP退出就无法接收广播</li></ul><pre class="line-numbers language-none"><code class="language-none">// new出上边定义好的BroadcastReceiverMyBroadCastReceiver yBroadCastReceiver = new MyBroadCastReceiver();// 实例化过滤器并设置要过滤的广播IntentFilter intentFilter = new IntentFilter("android.provider.Telephony.SMS_RECEIVED");// 注册广播   myContext.registerReceiver(smsBroadCastReceiver,intentFilter,              "android.permission.RECEIVE_SMS", null);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>3）发送广播两种方式：通过mContext.sendBroadcast(Intent)或mContext.sendBroadcast(Intent, String)发送的是无序广播(后者加了权限)；通过mContext.sendOrderedBroadcast(Intent, String, BroadCastReceiver, Handler, int, String, Bundle)发送的是有序广播</li></ul></li><li><p>Android数据存储方式</p><ul><li>1）SQLite：轻量级数据库，支持基本SQL语法，是常用的数据存储方式，Android提供了SQLiteDatabase的类封装了一些操作数据库的API</li><li>2）SharedPreference：存储比较简单的参数设置</li><li>3）File：文件（I/O）存储方式，常用于存储大量数据，缺点是更新数据很麻烦</li><li>4）ContentProvider：Android系统能实现所有应用程序共享数据的方式，由于数据通常在各个应用中是相互私密的，所有这种方式使用较少，一般用在音频，视频，图片和通讯录；每个Content Provider都会对外提供一个公共的URI（包装成Uri对象），如果应用程序有数据需要共享时，就需要使用Content Provider为这些数据定义一个URI，然后其他的应用程序就通过Content Provider传入这个URI来对数据进行操作</li></ul></li><li><p>Android动画分类</p><ul><li>tween补间动画，通过指定View的初始状态和变化时间、方式，对View的内容完成一系列的图形变换来实现动画效果，这种实现方式可以使视图组件移动、放大、缩小以及产生透明度的变化</li><li>frame帧动画，AnimationDrawable控制animation-list.xml布局，通过顺序的播放排列好的图片来实现</li></ul></li><li><p>Android解析XML的类</p><ul><li>1）SAX：读取是单向的，优点是不占内存空间、解析属性方便；缺点是对于嵌套多个分支处理不方便</li><li>2）DOM：把整个XML放到内存中</li><li>3）PUU：常用在J2ME对于节点处理比较好，类似SAX同样很节省内存，在J2ME中常使用KXML库来解析</li></ul></li><li><p>Android如何加速启动Activity</p><ul><li>启动应用：Application的构造方法，onCreate方法中不要进行耗时的操作，数据预读取/初始化数据放在异步中进行操作</li><li>普通Activity启动应用：A启动B时不要在A的onPause方法中进行耗时操作，因为B的onResume方法必须等待A的onPause方法执行完成才可以运行</li></ul></li><li><p>Android内存优化方法</p><ul><li>ListView优化</li><li>及时关闭资源</li><li>图片缓存</li></ul></li><li><p>ListView优化方案</p><ul><li>1）如果自定义适配器，那么在getView中需要考虑方法传进来的参数contentView是否为null，若为null则创建contentView并返回，否则直接使用（尽可能减少创建view）</li><li>2）给contentView设置tag（setTag()）传入一个viewHolder对象用于缓存需要显示的数据，可以达到图像数据异步加载的效果</li><li>3）如果ListView需要显示很多item时则需要考虑分页加载</li></ul></li><li><p>Activity在屏幕旋转时的生命周期</p><ul><li>不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，切横屏执行一次，切竖屏执行2次</li><li>设置Activity的android:configChanges = “orientation”时，切屏还是会重新调用各个生命，横屏竖屏各一次</li><li>设置Activity的android:configChanges=”orientation|keyboardHidden”时，切屏不会调用各个生命周期，只会调用onConfigurationChanged()方法</li></ul></li><li><p>如何启用&amp;停用Service</p><ul><li>1）继承Service类<code>public class SMSService extends Service{}</code></li><li>2）在AndroidManifest.xml文件中的<application>节点中对服务进行配置<service android:name=".SMSService"></service></application></li><li>3）若采用Context.startService()方法启动服务，在服务未被创建时，系统会先调用服务的onCreate()方法，接着调用onStart()方法。如果调用startService()方法前服务已经被创建，多次调用startService()方法并不会导致多次创建服务，但会导致多次调用onStart()方法。采用startService()方法启动的服务，只能调用Context.stopService()方法结束服务，服务结束时会调用onDestroy()方法</li><li>4）采用Context.bindService()方法启动服务，在服务未被创建时，系统会先调用服务的onCreate()方法，接着调用onBind()方法。这个时候调用者和服务绑定在一起，调用者退出了，系统就会先调用服务的onUnbind()方法，接着调用onDestroy()方法。如果调用bindService()方法前服务已经被绑定，多次调用bindService()方法并不会导致多次创建服务及绑定(也就是说onCreate()和onBind()方法并不会被多次调用)。如果调用者希望与正在绑定的服务解除绑定，可以调用unbindService()方法，调用该方法也会导致系统调用服务的onUnbind()–&gt;onDestroy()方法</li><li>服务常用生命周期回调方法如下： <ul><li>onCreate() 该方法在服务被创建时调用，该方法只会被调用一次，无论调用多少次startService()或bindService()方法，服务也只被创建一次。</li><li>onDestroy()该方法在服务被终止时调用。</li><li>与采用Context.startService()方法启动服务有关的生命周期方法</li><li>onStart() 只有采用Context.startService()方法启动服务时才会回调该方法。该方法在服务开始运行时被调用。多次调用startService()方法尽管不会多次创建服务，但onStart() 方法会被多次调用。</li><li>与采用Context.bindService()方法启动服务有关的生命周期方法</li><li>onBind()只有采用Context.bindService()方法启动服务时才会回调该方法。该方法在调用者与服务绑定时被调用，当调用者与服务已经绑定，多次调用Context.bindService()方法并不会导致该方法被多次调用。</li><li>onUnbind()只有采用Context.bindService()方法启动服务时才会回调该方法。该方法在调用者与服务解除绑定时被调用</li></ul></li></ul></li><li><p>单线程模型中Message、Handler、Message Queue、Looper之间的关系</p><ul><li>Handler获取当前线程中的looper对象，looper用来存放Message，MessageQueue可取出Message，由Handler对Message进行分发和处理</li><li>Message Queue消息队列：用来存放通过Handler发布的消息，通常附属于某个创建它的线程，可以通过looper.myQueue()得到当前线程的消息队列</li><li>Handler：可以发布或者处理一个消息或者操作一个Runnable，通过Handler发布消息，消息将只会发送到与它相关联的消息队列，也只能处理该消息队列的消息</li><li>Looper：是Handler和消息队列之间通信的桥梁，程序组件首先通过Handler将消息传递给Looper，Looper把消息放入队列；Looper也可以把消息广播给所有的Handler,Handler接受到消息后调用handleMessage进行处理</li><li>Message：消息的类型，在Handler类中的handleMessage方法得到单个消息进行处理</li></ul></li><li><p>在单线程模型下，为了线程通信问题，Android设计了一个Message Queue(消息队列)， 线程间可以通过该Message Queue并结合Handler和Looper组件进行信息交换。下面将对它们进行分别介绍：</p><ul><li>1）Message消息：理解为线程之间交流的信息，处理数据后台线程需要更新UI，则发送Message内含一些数据给UI线程</li><li>2）Handler处理者：是Message的主要处理者，负责Message的发送。Message内容的执行处理，后台线程就是通过传进来的Handler对象引用来sendMessage(Message)；使用Handler需要实现该类的handleMessage(Message)方法，它是处理这些Message的操作</li><li>3）Message Queue消息队列，用来存放Handler发布的消息，按照先进先出执行；每个Message Queue都会有一个对应的Handler，Handler会通过两种方式向message queue发生消息：sendMessage/post这两种消息都会插在message queue队尾并按先进先出执行。但通过这两种方法发送的消息执行的方式略有不同：通过sendMessage发送的是一个message对象,会被 Handler的handleMessage()函数处理；而通过post方法发送的是一个runnable对象，则会自己执行</li><li>4）Looper: Looper是每条线程里的Message Queue的管家。Android没有Global的Message Queue，而Android会自动替主线程(UI线程)建立Message Queue，但在子线程里并没有建立Message Queue。所以调用Looper.getMainLooper()得到的主线程的Looper不为NULL，但调用Looper.myLooper() 得到当前线程的Looper就有可能为NULL</li></ul></li><li><p>Activity、Intent、IntentFilter、Service、Broadcast、BroadcastReceiver</p><ul><li>一个activity呈现了一个用户可以操作的可视化界面</li><li>一个service不包含可视化界面而是后台运行，可与一个activity绑定，通过绑定暴露出来的接口并与其通信</li><li>一个broadcastreceiver是一个接收广播消息并作出回应的component，没有界面</li><li>一个intent是一个intent对象，保存了消息的内容，对activity和service来说，它指定了请求的操作名称和待操作数据URIIntent对象可以显式的指定一个目标component。如果这样的话，android会找到这个component(基于manifest文件中的声明)并激活它。但如果一个目标不是显式指定的，android必须找到响应intent的最佳component。它是通过将Intent对象和目标的intent filter相比较来完成这一工作的；</li><li>一个component的intent filter告诉android该component能处理的intent。intent filter也是在manifest文件中声明的。</li></ul></li><li><p>MVC模式原理</p><ul><li>模型model对象：是应用程序主体部分，负责所有业务逻辑都写在这里</li><li>视图view对象：是应用程序中负责界面的部分，也是MVC中唯一可见的一层，接受用户输入，显示处理结果</li><li>控制器control对象：根据用户输入，控制用户界面数据显示及更新model对象</li></ul></li><li><p>Android系统架构</p><ul><li>Linux内核、运行库、应用框架层、应用层</li></ul></li><li><p>ContentProvider是如何实现数据共享</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之简单工厂模式</title>
      <link href="20161018/designpattern-creator-simple-factory-pattern/"/>
      <url>20161018/designpattern-creator-simple-factory-pattern/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="设计模式之简单工厂模式"><a href="#设计模式之简单工厂模式" class="headerlink" title="设计模式之简单工厂模式"></a>设计模式之简单工厂模式</h1><h2 id="1-问题"><a href="#1-问题" class="headerlink" title="1.问题"></a>1.问题</h2><p>考虑一个简单的软件应用场景，一个软件系统可以提供多个外观不同的按钮（如圆形按钮、矩形按钮、菱形按钮等）， 这些按钮都源自同一个基类，不过在继承基类后不同的子类修改了部分属性从而使得它们可以呈现不同的外观，如果我们希望在使用这些按钮时，不需要知道这些具体按钮类的名字，只需要知道表示该按钮类的一个参数，并提供一个调用方便的方法，把该参数传入方法即可返回一个相应的按钮对象，此时，就可以使用简单工厂模式</p><h2 id="2-模式定义"><a href="#2-模式定义" class="headerlink" title="2.模式定义"></a>2.模式定义</h2><p>简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类</p><h2 id="3-模式结构-amp-UML类图"><a href="#3-模式结构-amp-UML类图" class="headerlink" title="3.模式结构&amp;UML类图"></a>3.模式结构&amp;UML类图</h2><ol><li><p>简单工厂模式包含如下角色：</p><ul><li>Factory：工厂角色 - 工厂角色负责实现创建所有实例的内部逻辑</li><li>Product：抽象产品角色 - 抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口</li><li>ConcreteProduct：具体产品角色 - 具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例</li></ul></li><li><p>UML类图<br><img src="https://blog-bak-1251678165.cos.ap-beijing.myqcloud.com/2016-10-18-SimpleFactory.jpg" alt="SimpleFactory"></p></li></ol><h2 id="4-时序图"><a href="#4-时序图" class="headerlink" title="4.时序图"></a>4.时序图</h2><p><img src="https://blog-bak-1251678165.cos.ap-beijing.myqcloud.com/2016-10-18-seq_SimpleFactory.jpg" alt="seq_SimpleFactory"></p><h2 id="5-实现方式"><a href="#5-实现方式" class="headerlink" title="5.实现方式"></a>5.实现方式</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">package SimpleFactoryPattern;/** * Created by weicools on 2016/10/18. */// Animal.java  抽象产品角色public abstract class Animal {    public abstract void eat();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">package SimpleFactoryPattern;/** * Created by weicools on 2016/10/18. */// Dog.java 具体产品角色public class Dog extends Animal {    @Override    public void eat() {        System.out.println("Dog eat!!!");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">package SimpleFactoryPattern;/** * Created by weicools on 2016/10/18. */// Pig.java 具体产品角色public class Pig extends Animal {    @Override    public void eat() {        System.out.println("Pig eat!!!");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">package SimpleFactoryPattern;/** * Created by weicools on 2016/10/18. */// AnimalFactory.java  工厂角色public class AnimalFactory {    private AnimalFactory() {}    public static Animal animalFactory(String str) {        if (str.equals("dog")){            return new Dog();        } else if (str.equals("pig")){            return new Pig();        } else {            return null;        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">package SimpleFactoryPattern;/** * Created by weicools on 2016/10/18. */public class AnimalTest {    public static void main(String[] args) {        Animal dog = AnimalFactory.animalFactory("dog");        dog.eat();        Animal pig = AnimalFactory.animalFactory("pig");        pig.eat();        Animal animal = AnimalFactory.animalFactory("dog");        animal.eat();        animal = AnimalFactory.animalFactory("pig");        animal.eat();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-模式分析"><a href="#6-模式分析" class="headerlink" title="6.模式分析"></a>6.模式分析</h2><ol><li>将对象的创建和对象本身业务处理分离可以降低系统的耦合度，使得两者修改起来都相对容易。</li><li>在调用工厂类的工厂方法时，由于工厂方法是静态方法，使用起来很方便，可通过类名直接调用，而且只需要传入一个简单的参数即可，在实际开发中，还可以在调用时将所传入的参数保存在XML等格式的配置文件中，修改参数时无须修改任何源代码。</li><li>简单工厂模式最大的问题在于工厂类的职责相对过重，增加新的产品需要修改工厂类的判断逻辑，这一点与开闭原则是相违背的。</li><li>简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节</li></ol><h2 id="7-优点-amp-缺点"><a href="#7-优点-amp-缺点" class="headerlink" title="7.优点&amp;缺点"></a>7.优点&amp;缺点</h2><ol><li>优点(帮助封装/解耦)<ul><li>工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品；简单工厂模式通过这种做法实现了对责任的分割，它提供了专门的工厂类用于创建对象</li><li>客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量</li><li>通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性</li></ul></li><li>缺点(可能增加客户端的复杂度/不方便扩展子工厂)<ul><li>由于工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响</li><li>使用简单工厂模式将会增加系统中类的个数，在一定程序上增加了系统的复杂度和理解难度</li><li>系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护</li><li>简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构</li></ul></li></ol><h2 id="8-使用环境"><a href="#8-使用环境" class="headerlink" title="8.使用环境"></a>8.使用环境</h2><ol><li>工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂</li><li>客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数</li></ol><h2 id="9-模式应用"><a href="#9-模式应用" class="headerlink" title="9.模式应用"></a>9.模式应用</h2><ol><li><p>JDK类库中广泛使用了简单工厂模式，如工具类java.text.DateFormat，它用于格式化一个本地日期或者时间。</p> <pre class="line-numbers language-java" data-language="java"><code class="language-java">public final static DateFormat getDateInstance();public final static DateFormat getDateInstance(int style);public final static DateFormat getDateInstance(int style,Localelocale);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>Java加密技术</p> <pre class="line-numbers language-java" data-language="java"><code class="language-java">// 获取不同加密算法的密钥生成器:KeyGenerator keyGen=KeyGenerator.getInstance("DESede");// 创建密码器:Cipher cp=Cipher.getInstance("DESede");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Java </tag>
            
            <tag> DesignPattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之单例模式</title>
      <link href="20161018/designpattern-creator-singleton-pattern/"/>
      <url>20161018/designpattern-creator-singleton-pattern/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="设计模式之单例模式"><a href="#设计模式之单例模式" class="headerlink" title="设计模式之单例模式"></a>设计模式之单例模式</h1><h2 id="1-问题："><a href="#1-问题：" class="headerlink" title="1.问题："></a>1.问题：</h2><p>对于系统中的某些类来说，只有一个实例很重要，例如，一个系统中可以存在多个打印任务，但是只能有一个正在工作的任务；一个系统只能有一个窗口管理器或文件系统；一个系统只能有一个计时工具或 ID（序号）生成器。如何保证一个类只有一个实例并且这个实例易于被访问呢？</p><h2 id="2-模式定义"><a href="#2-模式定义" class="headerlink" title="2.模式定义"></a>2.模式定义</h2><p>单例模式（Singleton Pattern）：确保一个类只有一个实例，而且自行实例化并向系统提供这个实例，提供全局访问方法。</p><p>实现思路：</p><ul><li>在单例的类中设置一个 private 静态变量 sInstance，sInstance 类型为当前类，用来持有单例唯一的实例。</li><li>将（无参数）构造器设置为 private，避免外部使用 new 构造多个实例。</li><li>提供一个 public 的静态方法，如 getInstance，用来返回该类的唯一实例 sInstance。</li></ul><h2 id="3-模式结构"><a href="#3-模式结构" class="headerlink" title="3.模式结构"></a>3.模式结构</h2><p>UML 类图：<br><img src="https://blog-bak-1251678165.cos.ap-beijing.myqcloud.com/2016-10-18-Singleton.jpg" alt="Singleton"></p><h2 id="4-时序图"><a href="#4-时序图" class="headerlink" title="4.时序图"></a>4.时序图</h2><p><img src="https://blog-bak-1251678165.cos.ap-beijing.myqcloud.com/2016-10-18-seq_Singleton.jpg" alt="seq_Singleton"></p><h2 id="5-七种实现方式"><a href="#5-七种实现方式" class="headerlink" title="5.七种实现方式"></a>5.七种实现方式</h2><h3 id="懒汉式-线程不安全"><a href="#懒汉式-线程不安全" class="headerlink" title="懒汉式,线程不安全"></a>懒汉式,线程不安全</h3><ul><li>在多个线程密集调用 getInstance 时，存在创建多个实例的可能。</li><li>比如线程 A 进入 null == sInstance 这段代码块，而在 A 线程未创建完成实例时，</li><li>如果线程 B 也进入了该代码块，必然会造成两个实例的产生。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * Created by weicools on 2016/10/18. * * 1.0 懒汉式,线程不安全 */public class SingletonLazy {    // 1.一个私有的指向自己的静态变量    private static SingletonLazy instance = null;    // 2.私有的构造方法,保证不能从外部创建对象    private SingletonLazy() {}    // 3.公开的静态工厂方法,返回该类的唯一实例(当发现没有实例没有初始化的时候才初始化)    public static SingletonLazy getInstance() {        if (instance == null) {            instance = new SingletonLazy();            System.out.println("创建SingletonLazy类的实例");        } else {            System.out.println("实例已经创建,不能再创建");        }        return instance;    }    public static void main(String[] args) {        SingletonLazy s = new SingletonLazy();        System.out.println(SingletonLazy.getInstance());        System.out.println(SingletonLazy.getInstance());        System.out.println(SingletonLazy.getInstance());    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="饿汉式-线程安全"><a href="#饿汉式-线程安全" class="headerlink" title="饿汉式,线程安全"></a>饿汉式,线程安全</h3><ul><li>不能完成懒加载</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * Created by weicools on 2016/10/18. * * 2.0 饿汉式,线程安全 */public class SingletonHungry {    // 1.私有的唯一的静态实例变量,在类加载的时候就创建好单例对象    private final static SingletonHungry INSTANCE = new SingletonHungry();    // 2.私有的构造函数,确保不能在类的外部访问该类的构造函数    private SingletonHungry() {        System.out.println("执行构造函数");    }    // 3.公开的静态工厂返回此类的唯一实例    public static SingletonHungry getInstance() {        return INSTANCE;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="懒汉式，线程安全，多线程环境下效率不高"><a href="#懒汉式，线程安全，多线程环境下效率不高" class="headerlink" title="懒汉式，线程安全，多线程环境下效率不高"></a>懒汉式，线程安全，多线程环境下效率不高</h3><ul><li>使用 synchrnozed 修饰 getInstance 方法可能是最简单的一个保证多线程保证单例唯一性的方法。synchronized 修饰的方法后，当某个线程进入调用这个方法，该线程只有当其他线程离开当前方法后才会进入该方法。</li><li>所以可以保证 getInstance 在任何时候只有一个线程进入，但是会导致性能下降，而且 getInstance 是一个被频繁调用的方法。虽然这种方法能解决问题，但是不推荐。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * Created by weicools on 2016/10/18. * * 3.0 单例模式，懒汉式，线程安全，多线程环境下效率不高 */public class SingletonLazySynchronized {    private static SingletonLazySynchronized instance = null;    private SingletonLazySynchronized() {}    public static synchronized SingletonLazySynchronized getInstance() {        if (instance == null) {            instance = new SingletonLazySynchronized();        } else {            System.out.println("实例已经创建,不能再创建");        }        return instance;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="懒汉式，变种，线程安全"><a href="#懒汉式，变种，线程安全" class="headerlink" title="懒汉式，变种，线程安全"></a>懒汉式，变种，线程安全</h3><ul><li>添加静态代码块,初始化实例</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * Created by weicools on 2016/10/18. * * 4.0 单例模式，懒汉式，变种，线程安全 */public class SingletonLazyStatic {    private static SingletonLazyStatic instance = null;    static {        instance = new SingletonLazyStatic();    }    private SingletonLazyStatic() {}    public static SingletonLazyStatic getInstance() {        return instance;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用静态内部类，线程安全【推荐】"><a href="#使用静态内部类，线程安全【推荐】" class="headerlink" title="使用静态内部类，线程安全【推荐】"></a>使用静态内部类，线程安全【推荐】</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * Created by weicools on 2016/10/18. * * 5.0 单例模式，使用静态内部类，线程安全【推荐】 */public class SingletonStaticInner {    private final static class SingletonHolder {        private final static SingletonStaticInner INSTANCE = new SingletonStaticInner();    }    private SingletonStaticInner() {}    public static SingletonStaticInner getInstance() {        return SingletonHolder.INSTANCE;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用枚举方式，线程安全"><a href="#使用枚举方式，线程安全" class="headerlink" title="使用枚举方式，线程安全"></a>使用枚举方式，线程安全</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * Created by weicools on 2016/10/18. * * 6.0 单例模式，使用枚举方式，线程安全 */public enum  SingletonEnum {    INSTANCE;    public void whateverMethod() {    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用双重校验锁，线程安全【推荐】"><a href="#使用双重校验锁，线程安全【推荐】" class="headerlink" title="使用双重校验锁，线程安全【推荐】"></a>使用双重校验锁，线程安全【推荐】</h3><ul><li><p>使用双重检查加锁，首先进入该方法时进行 null == sInstance 检查，如果第一次检查通过，即没有实例创建，则进入 synchronized 控制的同步块,并再次检查实例是否创建，如果仍未创建，则创建该实例。</p></li><li><p>双重检查加锁保证了多线程下只创建一个实例，并且加锁代码块只在实例创建的之前进行同步。如果实例已经创建后，进入该方法，则不会执行到同步块的代码。</p></li><li><p>Volatile 是轻量级的 synchronized，它在多处理器开发中保证了共享变量的“可见性”。可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。使用 volatile 修饰 sInstance 变量之后，可以确保多个线程之间正确处理 sInstance 变量。</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * Created by weicools on 2016/10/18. * * 7.0 单例模式，使用双重校验锁，线程安全【推荐】 */public class SingletonVerifyLock {    private volatile static SingletonVerifyLock instance = null;    private SingletonVerifyLock() {}    public static SingletonVerifyLock getInstance() {        if (instance == null) {            synchronized (SingletonVerifyLock.class) {                if (instance == null) {                    instance = new SingletonVerifyLock();                }            }        }        return instance;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-模式分析"><a href="#6-模式分析" class="headerlink" title="6.模式分析"></a>6.模式分析</h2><p>单例模式的目的是保证一个类仅有一个实例，并提供一个访问它的全局访问点。单例模式包含的角色只有一个，就是单例类——Singleton。单例类拥有一个私有构造函数，确保用户无法通过 new 关键字直接实例化它。除此之外，该模式中包含一个静态私有成员变量与静态公有的工厂方法，该工厂方法负责检验实例的存在性并实例化自己，然后存储在静态成员变量中，以确保只有一个实例被创建</p><p>在单例模式的实现过程中，需要注意如下三点： - 单例类的构造函数为私有； - 提供一个自身的静态私有成员变量； - 提供一个公有的静态工厂方法</p><h2 id="7-实例"><a href="#7-实例" class="headerlink" title="7.实例"></a>7.实例</h2><p>在操作系统中，打印池(Print Spooler)是一个用于管理打印任务的应用程序，通过打印池用户可以删除、中止或者改变打印任务的优先级，在一个系统中只允许运行一个打印池对象，如果重复创建打印池则抛出异常。现使用单例模式来模拟实现打印池的设计</p><h2 id="8-优点-amp-缺点"><a href="#8-优点-amp-缺点" class="headerlink" title="8.优点&amp;缺点"></a>8.优点&amp;缺点</h2><ol><li>优点：<ul><li>提供了对唯一实例的受控访问。因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它，并为设计及开发团队提供了共享的概念</li><li>由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象，单例模式无疑可以提高系统的性能</li><li>允许可变数目的实例。我们可以基于单例模式进行扩展，使用与单例控制相似的方法来获得指定个数的对象实例</li></ul></li><li>缺点：<ul><li>由于单例模式中没有抽象层，因此单例类的扩展有很大的困难</li><li>单例类的职责过重，在一定程度上违背了“单一职责原则”。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起</li><li>滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出</li></ul></li></ol><h2 id="9-使用环境"><a href="#9-使用环境" class="headerlink" title="9.使用环境"></a>9.使用环境</h2><ol><li>系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器，或者需要考虑资源消耗太大而只允许创建一个对象。</li><li>客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。</li><li>在一个系统中要求一个类只有一个实例时才应当使用单例模式。反过来，如果一个类可以有几个实例共存，就需要对单例模式进行改进，使之成为多例模式</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://droidyue.com/blog/2015/01/11/looking-into-singleton/">单例这种设计模式</a></li><li>SwordOffer</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Java </tag>
            
            <tag> DesignPattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础知识</title>
      <link href="20161012/java-base/"/>
      <url>20161012/java-base/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Java-基础知识"><a href="#Java-基础知识" class="headerlink" title="Java 基础知识"></a>Java 基础知识</h1><h2 id="4-1-基本概念"><a href="#4-1-基本概念" class="headerlink" title="4.1 基本概念"></a>4.1 基本概念</h2><ol><li><p> Java 语言优点： - 1).Java 语言为<strong>纯面向对象语言</strong>，编写程序更为容易 - 2).<strong>平台无关性</strong>，可以做到一次编译，到处运行（Java 是解释型语言编译器把 Java 代码变成中间代码，然后在 Java VM 上解释执行，中间代码与平台无关） - 3).Java 内置很多的类库，简化了程序设计工作（提供<strong>多线程支持，网络通信，垃圾回收</strong>……） - 4).提供了<strong>对 Web 应用开发支持</strong>（Applet，Servlet，JSP，Socket，RIM） - 5).具有<strong>较好的安全性和健壮性</strong> - 6).去除 C++难以理解，容易混淆的特性</p><a id="more"></a></li><li><p>Java 与 C/C++区别</p><ul><li>Java 与 C++都是面向对象语言，都使用面向对象思想（封装，继承，多态）</li><li>Java 是<strong>解释型语言</strong>（过程：源代码经过 Java 编译器编译成字节码，然后由 JVM 执行）</li><li>Java<strong>没有指针概念，使程序更加安全</strong></li><li>Java 可以<strong>自动回收垃圾</strong></li></ul></li><li><p>public static void main(String[][1] args)方法</p><ul><li>这是程序的入口方法，JVM 在执行程序时，会先找到 main 方法，public 表示任何一个类或者对象都可以访问这个方法，static 表示 main 方法是静态的</li><li>每个类都可以定义 main 方法，但只是与文件名相同的 public 修饰的类中的方法才可以作为程序入口</li></ul></li><li><p>实现在 main 方法之前输出“Hello world”</p><ul><li>main 方法是程序入口方法，<strong>在程序运行时最先加载；但是不一定是最先执行的</strong></li><li>使用静态代码块可以实现</li></ul></li><li><p>Java 程序初始化顺序</p><ul><li>Java 程序初始化一般遵循三个原则（优先级递减）</li><li><ol><li>静态对象（变量）优先于非静态对象（变量）初始化</li></ol></li><li><ol start="2"><li>父类优先于之类进行初始化</li></ol></li><li><ol start="3"><li>按照成员变量定义顺序进行初始化</li></ol></li></ul></li><li><p>Java 作用域</p><ul><li><p>声明在不同地方的变量具有不同作用域（局部变量、全局变量），在 Java 中作用域由花括号决定（可见性与生命周期）</p></li><li><p>成员变量和方法可见性</p><table><thead><tr><th>作用域与可见性</th><th>当前类</th><th>同一 package</th><th>子类</th><th>其他 package</th></tr></thead><tbody><tr><td>public</td><td>✔️</td><td>✔️</td><td>✔️</td><td>✔️</td></tr><tr><td>protected</td><td>✔️</td><td>✔️</td><td>✔️</td><td>❌</td></tr><tr><td>default</td><td>✔️</td><td>✔️</td><td>❌</td><td>❌</td></tr><tr><td>private</td><td>✔️</td><td>❌</td><td>❌</td><td>❌</td></tr></tbody></table></li></ul></li><li><p>Java 文件可以定义多个类，但是最多只有一个能被 public 修饰，并且这个类必须与文件名相同</p> <pre class="line-numbers language-java" data-language="java"><code class="language-java">// Derived.javaclass Base{    public void print() {        System.out.println("Base");    }}public class Derived extends Base {    public static void main(String[] args) {        Base b = new Derived();        b.print();    }}// 使用java Derived.java指令编译会生成两个字节码文件Base.class和Derived.class// java Derived指令执行代码，输出：Base<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>构造函数：是一种特殊函数，用来在对象实例化的时候初始化对象的成员变量。Java 中它具有以下特点：</p><ul><li>1）构造函数必须与类名相同，并且不能有返回值（返回值也不能是 void）</li><li>2）每个类可以呢有多个构造函数，当开发人员没有提供构造函数时，编译器在把源代码编译成字节码的过程中提供默认无参构造函数，已有构造函数编译器则不会再提供默认构造函数</li><li>3）构造函数可以有 0，1，1+个参数</li><li>4）主要作用是完成对象初始化工作</li><li>5）构造函数总是伴随 new 操作一起调用，不能由程序员直接调用，必须由系统调用；构造函数在对象实例化时被自动调用，且只运行一次；普通方法在程序执行到它时才会调用且可以多次调用</li><li>6）构造函数不能被继承，所以它不能被覆盖但是可以重载</li><li>7）子类可以通过 super 关键字显式调用父类构造函数；当父类没有提供无参构造函数时，子类的构造函数必须显式调用父类构造函数；当父类提供无参数构造函数时，子类可以不显式调用父类构造函数，默认就好调用父类无参数构造函数；对象实例化会先执行父类构造函数然后执行子类构造函数</li><li>8）父类和子类都没有定义构造函数，编译器会给父类和子类分别都生成默认无参构造函数</li></ul></li><li><p>为什么 Java 部分接口没有任何方法</p><ul><li><p>1）Java 为克服单继承缺点，引入接口；接口是抽象方法定义的集合，只有方法定义没有实现，且所有方法均是抽象的；接口中成员作用域修饰符都是 public，接口中常量默认值使用 public static final 修饰；一个类可以实现多个接口，可用来间接达到多重继承目的</p></li><li><p>2）有些接口没有任何方法即实现这些接口不需要重写任何方法，这些接口被叫做标识接口，仅充当标识作用，表明实现它的类属于一个特定类型（例如：Cloneable、Serializable）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">// Test.javaimport Java.Util.ArrayList;interface Stuff{}// 矿石interface Ore exrends Stuff{}// 武器interface Weapon extends Stuff{}// 垃圾interface Rubbish extends Stuff{}// 金矿class Gold implements Ore {    public String toString() {        return "Gold";    }}// 铜矿class Copper implements Ore {    public String toString() {        return "Copper";    }}// 枪class Gun implements Weapon {    public String toString() {        return "Gun";    }}class Stone implements Rubbish {    public String toString() {        return "Stone";    }}public class Test {    public static void main(String[] args) {        Stuff[] s = {new Gold(), new Copper(), new Gun(), new Stone()};        ArrayList&lt;Stuff&gt; list = collectStuff(s);        System.out.println("The usefull Stuff collected is : ");        for(int i = 0; i &lt; list.size(); i++){            System.out.println(list.get(i));        }    }    public static ArrayList&lt;Stuff&gt; collectStuff(Stuff[] s) {        ArrayList&lt;Stuff&gt; list = new ArrayList&lt;Stuff&gt;();        for(int i = 0; i &lt; s.length(); i++){            if(!(s[i).instanceof Rubbish)                list.add(s[i]);        }        return list;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>clone 方法作用：</p></li><li><p>反射机制：它允许程序在运行时进行自我检查，同时也允许对其内部成员进行操作；由于反射机制能够实现在运行时对类进行装载因此可以增加程序灵活性；不恰当的使用也会影响系统性能</p><p>反射机制主要功能：得到一个对象所属的类；获取一个类的所有成员变量和方法；在运行时创建对象；在运行时调用对象的方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">// 在运行时动态创建类的对象class Base{    public void f() {        System.out.println("Base");    }}class Sub extends Base {    public void f() {        System.out.println("Sub");    }}public class Test {    public static void main(String[] args) {        try {        // 使用反射机制动态加载类            Class c = Class.forName("Sub");            Base b = (Base)c.newInstance();            b.f();        } catch(Exception e) {            e.printStackTrace();        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><pre><code>获取class类的方法：1）class.forName("类的路径");2）类名.class;3）实例.getClass();</code></pre></blockquote></li><li><p>package 作用：</p><ul><li>1）提供多层命名空间，解决命名冲突</li><li>2）对类按功能进行分类，使项目结构清晰</li></ul></li></ol><h2 id="4-2-面向对象技术"><a href="#4-2-面向对象技术" class="headerlink" title="4.2 面向对象技术"></a>4.2 面向对象技术</h2><ol><li><p>面向对象与面向过程的区别：</p><ul><li>1）出发点不同。面向对象方法是用于符合常规思维逻辑的方式来处理客观世界的问题，强调把问题域的要领直接映射到对象与对象及对象之间的接口上；而面向过程方法则是强调过程的抽象化与模块化，它是以过程为中心构造或处理客观世界问题</li><li>2）层次逻辑关系不同。</li><li>3）数据处理方式与程序控制方式不同。</li><li>4）分析设计与编码转换方式不同。</li></ul></li><li><p>面向对象特征：</p><ul><li>1）抽象：抽象是忽略一个主题中与当前目标无关的那些方面，以便充分注意与当前目标有关的方面；抽象包括过程和数据抽象</li><li>2）继承：是一种联结类的层次模型，并且允许和鼓励类的重用，它提供一种明确表述共性的方法；对象的一个新类可以从现有的类中派生。新类继承原始类的特性</li><li>3）封装：是指将客观事物抽象成类，每个类对自身的数据和方法实行保护，类可以吧自己的数据和方法让可信的类或者对象操作，对不可信的进行隐藏</li><li>4）多态：允许不同类的对象对同一消息作出响应；多态包含参数化多态和包含多态；多态性语言具有灵活、抽象、行为共享等优势，很好解决了应用程序函数同名的问题</li></ul></li><li><p>面向对象开发优点：</p><ul><li>1）较高开发效率。</li><li>2）保证软件的鲁棒性。面向对象的开发方法有很高的重用性，在开发的过程中可以重用已有的而且相关领域经过长期测试的代码</li><li>3）保证软件的高可维护性。代码可读性高；设计模式使得代码结构清晰，并且面对需求变更的时候只需修改部分代码即可满足需求</li></ul></li><li><p>继承：是面向对象中非常重要的一个特性，通过继承，子类可以使用父类的一些成员变量与方法，从而提高代码复用性，提高开发效率。继承通过 extends 关键字实现。继承具有如下特性：</p><ul><li>1）Java 语言不支持多重继承，子类只能继承一个父类，但是可以通过接口的方式实现多重继承</li><li>2）子类只能继承父类非 private 得成员变量与方法</li><li>3）子类定义的成员变量与父类相同时，子类成员变量会覆盖父类成员变量</li><li>4）子类中的方法与父类中的方法有相同的签名（方法名，参数个数与类型）子类将会覆盖父类的方法</li></ul></li><li><p> 组合与继承的区别：继承（is-a）组合（has-a）</p></li><li><p>多态实现机制：</p><ul><li>1）方法重载 overload：同一个类中有多个方法，方法有着不同的参数</li><li>2）方法覆盖 override：子类方法覆盖父类方法</li></ul></li><li><p>重载和覆盖：overload 和 override 是 Java 多态性的不同表现形式</p><ul><li><p>1）重载是多态的一种表现，指一个类定义多个同名方法；重载通过不同方法参数区分的，不能通过访问权限、返回值类型、抛出异常类型区分</p></li><li><p>2）覆盖是指子类函数覆盖父类函数，对一个方法进行重写以达到不同的作用；覆盖时必须有相同的方法名称和参数、相同返回值类型、抛出的异常也相同；另外父类中的方法是 private 的话，子类则只是定义了一个方法，并没有覆盖</p></li><li><p>3）两者区别：覆盖是子类和父类之间的关系，属于垂直关系，重载是同一个类中的方法之间的关系，属于水平关系；重载要求参数列表不同，覆盖要求相同。。。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Super {    public int f() {        return 1;    }}public class SubClass extends Super {    public static void main(String[] args){        Super s = new SubClass();        System.out.println(s.f());    }    public float f() {        return 2f;    }}// 编译错误。因为函数是不能通过返回值来区分<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>抽象类与接口：</p><ul><li><p>1）相同点：都不能被实例化；接口的实现类或者抽象类的子类只有实现了接口或者抽象类中的方法才能被实例化</p></li><li><p>2）不同点：</p><table><thead><tr><th>接口</th><th>抽象类</th></tr></thead><tbody><tr><td>只有定义，方法不能在接口中实现</td><td>方法可以在抽象类中实现</td></tr><tr><td>接口需要实现（implements）一个类可以实现多个接口</td><td>抽象类需要继承（extends）一个类只能继承一个抽象类</td></tr><tr><td>接口强调功能实现，设计理念是”has-a”关系</td><td>抽象类强调所属关系，设计理念是”is-a”关系</td></tr><tr><td>接口中定义的成员变量默认为 public static final，只能含有静态的不能被修改的数据成员且必须赋初始值，所以成员方法都是 public、abstract 的</td><td>抽象类成员变量默认是 default，也可以被定义为 public，private，protected；抽象方法不能使用 private，static，synchronized，native 修饰且不能含有方法体</td></tr><tr><td>接口常用于实现比较常用的功能，便于提后维护或者添加删除方法</td><td>抽象类更倾向于充当公共类的角色，不适合日后对代码进行修改</td></tr></tbody></table></li></ul></li><li><p>内部类：在类里面的类叫做内部类，外面就是外部类；共分为 4 种：静态内部类，成员内部类，局部内部类，匿名内部类</p> <pre class="line-numbers language-java" data-language="java"><code class="language-java">class outClass {    // 静态内部类    static class innerClass {}}class outClass {    // 成员内部类    class innerClass {}}class outClass {    public void f() {        // 局部内部类        class innerClass {}    }}public class MyFrame extends Frame {    public MyFrame() {        addWindowListener(new Windows=Adapter(){    // 匿名内部类            // 方法。。。        });    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><pre><code>匿名内部类：不能有构造函数；不能使用关键字class、extends、implements；不能定义静态成员、方法、类；匿名内部类不能是public、protected。private、static；只能创建匿名内部类的一个实例</code></pre></blockquote></li><li><p>获取父类类名：通过调用 getClass().getName();</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Test {    public void test() {        System.out.println(this.getClass().getName());    }    public static void main(String[] args) {        new Test().test();    }}// 输出：Test<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">class A {}public class Test extends A {    public void test() {        System.out.println(super.getClass().getName());    }    public static void main(String[] args) {        new Test().test();    }}// ？输出：Test// Java中任何类都继承Object类，getClass()方法在Object中被定义为final与native，子类不能覆盖该方法// 所以this.getClass()与super.getClass最终调用的都是Object中的getClass()方法// Object的getClass()方法定义是返回此Object的运行时类<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">class A {}public class Test extends A {    public void test() {        System.out.println(this.getClass().getSuperclass().getName());    }    public static void main(String[] args) {        new Test().test();    }}// 输出：A// 使用反射机制可以得到<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>this 与 super</p><ul><li>1）this 用来指当前实例的对象，它的一个非常重要的作用是区分对象的成员变量与方法的形参</li><li>2）super 可以用来访问父类的方法或者成员变量（当子类中的成员方法或者变量与父类相同时会覆盖父类的方法或者成员变量）</li></ul></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Base {    public void f() {        System.out.println("Base:f()");    }}class Sub extends Base {    public void f() {        System.out.println("Sub:f()");    }    public void subf() {        f();    }    public void basef() {        super.f();    }}public class Test {    public static void main(String[] args) {        Sub s = new Sub();        s.subf();        s.basef();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-3-关键字"><a href="#4-3-关键字" class="headerlink" title="4.3 关键字"></a>4.3 关键字</h2><ol><li><p>变量命名规则：变量名、函数名、数组名统称为标识符，它只能由字母（a<del>z, A</del>Z）/数字（0~9）/下划线（_）/$组成，且第一个不能是数字，也不能含有换行符、空格、制表符、Java 保留的字符</p></li><li><p>break、continue、return：</p></li><li><p>final、finally、finalize：</p><ul><li>1）final 用于声明属性、方法、类；分别表属性不可变（引用不可变）、方法不可覆盖、类不可被继承</li><li>2）finally 作为异常处理的一部分，只能使用在 try/catch 语句中，表这段语句最终一定被执行，常用语释放资源</li><li>3）finalize 是 Object 类的一个方法，</li></ul></li><li><p>assert：assert 断言是作为软件调试的一种方法，提供在代码中进行正确性检查的机制；主要作用是对一个 boolean 表达式进行检查，正确运行程序必须保证 boolean 为 true，若为 false 系统需要提供警告信息并退出</p></li><li><p>static 关键字作用：</p><ul><li>1）为特定数据类型或者对象分配单一的存储空间，而与创建对象的个数无关</li><li>2）在不创建对象时就可以直接通过调用方法或者使用类的属性</li><li>3）static 主要使用在成员变量、成员方法、代码块、内部类</li></ul></li><li><p>switch：switch 语句用于多分支选择，switch(expr)中 expr 只能是枚举常量或者整数表达式</p></li><li><p>volatile 作用：是一个类型修饰符，被设计用来修饰不同线程访问和修改的变量，被 volatile 修饰的变量，系统每次调用到它都是从缓存当中提取</p></li><li><p>instanceof 作用：instanceof 是 Java 语言中一个二次元运算符，它的作用是判断一个引用类型的变量所指向的对象是否是一个类或接口、抽象类、父类的实例。</p></li></ol><h2 id="4-4-基本类型运算"><a href="#4-4-基本类型运算" class="headerlink" title="4.4 基本类型运算"></a>4.4 基本类型运算</h2><ol><li><p>基本数据类型：byte-8bit、short-16bit、int-32bit、long-64bit、float-32bit、double-64bit、char-16bit、boolean</p></li><li><p>不可变类：当创建这个类的实例后，就不允许修改它的值</p></li><li><p>值传递与引用传递：</p><ul><li>1）值传递：在方法调用中，实参会把值传递给形参，形参只是用实参的值初始化一个临时存储的单元，所以形参和实参虽有相同的值，却有不同的存储单元，形参改变不影响实参的值</li><li>2）引用传递：在方法调用中传递的是对象（对象的地址）这时形参与实参的对象指向同一块存储单元，修改形参会印象实参</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Test {    public static void testPassParameter(StringBuffer ssq, int n){        ss1.append("World");        n = 9;    }    public static void main(String[] args) {        int a = 1;        StringBuffer sb = new StringBuffer("Hello");        testPassParameter(sb, a);        // 打印sb和a    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>不同数据类型转换规则</p></li><li><p>强制类型转换注意事项</p></li><li><p>运算符优先级：</p><p>| 优先级 | 运算符                        |<br>| —— | —————————– | ——————– | — |<br>| 1      | . () []                       |<br>| 2      | +正 -负 ++ — ~ !              |<br>| 3      | * / %                        |<br>| 4      | + -                           |<br>| 5      | &lt;&lt; &gt;&gt;无符号右移 &gt;&gt;&gt;有符号右移 |<br>| 6      | &lt; &lt;= &gt; &gt;= instanceof          |<br>| 7      | == !=                         |<br>| 8      | &amp;                             |<br>| 9      |                               |                      |<br>| 10     | ^                             |<br>| 11     | &amp;&amp;                            |<br>| 12     |                               |                      |     |<br>| 13     | ?:                            |<br>| 14     | = += -= *= /= &amp;= =           | = ^= ~= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;= |</p></li><li><p>Math 类中的关键方法：</p><ul><li>1）round 方法表四舍五入，返回值为 int 型；Math.round(11.5)=12,Math.round(-11.5)=11</li><li>2）ceil 向上取整，返回值 double 型，正数小数入，负数小数舍</li><li>3）floor 向下取整</li></ul></li><li><p>i++与++i：前者是郑旭执行完自增，后者是先自增然后执行</p></li><li><p>（&gt;&gt;）有符号右移；（&gt;&gt;&gt;）无符号右移，有符号右移在执行时，正数高位补 0，负数高位补 1，无符号则是都补 0</p></li><li></li></ol><h2 id="4-5-字符串与数组"><a href="#4-5-字符串与数组" class="headerlink" title="4.5 字符串与数组"></a>4.5 字符串与数组</h2><ol><li><p>字符串创建与存储机制</p><ul><li>1）对于 String s1 = new String(“abc”);和 String s2 = new String(“abc”);存在两个引用对象，它们在内存中的地址不同</li><li>2）对于 String S1 = “abc”;和 String S2 = “abc”;在 JVM 中存在字符串常量池，保持很多的 String 对象，并且可以被共享使用</li></ul></li><li><p>==、equals、hashCode 的区别</p><ul><li>1）==用来比较两个变量的值是否相等</li><li>2）equals()是 Object 类提供的基本方法，，每个类都继承自 Object 类，每个对象都有 equals()方法，比较的是引用（Set 中元素不重复使用 equals()方法）</li><li>3）hashCode()方法是从 Object 类中继承来的，也用来鉴定两个对象是否相等，此方法返回对象在内存中地址转换成的一个 int 型的值，如果没有重新 hashCode()方法，任何对象的 hashCode()方法都是不等</li></ul></li><li><p>String,StringBuffer,StringBuilder,StringTokenizer</p><ul><li>String,StringBuffer,StringBuilder,StringTokenizer 都可以对字符串操作，character 用于单个字符，String 用于字符串操作，属于不可变类；而 StringBuffer 也是用于字符串操作但是属于可变类</li><li>String 是不可变类，对象一旦被创建其值不可变而 StringBuffer 可以改变值</li><li>实例化 String 时可以使用构造函数 String s = new String(“qwe”);或者 String s = “qwe”;</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">String s = "hell0";s += "weico";// 等价于StringBuffer sb = new StringBuffer(s);s.append("weico");s = sb.toString();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>StringBuilder 也可以修改字符串，都是字符串缓冲区，但是 StringBuilder 不是线程安全的，如果在单线程中使用字符串缓冲区 StringBuilder 效率高一些。效率 StringBuilder&gt;StringBuffer&gt;String</li><li>StringTokenizer 是用来分割字符串的</li></ul></li><li><p>数组是一个对象，数组是指具有相同类型的数据集合，它们一般具有固定长度，在内存中占据连续的空间</p></li><li><p>数组初始化方式：</p><ul><li>一维数组：type arrayName[]或者 type[] arrayName,type 可以是基本数据类型也可以是类，Java 创建数组后会根据数组存放类型进行初始化值（int 初始化为 0，对象初始化为 null）</li><li>二维数组：type arrayName[][]或者 type[][] arrayName 或者 type[] arrayName[]</li></ul></li><li><p>length 属性与 length()方法：length 可以获取数组长度，length()获取字符串长度，另外 size()是计算泛型集合有多少个元素</p></li></ol><h2 id="4-6-异常处理"><a href="#4-6-异常处理" class="headerlink" title="4.6 异常处理"></a>4.6 异常处理</h2><ol><li>finally 块中代码什么时候执行：（一定会被执行）</li><li>异常处理原理：异常是指程序运行时，所发生的非正常或者错误，当程序违语义规则 jvm 将会出现错误表示一个异常并抛出，可以 catch 程序块捕获</li><li>运行时异常和普通异常：<ul><li>Java 提供两种错误的异常类 Error 和 Exception，且拥有共同父类 Throwable；Error 不可恢复，Exception 可恢复</li><li>检查异常：是程序中最常碰到的异常，所有继承自 Exception 的异常除了运行时异常就是检查异常。比如 IO/SQL 异常</li><li>运行时异常，编译器没有强制对其进行捕获处理，由 JVM 来处理，如 NullPointException 异常，ClassCastException 类型转换异常，ArrayIndexOutOfBounds 数组越界异常，StoreException，BufferOverflowException</li></ul></li></ol><h2 id="4-7-输入输出流"><a href="#4-7-输入输出流" class="headerlink" title="4.7 输入输出流"></a>4.7 输入输出流</h2><ol><li><p>Java IO 流实现机制</p><ul><li>输入和输出都被成为抽象的流，流可以看作有序的字节集合</li><li>流的本质是数据传输，根据处理数据类型不同可分为字节流和字符流</li><li>字节流以字节 8bit 为单位，包含抽象类 InputStream 和 OutputStream；字符流以字符 16bit 为单位，包含 Reader 和 Writer</li><li>区别在于字节流处理数据不会用到缓存</li></ul></li><li><p>管理文件和目录的类：File</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>File(String path)</td><td>根据制定的路径创建 File 对象</td></tr><tr><td>createNewFile()</td><td>若目录或文件存在返回 false，否则创建文件或文件夹</td></tr><tr><td>delete()</td><td>删除文件或文件夹</td></tr><tr><td>isFile()</td><td>判断是否是文件</td></tr><tr><td>isDirectory()</td><td>判断是不是文件夹</td></tr><tr><td>listFiles()</td><td>若对象代表目录，则返回目录中所有文件的 File 对象</td></tr><tr><td>mkdir()</td><td>创建目录</td></tr><tr><td>exist()</td><td>是否存在</td></tr></tbody></table></li><li><p>Java Socket：也称为套接字，在 Java 中分为：面向连接的 Socket 通信协议 TCP，面向无连接的 UDP</p><ul><li>基于 TCP 的通信过程：首先 Server 端 Listen 指定某个端口是否由连接请求，client 向 server 发出连接，最后 server 返回接受信息</li><li>Socket 生命周期：打开 Socket、使用 Socket 收发数据，关闭 Socket</li></ul></li><li><p>JavaNIO</p></li><li><p>Java 序列化：Java 提供两种对象持久化方式，分别是序列化和外部序列化</p><ul><li>1）序列化 Serialization；序列化是一种将对象以一连串的字节描述的过程，用于解决在对对象进行读写操作时所引发的问题，可将对象的状态下载流里进行网络传输，或者保存到文件/数据库，并在需要时将流读取出来重新构造一个相同对象</li><li>2）实现序列化的类都必须实现 Serializable 接口（位于 java.lang 包），里面没有任何方法</li><li>3）序列化特点：如果一个类能被序列化，其子类也可以被序列化；由于 static 表类的成员是静态的，transient 表对象的临时数据，因此被这两个关键字声明是不能够序列化的</li></ul></li></ol><h2 id="4-8-java-平台内存管理"><a href="#4-8-java-平台内存管理" class="headerlink" title="4.8 java 平台内存管理"></a>4.8 java 平台内存管理</h2><ol><li><p>Java 平台独立性：中间码，虚拟机将中间码翻译成硬件平台能够执行的代码（.class 文件有 JVM 执行）-动态解释型语言</p></li><li><p>Java 平台特效：JVM+JavaAPI</p></li><li><p>JVM 加载 class 文件机制：类加载分为隐式和显示，隐式加载是指程序使用 new 的方式创建对象，会隐式的调用类的加载器，把对应的类加载到 jvm 中；显示加载是指直接通过 class.forName()把所需要的类加载到 jvm</p></li><li><p>GC 垃圾回收：主要作用回收程序中不再使用的内存，它需要完成三项任务：内存分配，确保被引用的对象的内存不被错误的回收，回收不再被引用的对象</p><ul><li>1）开发人员可以从复杂的释放内存工作中解放出来，提高了开发人员的效率</li><li>2）屏蔽释放内存的方法，避免开发人员错误的操作内存而导致程序崩溃，保证程序稳定性</li><li>3）对于对象若没有任何变量去引用它，那么该对象将不可能被程序访问，因此可视为垃圾信息</li><li>4）对于垃圾回收器，它使用有向图来记录和管理堆内存中所有对象</li><li>5）常用垃圾回收算法：引用计数-Reference Counting Collector，追踪回收 Tracing Collector，压缩回收 Comparing Collector，赋值回收 Coping Collector，按代回收 Generational Collector</li></ul></li><li><p>java 是否存在内存泄漏</p><ul><li>内存泄漏是指不在被程序对象使用的或者变量还在内存中占有一定空间</li><li></li></ul></li><li><p>Java 中堆和栈</p><ul><li>基本数据类型和对象的引用变量，其内存都分配在栈上，变量出了作用域就会被释放</li><li>引用类型的变量，内存分配在堆上或者常量池中（如 String 常量和基本数据类型的常量）</li></ul></li></ol><h2 id="4-9-容器"><a href="#4-9-容器" class="headerlink" title="4.9 容器"></a>4.9 容器</h2><ol><li><p>Java Collections 框架</p><ul><li>Java collections 框架包含许多集合接口和这些接口的实现类和操作他们的算法（排序，查找，反转，替换，复制，取最小最大元素），主要提供 List，Queue，Set，Stack，Map，前四个都继承自 Collection 接口</li><li>Set：数学意义上的集合，主要特点元素不能重复，每个元素都必须定义 equals 方法确保唯一</li><li>List：有序 collection，它按对象进入的顺序保存，可保存重复对象</li><li>Map：提供从键映射到值得数据结构，用于保存键值对，值可以重复，键是唯一。Java 有许多实现该接口的类：HashMap，TreeMap，LinkedHashMap，WeakHashMap，IdentityHashMap</li></ul></li><li><p>迭代器 Iterator：遍历并选择序列中的对象，提供一种访问一个容器对象中的所有元素，而又不暴露该对象的内部细节方法，使用迭代需要注意</p><ul><li>1）使用容器的 iterator()方法返回一个 Iterator，然后通过 Iterator 的 next()方法返回第一个元素</li><li>2）使用 Iterator 的 hasNext(）方法判断容器中是否还有元素，若有则使用 next()方法获取下一个元素</li><li>3）通过 Iterator 的 remove()方法删除迭代器返回的元素</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class IteratorTest {    public static void main(String[] args) {        List&lt;String&gt; ll = new LinkedList&lt;String&gt;();        ll.add("first");        ll.add("second");        ll.add("third");        ll.add("fourth");        for (Iterator&lt;String&gt; iter  = ll.iterator(); iter.hasNext();) {            String s = iter.next();            System.out.println(s);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>ArrayList，Vector，LinkedList</p><ul><li>ArrayList 和 Vector 都是基于存储元素 Object[] array 来实现，他们会在内存中开辟一块连续空间来存储，数据存储是连续的，所以支持使用序列号来访问元素，查找速度较快，插入数据较慢；两者都有初始化的容量大小，为了提高程序效率 vector 每次扩充 2 倍，ArrayList 扩充 1.5 倍</li><li>LinkedList 是采用双向列表来实现的，对数据的索引需要从表头开始遍历，随机访问效率低，但是插入元素时不需要对数据进行移动，插入效率高</li></ul></li><li><p>HashMap，HashTable，TreeMapWeakHashMap</p><ul><li>Java 为数据结构的映射定义了一个接口 java.util.Map，它包括 3 个实现类 HashMap，HashTable，TreeHash</li><li>HashMap 是最常用的 Map，它根据键的 HashCode 存储数据，由键可以获取值，具有访问速度快。HashMap 和 HashTable 都使用 hash 法进行索引。不同之处 1）HashMap 是 HashTable 的轻量级实现（非现场安全的实现），都完成了 Map 接口，HashMap 允许空键值（由于键唯一性，最多允许一条记录键为 null，不允许多条记录的值为空）HashTable 不允许；2）HashMap 把 HashTable 的 contains 方法去掉了，改为 containsvalue 和 containsKey；3）HashTable 的方法是线程安全的，HashMap 不支持线程同步，所以是现场不安全的，需要开发人员提供额外的同步机制；4）HashTable 使用 Enumeration，HashMap 使用 Iterator；5）HashTable 中 hash 数组默认大小是 11，增加方式是原来大小*2+1，而 HashMap 中 hash 数组的默大小是 16，而且一定是 2 的指数</li></ul></li><li><p>使用自定义类型作为 HashTable 和 HashMap 需要注意</p></li><li></li></ol><h2 id="4-10-多线程"><a href="#4-10-多线程" class="headerlink" title="4.10 多线程"></a>4.10 多线程</h2><ol><li><p>线程</p><ul><li>线程是程序在执行过程中，能够执行程序代码的一个执行单元，共有四种状态：运行，就绪，挂起，结束</li><li>多线程可减少程序执行时间，提供效率</li><li>线程切换开销更小</li></ul></li><li><h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2></li><li><p>实现 Java 多线程方法</p><ul><li>1）继承 Thread 类，重写 run()方法</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">class MyThread extends Thread {    public void run() {        System.out.println("Thread body");    }    public class Test {        public static void main(String[] args) {            MyThread t = new MyThread();            t.start();//开启线程，不立即执行多线程代码，而是使线程变为可运行状态        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>2）实现 Runnable 接口</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">// 自定义类并实现Runnable接口，实现run()方法// 创建Thread对象，实现Runnable接口的对象作为参数实例化该Thread对象// 调用Thread的start()方法class MyThread implements Runnable {    public void run() {        System.out.println("Thread body");    }    public class Test {        public static void main(String[] args) {            MyThread t = new MyThread();            Thread thread = new Thread(t);            t.start(); //开启线程            // 最终都是通过Thread的对象的API来控制线程        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>3)实现 Callable 接口，重写 call()方法；Callable 在任务结束后提供一个返回值，call()方法可以抛出异常，</li></ul></li><li><p>run()方法与 start()方法</p><ul><li>系统通过调用 Thread 的 start 方法启动一个线程，此时处于就绪态，通过调用 run 方法来完成实际操作</li></ul></li><li><p>多线程同步方法</p><ul><li>1）synchronized 关键字：Java 中每个对象都有一个对象锁与之相关联，该锁表明对象在任何时候只允许被一个线程锁拥有，当一个线程调用对象的一段 synchronized 代码时，需要先获得这个锁，然后去执行相关代码，释放锁。synchronized 主要有两种用法：synchronized 方法和 synchronized 块<ul><li>synchronized 方法：public synchronized void mutiThreadAccess();</li><li>synchronized 块：可以把任意代码段声明为 synchronized，也可以指定上锁的对象 synchronized(syncObject){}</li></ul></li><li>2）wait()与 notify()：使用 synchronized 修饰某个共享资源师，当线程 A1 在执行 synchronized 代码，A2 也在等同一对象的同一个 synchronized 代码才能继续执行，这时需要 wait 和 notify 方法；在 synchronized 被执行时，线程可以调用对象的 wait 方法</li><li>3)lock()：以阻塞的方式获取锁，若获取到了锁，立即返回；若别的线程持有锁，当前线程等待，直到获取锁后返回。</li></ul></li><li><p>sleep()方法与 wait()方法区别：sleep()是使线程暂停执行一段时间</p><ul><li>1）原理不同：sleep()方法是 Thread 类的静态方法，是线程用来控制自身流程的，它会使此线程暂停执行一段时间</li><li>2）对锁的处理机制不同</li><li>3）使用区域不同：wait 必须使用在同步方法或者同步代码块；sleep 必须抛出异常</li></ul></li><li><p>终止线程方法：stop()和 suspend()</p></li><li><p>synchronized 与 lock</p></li><li><p>守护线程：服务进程/后台进程</p></li><li><p>join()方法：让调用该方法的线程在执行完 run 方法之后，再执行 join 方法后面的代码</p></li></ol><h2 id="4-11-Java-数据库操作"><a href="#4-11-Java-数据库操作" class="headerlink" title="4.11 Java 数据库操作"></a>4.11 Java 数据库操作</h2><ol><li>通过 JDBC 连接数据库：用于在 Java 程序中实现数据库操作，提供了执行 SQL 语句，访问各种数据库的方法，并为不同的数据库提供接口；java.sql 包含了 JDBC 操作数据库的所有类；通过 JDBC 访问数据库步骤：<ul><li>1）加载 jDBC 驱动器，将数据库的 JDBC 加载到 classpath 中（JavaEE web 需要把目标数据库的 JDBC 驱动复制到 WEB-INF/lib）</li><li>2）加载 JDBC 驱动，并注册到 DriveManager 中；一般使用反射 class.forName(String driveName)</li><li>3）建立数据库连接，取得 Connection 对象一般通过 DriveManager.getConnection(url, username, pw)</li><li>4）建立 Statement 对象或者 PrepareStatement 对象</li><li>5）执行 SQL 语句</li><li>6）访问结果集 ResultSet 对象</li><li>7）依次将 ResultSet、Statement、PrepareStatement、Connection 关闭，释放掉所有占有的资源（JDBC 在底层通常都是通过网络 IO 实现 SQL 命令）</li></ul></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java常考面试题</title>
      <link href="20160828/interview-java-summary/"/>
      <url>20160828/interview-java-summary/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Java-常考面试题"><a href="#Java-常考面试题" class="headerlink" title="Java 常考面试题"></a>Java 常考面试题</h1><ol><li>什么是 Java 虚拟机，为什么 Java 是平台无关性的语言？</li></ol><ul><li>Java 虚拟机是一个可以执行 Java 字节码的虚拟机进程。Java 源文件被编译成能被 Java 虚拟机执行的字节码文件</li><li>Java 被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java 虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性； JVM 屏蔽了与具体操作系统平台相关的信息，使得 Java 程序只需生成在 Java 虚拟机上运行的目标代码（ 字节码 ），就可以在多种平台上不加修改地运行<a id="more"></a></li></ul><ol start="2"><li>JDK 和 JRE 的区别</li></ol><ul><li>Java 运行时环境(JRE)是将要执行 Java 程序的 Java 虚拟机。它同时也包含了执行 applet 需要的浏览器插件</li><li>Java 开发工具包(JDK)是完整的 Java 软件开发包，包含了**JRE，编译器和其他的工具(比如：JavaDoc，Java 调试器)**，可以让开发者开发、编译、执行 Java 应用程序</li></ul><ol start="3"><li>”static”关键字？Java 中是否可以覆盖(override)一个 private 或者是 static 的方法？</li></ol><ul><li>“static”关键字表示静态的意思，可用于修饰变量和成员函数，被 static 修饰的成员函数只能访问静态成员，静态是随着类加载而加载的，因此可以直接用类进行访问</li><li>Java 中 static 方法不能被覆盖，因为覆盖是基于运行时动态绑定的，而 static 方法是编译时静态绑定的</li><li><strong>重写是子类中的方法和子类继承的父类中的方法一样（函数名，参数，参数类型，反回值类型）</strong>，但是子类中的访问权限要不低于父类中的访问权限。重写的前提是必须要继承，private 修饰不支持继承，因此被私有的方法不可以被重写。静态方法形式上可以被重写，即子类中可以重写父类中静态的方法。但是实际上<strong>从内存的角度上静态方法不可以被重写</strong></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Super{  static String getString(){    return "Good night"  }  String name(){    return "Weico"  }}class Sub extends Super{  static String getString(){    return "Hello"  }  String name(){    return "lecymeng"  }}class Test{  public static void main(String[] args){    Super s = new Sub();    System.out.println(s.getString() + "," + s.name());    // 输出结果：Good night,lecymeng    // 实例方法被覆盖，静态方法被隐藏  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li>是否可以在 static 环境中访问非 static 变量？</li></ol><ul><li>静态的成员属于类，随着类的加载而加载到静态方法区内存，当类加载时，此时不一定有实例创建，没有实例，就不可以访问非静态的成员</li><li>当类被 Java 虚拟机载入的时候，会对 static 变量进行初始化。如果你的代码尝试不用实例来访问非 static 的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上</li></ul><ol start="5"><li>Java 支持的数据类型有哪些？什么是自动拆装箱？</li></ol><ul><li>Java 支持 8 中基本数据类型：byte/short/int/long/float/double/boolean/char</li><li>自动装箱是 Java 编译器在基本数据类型和对应的对象包装类型之间的转化。byte-&gt;Byte;short-&gt;Short;int-&gt;Integer;long-&gt;Long;float-&gt;Float;double-&gt;Double;boolean-&gt;Boolean;char-&gt;Character.反之就是自动拆箱</li></ul><ol start="6"><li>Java 中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？</li></ol><ul><li>Java 中的方法重载 Overloading 发生在<strong>同一个类</strong>里面两个或者是多个方法的<strong>方法名相同但是参数不同</strong>的情况</li><li>方法覆盖 Overriding 是说子类重新定义了父类的方法。方法覆盖必须有相同的方法名，参数列表和返回类型。覆盖者可能不会限制它所覆盖的方法的访问</li><li>访问权限&gt;=父类，抛出异常必须&lt;=父类（或者不抛异常）。（特殊点，如果子类重写的方法所抛异常小于父类，那么就不能调用父类的方法，因为子类的异常小，捕获不了 ）， private 修饰的父类方法不能被重写</li></ul><ol start="7"><li>Java 中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？</li></ol><ul><li>当新对象被创建的时候，构造函数会被调用。每一个类都有构造函数。在程序员没有给类提供构造函数的情况下，Java 编译器会为这个类创建一个默认的构造函数</li><li>Java 中构造函数重载和方法重载很相似；可以为一个类创建多个构造函数。每一个构造函数必须有它自己唯一的参数列表</li><li>Java 不支持像 C++中那样的复制构造函数，这个不同点是因为如果你不自己写构造函数的情况下，Java 不会创建默认的复制构造函数</li></ul><ol start="8"><li>Java 支持多继承么？</li></ol><ul><li>Java 中<strong>类不支持多继承</strong>，只支持单继承（即一个类只有一个父类）</li><li>但是 java 中的<strong>接口支持多继承</strong>，即一个子接口可以有多个父接口。（接口的作用是用来扩展对象的功能，一个子接口继承多个父接口，说明子接口扩展了多个功能，当类实现接口时，类就扩展了相应的功能）</li></ul><ol start="9"><li>接口和抽象类的区别是什么？</li></ol><ul><li>Java 提供和支持创建抽象类和接口，它们的实现有共同点，也有不同之处：</li><li>接口中所有的方法隐含的都是抽象方法 / 而抽象类则可以同时包含抽象和非抽象方法</li><li>类可以实现多个接口 / 但是只能继承一个抽象类</li><li>Java 接口中申明的变量默认都是 public static final / 抽象类可以包含非 final 的变量</li><li>Java 接口中的成员函数默认是 public 的 / 抽象类的成员函数可以是 private，protected 或者是 public</li><li>接口是绝对抽象的，不可以被实例化 / 抽象类也不可以被实例化，但是，如果它包含 main 方法的话是可以被调用的</li><li>类可以不实现抽象类和接口声明的所有方法(在这种情况下，类也必须得声明成是抽象的)</li><li>抽象类可以在不提供接口方法实现的情况下实现接口–？</li></ul><ol start="10"><li>什么是值传递和引用传递？</li></ol><ul><li>值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量</li><li>引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身 。 所以对引用对象进行操作会同时改变原对象.</li><li>一般认为,java 内的传递都是值传递</li><li>问题来了：java 中对象作为参数传递给一个方法，到底是值传递，还是引用传递？<ul><li>值传递！Java 中只有按值传递，没有按引用传递！</li></ul></li></ul><ol start="11"><li>进程和线程的区别是什么？</li></ol><ul><li>进程是执行着的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。线程又叫做轻量级进程</li></ul><ol start="12"><li>创建线程有几种不同的方式？你喜欢哪一种？为什么？</li></ol><ul><li>继承 Thread 类</li><li>实现 Runnable 接口</li><li>应用程序可以使用 Executor 框架来创建线程池</li><li>实现 Runnable 接口这种方式更受欢迎，因为这不需要继承 Thread 类。在应用设计中已经继承了别的对象的情况下，这需要多继承（而 Java 不支持多继承），只能实现接口。同时，线程池也是非常高效的，很容易实现和使用</li></ul><ol start="13"><li>概括的解释下线程的几种可用状态</li></ol><ul><li>1.新建（new）：新创建了一个线程对象</li><li>2.可运行（runnable）：线程对象创建后，其他线程（例如 main 线程）调用了该线程的 start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取 cpu 的使用权</li><li>3.运行（running）：可运行状态的线程获得了 CPU 时间片（timeslice），执行程序代码</li><li>4.阻塞（block）：阻塞状态是指线程因为某种原因放弃了 CPU 使用权，暂时停止运行。直到线程进入可运行( runnable )状态，才有 机会再次获得 cpu timeslice 转到运行( running )状态。阻塞的情况分三种：<ul><li>(一). 等待阻塞：运行( running )的线程执行 o . wait ()方法， JVM 会把该线程放 入等待队列( waitting queue )中</li><li>(二). 同步阻塞：运行( running )的线程在获取对象的同步锁时，若该同步锁 被别的线程占用，则 JVM 会把该线程放入锁池( lock pool )中</li><li>(三). 其他阻塞: 运行( running )的线程执行 Thread . sleep ( long ms )或 t . join ()方法，或者发出了 I / O 请求时， JVM 会把该线程置为阻塞状态。当 sleep ()状态超时、 join ()等待线程终止或者超时、或者 I / O 处理完毕时，线程重新转入可运行( runnable )状态</li></ul></li><li>5.死亡（dead）：线程 run ()、 main () 方法执行结束，或者因异常退出了 run ()方法，则该线程结束生命周期。死亡的线程不可再次复生<br><img src="http://uploadfiles.nowcoder.com/images/20151217/149974_1450349079825_4697A22AC611680A692472687DEC1CFD" alt="Thread state"></li></ul><ol start="14"><li>同步方法和同步代码块的区别？</li></ol><ul><li>同步方法默认用 this 或者当前类 class 对象作为锁</li><li>同步代码块可以选择以什么来加锁，比同步方法要更细颗粒度，我们可以选择只同步会发生同步问题的部分代码而不是整个方法</li></ul><ol start="15"><li>在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？</li></ol><ul><li>监视器和锁是在 Java 虚拟机中一块使用的</li><li>监视器监视一块同步代码块，确保只有一次只有一个线程执行同步代码块</li><li>每一个监视器都和一个对象引用关联</li><li>线程在获取锁之前不允许执行同步代码块</li></ul><ol start="16"><li>什么是死锁（deadlock）？</li></ol><ul><li>两个或者两个以上的线程都在等待对方执行完毕才能继续往下执行的时候就发生了死锁，结果是这些线程都陷入了无线的等待</li></ul><ol start="17"><li>如何确保 N 个线程可以访问 N 个资源同时又不导致死锁？</li></ol><ul><li>使用多线程的时候，简单避免死锁的方式就是：指定获取锁的顺序，并强制线程按照规定的熟悉怒获取锁；如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了</li><li>多线程产生死锁需要四个条件，分别是<strong>互斥性，保持和请求，不可剥夺性还有要形成闭环</strong>，这四个条件缺一不可，只要破坏了其中一个条件就可以破坏死锁，其中最简单的方法就是线程都是以同样的顺序加锁和释放锁，也就是破坏了第四个条件<ul><li>1.互斥条件：一个资源每次只能被一个进程使用</li><li>2.保持和请求条件：一个进程因请求资源而阻塞时，对已获得资源保持不放</li><li>3.不可剥夺调教：进程已获得资源，在未使用完成前，不能被剥夺</li><li>4.循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系</li></ul></li></ul><ol start="18"><li>Java 集合类框架的基本接口有哪些？</li></ol><ul><li>集合类中指定了一组叫做元素的对象，集合类接口中的每一种具体实现类都可以选择以它的方式对元素进行保存和排序，有的集合类允许重复的键，有些不允许</li><li>Java 集合类提供了一套设计良好的支持对一组对象进行操作的接口和类。Java 集合类里面最基本的接口有：</li><li>Collection：代表一组对象，每一个对象都是它的子元素<ul><li>List：有顺序的 Collection，可以包含重复元素<ul><li>ArrayList：类似一个长度可变的数组 。适合查询，不适合增删</li><li>LinkedList：底层是双向循环链表。适合增删，不适合查询</li></ul></li><li>Set：不包含重复元素的 Collection<ul><li>HashSet：根据对象的哈希值确定元素在集合中的位置</li><li>TreeSet: 以二叉树的方式存储元素，实现了对集合中的元素排序</li></ul></li></ul></li><li>Map：可以把键 key 映射到值 value 得对象，键不允许重复<ul><li>HashMap：用于存储键值映射关系，不能出现重复的键 key</li><li>TreeMap：用来存储键值映射关系，不能出现重复的键 key，所有的键按照二叉树的方式排列</li></ul></li></ul><ol start="19"><li>为什么集合类没有实现 Cloneable 和 Serializable 接口？</li></ol><ul><li>克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的。因此，应该由集合类的具体实现来决定如何被克隆或者是序列化</li></ul><ol start="20"><li>什么是迭代器(Iterator)？</li></ol><ul><li>Iterator 接口提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代器实例的迭代方法。迭代器可以在迭代的过程中删除底层集合的元素,但是不可以直接调用集合的 remove(Object Obj)删除，可以通过迭代器的 remove()方法删除</li></ul><ol start="21"><li>Iterator 和 ListIterator 的区别是什么？</li></ol><ul><li>Iterator 可以遍历 List 和 Set / ListIterator 只能遍历 List</li><li>Iterator 对集合只能是前向遍历 / ListIterator 既可以前向也可以后向</li><li>ListIterator 实现了 Iterator 接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引等等</li></ul><ol start="22"><li>快速失败（fail-fast）和安全失败（fail-safe）区别</li></ol><ul><li>Iterator 的安全失败是基于对底层集合进行拷贝，所以不受源集合上修改的影响</li><li>java.util 包下面的所有集合类都是快速失败</li><li>java.util.concurrent 包下面的所有的类都是安全失败的</li><li>快速失败的迭代器会抛出 ConcurrentModificationException 异常，而安全失败的迭代器永远不会抛出这样的异常</li></ul><ol start="23"><li>Java 中的 HashMap 的工作原理是什么？</li></ol><ul><li>Java 中 HashMap 是以键值对（key-value）的形式存储元素</li><li>HashMap 需要一个 hash 函数，它使用 hashCode()和 equals()方法来向集合添加元素/从集合中检索元素</li><li>当调用 put()方法的时候，HashMap 会计算 key 的 hash 值，然后把键值对存储在集合中合适的索引上。如果 key 已经存在了，value 会被更新成新值</li><li>HashMap 的一些重要的特性是它的容量(capacity)，负载因子(load factor)和扩容极限(threshold resizing)</li></ul><ol start="24"><li>hashCode()和 equals()方法的重要性体现在什么地方？</li></ol><ul><li>Java 中的 HashMap 使用 hashCode()和 equals()方法来确定键值对的索引，当根据键获取值的时候也会用到这两个方法</li><li>如果没有正确的实现这两个方法，两个不同的键可能会有相同的 hash 值，因此，可能会被集合认为是相等的</li><li>这两个方法也用来发现重复元素。所以这两个方法的实现对 HashMap 的精确性和正确性是至关重要的</li></ul><ol start="25"><li>HashMap 和 Hashtable 有什么区别？</li></ol><ul><li>HashMap 和 Hashtable 都实现了 Map 的接口，因此很多特性非常相似。他们不同之处在于：</li><li>HashMap 运行键和值是 null，而 Hashtable 不允许键值为 null</li><li>Hashtable 是同步的，而 HashMap 不是；所以 HashMap 更适合单线程环境，Hashtable 更适合多线程环境</li><li>HashMap 提供了可以供应用迭代的键的集合，因此 HashMap 是快速失败的；另一方，Hashtable 提供了对键的列举(Enumeration)。一般认为 Hashtable 是一个遗留的类</li></ul><ol start="26"><li>数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用 Array 而不是 ArrayList？</li></ol><ul><li>Array 可以包含基本类型和对象类型 / ArrayList 只能包含对象类型</li><li>Array 的大小是固定的 / ArrayList 的大小是动态变化的</li><li>ArrayList 提供更多的方法和特性，例如：addAll(),removeAll(),iterator()</li><li>对于基本数据类型，集合使用自动装箱来减少编码工作量；但是当处理固定大小固定大小的基本数据类型的时候，这种方式相对比较慢</li></ul><ol start="27"><li>ArrayList 和 LinkedList 有什么区别？</li></ol><ul><li>ArrayList 和 LinkedList 都实现了 List 接口，不同之处在于：</li><li>ArrayList 是基于索引的数据接口，它的底层是数组，它可以以 O(1)时间复杂度对元素进行随机访问 / 与此对应，LinkedList 是以元素列表的形式存储它的数据，每一个元素都和它的前一个元素和后一个元素链接在一起，查找某个元素的时间复杂度是 O(N)</li><li>相对于 ArrayList，LinkedList 的插入，添加，删除操作速度更快，因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引</li><li>LinkedList 比 ArrayList 更占内存，因为 LinkedList 为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素</li></ul><ol start="28"><li>Comparable 和 Comparator 接口是干什么的？列出它们的区别</li></ol><ul><li>Java 提供了只包含一个 compareTo()方法的 Comparable 接口。这个方法可以个给两个对象排序。具体来说，它返回负数，0，正数来表明输入对象小于，等于，大于已经存在的对象</li><li>Java 提供了包含 compare()和 equals()两个方法的 Comparator 接口。compare()方法用来给两个输入参数排序，返回负数，0，正数表明第一个参数是小于，等于，大于第二个参数。equals()方法需要一个对象作为参数，它用来决定输入参数是否和 comparator 相等。只有当输入参数也是一个 comparator 并且输入参数和当前 comparator 的排序结果是相同的时候，这个方法才返回 true</li></ul><ol start="29"><li>什么是 Java 优先级队列(Priority Queue)？</li></ol><ul><li>Priority Queue 一个基于优先级堆得无线队列，它的元素是按照自然顺序排序的</li><li>在创建的时候，我们可以给它提供一个负责给元素排序的比较器</li><li>PriorityQueue 不允许 null 值，因为他们没有自然顺序，或者说他们没有任何的相关联的比较器</li><li>PriorityQueue 不是线程安全的，入队和出队的时间复杂度是 O(log(n))</li></ul><ol start="30"><li>你了解大 O 符号(big-O notation)么？你能给出不同数据结构的例子么？</li></ol><ul><li>大 O 符号描述了当数据结构里面的元素增加的时候，算法的规模或者是性能在最坏的场景下有多么好。</li><li>大 O 符号也可用来描述其他的行为，比如：内存消耗。因为集合类实际上是数据结构，我们一般使用大 O 符号基于时间，内存和性能来选择最好的实现。大 O 符号可以对大量数据的性能给出一个很好的说明</li></ul><ol><li><p>如何权衡是使用无序的数组还是有序的数组？</p><ul><li>有序数组最大的好处在于查找的时间复杂度是 O(log n)，而无序数组是 O(n)。有序数组的缺点是插入操作的时间复杂度是 O(n)，因为值大的元素需要往后移动来给新元素腾位置。相反，无序数组的插入时间复杂度是常量 O(1)</li></ul></li><li><p>Java 集合类框架的最佳实践</p><ul><li>根据应用的需要正确选择要使用的集合的类型对性能非常重要，比如：假如元素的大小是固定的，而且能事先知道，我们就应该用 Array 而不是 ArrayList</li><li>有些集合类允许指定初始容量。因此，如果我们能估计出存储的元素的数目，我们可以设置初始容量来避免重新计算 hash 值或者是扩容</li><li>为了类型安全，可读性和健壮性的原因总是要使用泛型。同时，使用泛型还可以避免运行时的 ClassCastException</li><li>使用 JDK 提供的不变类(immutable class)作为 Map 的键可以避免为我们自己的类实现 hashCode()和 equals()方法</li><li>编程的时候接口优于实现</li><li>底层的集合实际上是空的情况下，返回长度是 0 的集合或者是数组，不要返回 null</li></ul></li><li><p>Enumeration 接口和 Iterator 接口的区别</p><ul><li>Enumeration 速度是 Iterator 的 2 倍，同时占用更少的内存</li><li>但是，Iterator 远远比 Enumeration 安全，因为其他线程不能够修改正在被 iterator 遍历的集合里面的对象</li><li>同时，Iterator 允许调用者删除底层集合里面的元素，这对 Enumeration 来说是不可能的</li></ul></li><li><p>HashSet 和 TreeSet 有区别</p><ul><li>HashSet 是由一个 hash 表来实现的，因此，它的元素是无序的。add()，remove()，contains()方法的时间复杂度是 O(1)</li><li>TreeSet 是由一个树形的结构来实现的，它里面的元素是有序的。因此，add()，remove()，contains()方法的时间复杂度是 O(logn)</li></ul></li><li><p>Java 垃圾回收目的</p><ul><li>垃圾回收的目的是识别并且丢弃应用不再使用的对象来释放和重用资源</li></ul></li><li><p>System.gc()和 Runtime.gc()会做什么事情</p><ul><li>用来提示 JVM 要进行垃圾回收。但是，立即开始还是延迟进行垃圾回收是取决于 JVM 的</li></ul></li><li><p>finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？</p><ul><li>垃圾回收器(garbage colector)决定回收某对象时，就会运行该对象的 finalize()方法 但是在 Java 中很不幸，如果内存总是充足的，那么垃圾回收可能永远不会进行，也就是说 filalize()可能永远不被执行，显然指望它做收尾工作是靠不住的，它最主要的用途是回收特殊渠道申请的内存。</li><li>析构 finalization，比如你在调用了一些 native 的方法，可以要在 finaliztion 里去调用释放函数</li></ul></li><li><p>如果对象的引用被置为 null，垃圾收集器是否会立即释放对象占用的内存？</p><ul><li>不会，在下一个垃圾回收周期中，这个对象将是可被回收的</li></ul></li><li><p>Java 堆的结构是什么样子的？什么是堆中的永久代(Perm Gen space)?</p><ul><li>JVM 的堆是运行时数据区，所有类的实例和数组都是在堆上分配内存。它在 JVM 启动的时候被创建。对象所占的堆内存是由自动内存管理系统也就是垃圾收集器回收</li><li>堆内存是由存活和死亡的对象组成的。存活的对象是应用可以访问的，不会被垃圾回收。死亡的对象是应用不可访问尚且还没有被垃圾收集器回收掉的对象。一直到垃圾收集器把这些对象回收掉之前，他们会一直占据堆内存空间</li></ul></li><li><p>串行(serial)收集器和吞吐量(throughput)收集器的区别</p><ul><li>串行收集器对大多数的小应用(在现代处理器上需要大概 100M 左右的内存)就足够了</li><li>吞吐量收集器使用并行版本的新生代垃圾收集器，它用于中等规模和大规模数据的应用程序</li></ul></li><li><p>在 Java 中，对象什么时候可以被垃圾回收</p><ul><li>当没有任何对象的引用指向对象时在一个不可预期的时间内对象才会被回收(对于那些循环应用的时候，也要被回收)</li><li>当对象对当前使用这个对象的应用程序变得不可触及的时候，这个对象就可以被回收了</li></ul></li><li><p>JVM 的永久代中会发生垃圾回收么？</p><ul><li>垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)</li><li>如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的</li></ul></li><li><p>Java 中的两种异常类型是什么？他们有什么区别？</p><ul><li>Java 中有两种异常：受检查的(checked)异常和不受检查的(unchecked)异常</li><li>不受检查的异常不需要在方法或者是构造函数上声明，就算方法或者是构造函数的执行可能会抛出这样的异常，并且不受检查的异常可以传播到方法或者是构造函数的外面</li><li>受检查的异常必须要用 throws 语句在方法或者是构造函数上声明</li></ul></li><li><p>Java 中 Exception 和 Error 有什么区别？</p><ul><li>Exception 和 Error 都是 Throwable 的子类</li><li>Exception 用于用户程序可以捕获的异常情况</li><li>Error 定义了不期望被用户程序捕获的异常</li></ul></li><li><p>throw 和 throws 有什么区别？</p><ul><li>throw 关键字用来在程序中明确的抛出异常，相反，throws 语句用来表明方法不能处理的异常</li><li>Throw 用于方法内部，Throws 用于方法声明上;Throw 后跟异常对象，Throws 后跟异常类型;Throw 后只能跟一个异常对象，Throws 后可以一次声明多种异常类型</li><li>每一个方法都必须要指定哪些异常不能处理，所以方法的调用者才能够确保处理可能发生的异常，多个异常是用逗号分隔的(语法：修饰符 返回值类型 方法名 参数类型 throws 异常类<br>public void test throws Exception1,Exception2(){})</li></ul></li><li><p>异常处理完成以后，Exception 对象会发生什么变化？</p><ul><li>Exception 对象会在下一个垃圾回收过程中被回收掉</li></ul></li><li><p>finally 代码块和 finalize()方法有什么区别？</p><ul><li>无论 try catch 语句块中的代码块是否抛出异常，finally 代码块都会执行，它主要是用来释放应用占用的资源</li><li>finalize()方法是 Object 类的一个 protected 方法，它是在对象被垃圾回收之前由 Java 虚拟机来调用的</li></ul></li><li><p>什么是 Applet？</p><ul><li>java applet 是能够被包含在 HTML 页面中并且能被启用了 java 的客户端浏览器执行的程序。Applet 主要用来创建动态交互的 web 应用程序</li></ul></li><li><p>Applet 的生命周期:</p><ul><li>Init：每次被载入的时候都会被初始化</li><li>Start：开始执行 applet</li><li>Stop：结束执行 applet</li><li>Destroy：卸载 applet 之前，做最后的清理工作</li></ul></li><li><p>当 applet 被载入的时候会发生什么？</p><ul><li>首先创建 applet 控制类的实例;然后初始化 applet;最后开始运行</li></ul></li><li><p>Applet 和普通的 Java 应用程序有什么区别？</p><ul><li>applet 是运行在启用了 java 的浏览器中，Java 应用程序是可以在浏览器之外运行的独立的 Java 程序</li><li>Java 应用程序需要一个有特定方法签名的 main 函数来开始执行。Java applet 不需要这样的函数来开始执行</li><li>Java applet 一般会使用很严格的安全策略，Java 应用一般使用比较宽松的安全策略</li></ul></li><li><p>Java applet 有哪些限制条件？</p><ul><li>applet 不能够载入类库或者定义本地方法</li><li>applet 不能在宿主机上读写文件</li><li>applet 不能读取特定的系统属性</li><li>applet 不能发起网络连接，除非是跟宿主机</li><li>applet 不能够开启宿主机上其他任何的程序</li></ul></li><li><p>什么是不受信任的 applet？</p><ul><li>不受信任的 applet 是不能访问或是执行本地系统文件的 Java applet，默认情况下，所有下载的 applet 都是不受信任的</li></ul></li><li><p>从网络上加载的 applet 和从本地文件系统加载的 applet 有什么区别？</p><ul><li>当 applet 是从网络上加载的时候，applet 是由 applet 类加载器载入的，它受 applet 安全管理器的限制</li><li>当 applet 是从客户端的本地磁盘载入的时候，applet 是由文件系统加载器载入的</li><li>从文件系统载入的 applet 允许在客户端读文件，写文件，加载类库，并且也允许执行其他程序，但是，却通不过字节码校验</li></ul></li><li><p>applet 类加载器是什么？它会做哪些工作？</p><ul><li>当 applet 是从网络上加载的时候，它是由 applet 类加载器载入的。类加载器有自己的 java 名称空间等级结构。类加载器会保证来自文件系统的类有唯一的名称空间，来自网络资源的类有唯一的名称空间</li><li>当浏览器通过网络载入 applet 的时候，applet 的类被放置于和 applet 的源相关联的私有的名称空间中。然后，那些被类加载器载入进来的类都是通过了验证器验证的。验证器会检查类文件格式是否遵守 Java 语言规范，确保不会出现堆栈溢出(stack overflow)或者下溢(underflow)，传递给字节码指令的参数是正确的</li></ul></li><li><p>applet 安全管理器是什么？它会做哪些工作？</p><ul><li>applet 安全管理器是给 applet 施加限制条件的一种机制。浏览器可以只有一个安全管理器。安全管理器在启动的时候被创建，之后不能被替换覆盖或者是扩展</li></ul></li><li><p>弹出式选择菜单(Choice)和列表(List)有什么区别</p><ul><li>Choice 是以一种紧凑的形式展示的，需要下拉才能看到所有的选项。Choice 中一次只能选中一个选项</li><li>List 同时可以有多个元素可见，支持选中一个或者多个元素</li></ul></li><li><p>布局管理器</p><ul><li>布局管理器用来在容器中组织组件</li></ul></li><li><p>滚动条(Scrollbar)和滚动面板(JScrollPane)区别</p><ul><li>Scrollbar 是一个组件，不是容器。而 JScrollPane 是容器。JScrollPane 自己处理滚动事件</li><li>在设置界面时，可能会遇到在一个较小的容器窗体中显示一个较大部分的内容，这时可以使用 JScrollPane 面板，JscrollPane 面板是带滚动条的面板，也是一种容器，但是常用于布置单个控件，并且不可以使用布局管理器。如果需要在 JScrollPane 面板中放置多个控件，需要将多个控件放置到 JPanel 面板上，然后将 JPanel 面板作为一个整体控件添加到 JScrollPane 控件上</li></ul></li><li><p>哪些 Swing 的方法是线程安全的？</p><ul><li>只有 3 个线程安全的方法： repaint(), revalidate(), and invalidate()</li></ul></li><li><p>支持重绘(painting)的组件</p><ul><li>Canvas, Frame, Panel,和 Applet 支持重绘</li></ul></li><li><p>什么是裁剪(clipping)？</p><ul><li>限制在一个给定的区域或者形状的绘图操作就做裁剪</li></ul></li><li><p>MenuItem 和 CheckboxMenuItem 的区别是什么？</p><ul><li>CheckboxMenuItem 类继承自 MenuItem 类，支持菜单选项可以选中或者不选中</li></ul></li><li><p>边缘布局(BorderLayout)里面的元素是如何布局的？</p><ul><li>BorderLayout 里面的元素是按照容器的东西南北中进行布局的</li></ul></li><li><p>网格包布局(GridBagLayout)里面的元素是如何布局的？</p><ul><li>GridBagLayout 里面的元素是按照网格进行布局的。不同大小的元素可能会占据网格的多于 1 行或一列。因此，行数和列数可以有不同的大小</li></ul></li><li><p>Windows 和 Frame 区别</p><ul><li>Frame 类继承了 Window 类，它定义了一个可以有菜单栏的主应用窗口</li></ul></li><li><p>裁剪(clipping)和重绘(repainting)有什么联系？</p><ul><li>当窗口被 AWT 重绘线程重绘的时候，它会把裁剪区域设置成重绘的窗口区域</li></ul></li><li><p>事件监听器接口(event-listener interface)和事件适配器(event-adapter)的关系</p><ul><li>事件监听器接口定义了对特定的事件，事件处理器必须要实现的方法</li><li>事件适配器给事件监听器接口提供了默认的实现（适配器是一种设计模式，就是我写一个抽象方法，实现接口所有方法，但是都没有语句，你要实现哪个方法，就重写哪个方法）</li></ul></li><li><p>GUI 组件如何来处理它自己的事件？</p><ul><li>GUI 组件可以处理它自己的事件，只要它实现相对应的事件监听器接口，并且把自己作为事件监听器</li></ul></li><li><p>Java 的布局管理器比传统的窗口系统有哪些优势？</p><ul><li>Java 使用布局管理器以一种一致的方式在所有的窗口平台上摆放组件。</li><li>因为布局管理器不会和组件的绝对大小和位置相绑定，所以他们能够适应跨窗口系统的特定平台的不同</li></ul></li><li><p>Java 的 Swing 组件的种设计模式</p><ul><li>Java 中的 Swing 组件使用了 MVC(视图-模型-控制器)设计模式</li></ul></li><li><p>JDBC 是允许用户在不同数据库之间做选择的一个抽象层。JDBC 允许开发者用 JAVA 写数据库应用程序，而不需要关心底层特定数据库的细节</p></li><li><p>驱动(Driver)在 JDBC 中的角色</p><ul><li>JDBC 驱动提供了特定厂商对 JDBC API 接口类的实现</li><li>驱动必须要提供 java.sql 包下面这些类的实现：Connection, Statement, PreparedStatement,CallableStatement, ResultSet 和 Driver</li></ul></li><li><p>Class.forName()方法作用</p><ul><li>初始化参数指定的类，并且返回此类对应的 Class 对象</li><li>在初始化一个类，生成一个实例的时候，newInstance()方法使用类加载机制，new 关键字是创建一个新类；从 JVM 的角度看，我们使用关键字 new 创建一个类的时候，这个类可以没有被加载。但是使用 newInstance()方法的时候就要求： 1、这个类已经加载； 2、这个类已经连接了；完成上面两个步骤的正是 Class 的静态方法 forName()所完成的，这个静态方法调用了启动类加载器，即加载 java API 的那个加载器</li></ul></li><li><p>PreparedStatement 比 Statement 有什么优势？</p><ul><li>PreparedStatements 是预编译的，PreparedStatements 实例包涵已编译的 sql 语句，所以其执行速度要快于 statement 对象，性能会更好</li><li>PreparedStatements 作为 statement 的子类，继承了 statement 的所有方法，三种方法，excute,excuteQuery 和 excuteUpdate 已被更改以使之不再需要参数</li><li>PreparedStatements 的代码可读性，可维护性强于 statement.</li><li>极大的提高了安全性</li></ul></li><li><p>什么时候使用 CallableStatement？用来准备 CallableStatement 的方法是什么？</p><ul><li>CallableStatement 用来执行存储过程。存储过程是由数据库存储和提供的，它还提供了安全性和模块化</li><li>存储过程可以接受输入参数，也可以有返回结果</li><li>准备一个 CallableStatement 的方法是：CallableStament.prepareCall();</li></ul></li><li><p>RMI:Java 远程方法调用(Java RMI)是 Java API 对远程过程调用(RPC)提供的面向对象的等价形式，支持直接传输序列化的 Java 对象和分布式垃圾回收。远程方法调用可以看做是激活远程正在运行的对象上的方法的步骤。RMI 对调用者是位置透明的，因为调用者感觉方法是执行在本地运行的对象上的。看下 RMI 的一些注意事项</p></li><li><p>RMI 体系结构的基本原则</p><ul><li>RMI 体系结构是基于一个非常重要的行为定义和行为实现相分离的原则。RMI 允许定义行为的代码和实现行为的代码相分离，并且运行在不同的 JVM 上</li></ul></li><li><p>RMI 体系结构分层</p><ul><li>存根和骨架层(Stub and Skeleton layer)：这一层对程序员是透明的，它主要负责拦截客户端发出的方法调用请求，然后把请求重定向给远程的 RMI 服务</li><li>远程引用层(Remote Reference Layer)：RMI 体系结构的第二层用来解析客户端对服务端远程对象的引用。这一层解析并管理客户端对服务端远程对象的引用。连接是点到点的</li><li>传输层(Transport layer)：这一层负责连接参与服务的两个 JVM。这一层是建立在网络上机器间的 TCP/IP 连接之上的。它提供了基本的连接服务，还有一些防火墙穿透策略</li></ul></li><li><p>RMI 中的远程接口(Remote Interface)扮演了什么样的角色？</p><ul><li>远程接口用来标识哪些方法是可以被非本地虚拟机调用的接口。远程对象必须要直接或者是间接实现远程接口。实现了远程接口的类应该声明被实现的远程接口，给每一个远程对象定义构造函数，给所有远程接口的方法提供实现</li></ul></li><li><p>RMI 中的远程接口(Remote Interface)扮演了什么样的角色？</p><ul><li>远程接口用来标识哪些方法是可以被非本地虚拟机调用的接口。远程对象必须要直接或者是间接实现远程接口。实现了远程接口的类应该声明被实现的远程接口，给每一个远程对象定义构造函数，给所有远程接口的方法提供实现。</li></ul></li><li><p>java.rmi.Naming 类扮演了什么样的角色？</p><ul><li>java.rmi.Naming 类用来存储和获取在远程对象注册表里面的远程对象的引用。Naming 类的每一个方法接收一个 URL 格式的 String 对象作为它的参数</li></ul></li><li><p>RMI 的绑定(Binding)</p><ul><li>绑定是为了查询找远程对象而给远程对象关联或者是注册以后会用到的名称的过程。远程对象可以使用 Naming 类的 bind()或者 rebind()方法跟名称相关联</li></ul></li><li><p>Naming 类的 bind()和 rebind()方法有什么区别？</p><ul><li>bind()方法负责把指定名称绑定给远程对象，rebind()方法负责把指定名称重新绑定到一个新的远程对象。如果那个名称已经绑定过了，先前的绑定会被替换掉</li></ul></li><li><p>让 RMI 程序能正确运行有哪些步骤？</p><ul><li>编译所有的源文件</li><li>使用 rmic 生成 stub</li><li>启动 rmiregistry</li><li>启动 RMI 服务器</li><li>运行客户端程序</li></ul></li><li><p>RMI 的 stub 扮演了什么样的角色？</p><ul><li>远程对象的 stub 扮演了远程对象的代表或者代理的角色。调用者在本地 stub 上调用方法，它负责在远程对象上执行方法。当 stub 的方法被调用的时候，会经历以下几个步骤：</li><li>初始化到包含了远程对象的 JVM 的连接</li><li>序列化参数到远程的 JVM</li><li>等待方法调用和执行的结果</li><li>反序列化返回的值或者是方法没有执行成功情况下的异常</li><li>把值返回给调用者</li></ul></li><li><p>什么是分布式垃圾回收(DGC)？它是如何工作的？</p><ul><li>DGC 叫做分布式垃圾回收。RMI 使用 DGC 来做自动垃圾回收。因为 RMI 包含了跨虚拟机的远程对象的引用，垃圾回收是很困难的。DGC 使用引用计数算法来给远程对象提供自动内存管理</li></ul></li><li><p>RMI 中使用 RMI 安全管理器(RMISecurityManager)的目的是什么？</p><ul><li>RMISecurityManager 使用下载好的代码提供可被 RMI 应用程序使用的安全管理器。如果没有设置安全管理器，RMI 的类加载器就不会从远程下载任何的类。</li></ul></li><li><p>解释下 Marshalling 和 demarshalling</p><ul><li>当应用程序希望把内存对象跨网络传递到另一台主机或者是持久化到存储的时候，就必须要把对象在内存里面的表示转化成合适的格式。这个过程就叫做 Marshalling，反之就是 demarshalling</li></ul></li><li><p>解释下 Serialization 和 Deserialization</p><ul><li><p>Java 提供了一种叫做对象序列化的机制，他把对象表示成一连串的字节，里面包含了对象的数据，对象的类型信息，对象内部的数据的类型信息等等</p></li><li><p>序列化可以看成是为了把对象存储在磁盘上或者是从磁盘上读出来并重建对象而把对象扁平化的一种方式。反序列化是把对象从扁平状态转化成活动对象的相反的步骤</p></li><li><p>Servlet 是用来处理客户端请求并产生动态网页内容的 Java 类。</p></li><li><p>Servlet 主要是用来处理或者是存储 HTML 表单提交的数据，产生动态内容，在无状态的 HTTP 协议下管理状态信息</p></li></ul></li><li><p>Servlet 的体系结构</p><ul><li>所有的 Servlet 都必须要实现的核心的接口是 javax.servlet.Servlet</li><li>每一个 Servlet 都必须要直接或者是间接实现这个接口，或者是继承 javax.servlet.GenericServlet 或者 javax.servlet.http.HTTPServlet</li><li>最后，Servlet 使用多线程可以并行的为多个请求服务</li></ul></li><li><p>Applet 和 Servlet 有什么区别？</p><ul><li>Applet 是运行在客户端主机的浏览器上的客户端 Java 程序。而 Servlet 是运行在 web 服务器上的服务端的组件</li><li>applet 可以使用用户界面类，而 Servlet 没有用户界面，相反，Servlet 是等待客户端的 HTTP 请求，然后为请求产生响应</li></ul></li><li><p>GenericServlet 和 HttpServlet 区别</p><ul><li>GenericServlet 是一个通用的协议无关的 Servlet，它实现了 Servlet 和 ServletConfig 接口。继承自 GenericServlet 的 Servlet 应该要覆盖 service()方法</li><li>若要开发一个能用在网页上服务于使用 HTTP 协议请求的 Servlet，你的 Servlet 必须要继承自 HttpServlet</li></ul></li><li><p>Servlet 的生命周期</p><ul><li>1）对每一个客户端的请求，Servlet 引擎载入 Servlet，调用它的 init()方法，完成 Servlet 的初始化</li><li>2）Servlet 对象通过为每一个请求单独调用 service()方法来处理所有随后来自客户端的请求</li><li>3）最后，调用 Servlet 的 destroy()方法把 Servlet 删除掉</li></ul></li><li><p>doGet()方法和 doPost()方法区别</p><ul><li>doGet：GET 方法会把名值对追加在请求的 URL 后面。因为 URL 对字符数目有限制，进而限制了用在客户端请求的参数值的数目。并且请求中的参数值是可见的，因此，敏感信息不能用这种方式传递</li><li>doPOST：POST 方法通过把请求参数值放在请求体中来克服 GET 方法的限制，因此，可以发送的参数的数目是没有限制的。最后，通过 POST 请求传递的敏感信息对外部客户端是不可见的</li></ul></li><li><p>Web 应用程序</p><ul><li>Web 应用程序是对 Web 或者是应用服务器的动态扩展</li><li>有两种类型的 Web 应用：面向表现的和面向服务的。面向表现的 Web 应用程序会产生包含了很多种标记语言和动态内容的交互的 web 页面作为对请求的响应。而面向服务的 Web 应用实现了 Web 服务的端点(endpoint)</li></ul></li><li><p>什么是服务端包含(Server Side Include)？</p><ul><li>服务端包含(SSI)是一种简单的解释型服务端脚本语言，大多数时候仅用在 Web 上，用 servlet 标签嵌入进来</li><li>SSI 最常用的场景把一个或多个文件包含到 Web 服务器的一个 Web 页面中。当浏览器访问 Web 页面的时候，Web 服务器会用对应的 servlet 产生的文本来替换 Web 页面中的 servlet 标签</li></ul></li><li><p>Servlet 链(Servlet Chaining)</p><ul><li>Servlet 链是把一个 Servlet 的输出发送给另一个 Servlet 的方法。第二个 Servlet 的输出可以发送给第三个 Servlet，依次类推。链条上最后一个 Servlet 负责把响应发送给客户端</li></ul></li><li><p>如何知道是哪一个客户端的机器正在请求你的 Servlet？</p><ul><li>ServletRequest 类可以找出客户端机器的 IP 地址或者是主机名</li><li>etRemoteAddr()方法获取客户端主机的 IP 地址，getRemoteHost()可以获取主机名</li></ul></li><li><p>HTTP 响应的结构是怎么样的？</p><ul><li>状态码(Status Code)：描述了响应的状态。可以用来检查是否成功的完成了请求。请求失败的情况下，状态码可用来找出失败的原因。如果 Servlet 没有返回状态码，默认会返回成功的状态码 HttpServletResponse.SC_OK</li><li>HTTP 头部(HTTP Header)：它们包含了更多关于响应的信息。比如：头部可以指定认为响应过期的过期日期，或者是指定用来给用户安全的传输实体内容的编码格式</li><li>主体(Body)：它包含了响应的内容。它可以包含 HTML 代码，图片，等等。主体是由传输在 HTTP 消息中紧跟在头部后面的数据字节组成的</li></ul></li><li><p>什么是 cookie？session 和 cookie 有什么区别？</p><ul><li>cookie 是 Web 服务器发送给浏览器的一块信息。浏览器会在本地文件中给每一个 Web 服务器存储 cookie。以后浏览器在给特定的 Web 服务器发请求的时候，同时会发送所有为该服务器存储的 cookie</li><li>无论客户端浏览器做怎么样的设置，session 都应该能正常工作。客户端可以选择禁用 cookie，但是，session 仍然是能够工作的，因为客户端无法禁用服务端的 session</li><li>在存储的数据量方面 session 和 cookies 也是不一样的。session 能够存储任意的 Java 对象，cookie 只能存储 String 类型的对象</li></ul></li><li><p>浏览器和 Servlet 通信使用的是 HTTP 协议</p></li><li><p>HTTP 隧道:HTTP 隧道是一种利用 HTTP 或者是 HTTPS 把多种网络协议封装起来进行通信的技术。因此，HTTP 协议扮演了一个打通用于通信的网络协议的管道的包装器的角色。把其他协议的请求掩盖成 HTTP 的请求就是 HTTP 隧道</p></li><li><p>sendRedirect()和 forward()方法有什么区别？</p><ul><li>sendRedirect()方法会创建一个新的请求，而 forward()方法只是把请求转发到一个新的目标上</li><li>重定向(redirect)以后，之前请求作用域范围以内的对象就失效了，因为会产生一个新的请求，而转发(forwarding)以后，之前请求作用域范围以内的对象还是能访问的</li><li>一般认为 sendRedirect()比 forward()要慢</li></ul></li><li><p>什么是 URL 编码和 URL 解码？</p><ul><li>URL 编码是负责把 URL 里面的空格和其他的特殊字符替换成对应的十六进制表示，反之就是解码</li></ul></li><li><p>什么是 JSP 页面？</p><ul><li>JSP 页面是一种包含了静态数据和 JSP 元素两种类型的文本的文本文档</li><li>静态数据可以用任何基于文本的格式来表示，比如：HTML 或者 XML</li><li>JSP 是一种混合了静态内容和动态产生的内容的技术</li></ul></li><li><p>JSP 请求是如何被处理的？</p><ul><li>浏览器首先要请求一个以.jsp 扩展名结尾的页面，发起 JSP 请求，然后，Web 服务器读取这个请求，使用 JSP 编译器把 JSP 页面转化成一个 Servlet 类。</li><li>需要注意的是，只有当第一次请求页面或者是 JSP 文件发生改变的时候 JSP 文件才会被编译，然后服务器调用 servlet 类，处理浏览器的请求。一旦请求执行结束，servlet 会把响应发送给客户端</li></ul></li><li><p>JSP 优点</p><ul><li>JSP 页面是被动态编译成 Servlet 的，因此，开发者可以很容易的更新展现代码</li><li>JSP 页面可以被预编译</li><li>JSP 页面可以很容易的和静态模板结合，包括：HTML 或者 XML，也可以很容易的和产生动态内容的代码结合起来</li><li>开发者可以提供让页面设计者以类 XML 格式来访问的自定义的 JSP 标签库</li><li>开发者可以在组件层做逻辑上的改变，而不需要编辑单独使用了应用层逻辑的页面。</li></ul></li><li><p>什么是 JSP 指令(Directive)？JSP 中有哪些不同类型的指令？</p><ul><li>Directive 是当 JSP 页面被编译成 Servlet 的时候，JSP 引擎要处理的指令。Directive 用来设置页面级别的指令，从外部文件插入数据，指定自定义的标签库。Directive 是定义在 &lt;%@ 和 %&gt;之间的。下面列出了不同类型的 Directive：</li><li>包含指令(Include directive)：用来包含文件和合并文件内容到当前的页面。</li><li>页面指令(Page directive)：用来定义 JSP 页面中特定的属性，比如错误页面和缓冲区。</li><li>Taglib 指令： 用来声明页面中使用的自定义的标签库。</li></ul></li><li><p>JSP 动作(JSP action)</p><ul><li>JSP 动作以 XML 语法的结构来控制 Servlet 引擎的行为。当 JSP 页面被请求的时候，JSP 动作会被执行。它们可以被动态的插入到文件中，重用 JavaBean 组件，转发用户到其他的页面，或者是给 Java 插件产生 HTML 代码。下面列出了可用的动作：</li><li>jsp:include-当 JSP 页面被请求的时候包含一个文件</li><li>jsp:useBean-找出或者是初始化 Javabean</li><li>jsp:setProperty-设置 JavaBean 的属性</li><li>jsp:getProperty-获取 JavaBean 的属性</li><li>jsp:forward-把请求转发到新的页面</li><li>jsp:plugin-产生特定浏览器的代码。</li></ul></li><li><p>什么是 Scriptlets？</p><ul><li>JSP 技术中，scriptlet 是嵌入在 JSP 页面中的一段 Java 代码。scriptlet 是位于标签内部的所有的东西，在标签与标签之间，用户可以添加任意有效的 scriplet</li></ul></li><li><p>声明(Decalaration)在哪里？</p><ul><li>声明跟 Java 中的变量声明很相似，它用来声明随后要被表达式或者 scriptlet 使用的变量。添加的声明必须要用开始和结束标签包起来</li></ul></li><li><p>什么是表达式(Expression)？</p><ul><li>【列表很长，可以分上、中、下发布】</li><li>JSP 表达式是 Web 服务器把脚本语言表达式的值转化成一个 String 对象，插入到返回给客户端的数据流中。表达式是在&lt;%=和%&gt;这两个标签之间定义的</li></ul></li><li><p>隐含对象是什么意思？有哪些隐含对象？</p><ul><li>JSP 隐含对象是页面中的一些 Java 对象，JSP 容器让这些 Java 对象可以为开发者所使用。开发者不用明确的声明就可以直接使用他们。JSP 隐含对象也叫做预定义变量。下面列出了 JSP 页面中的隐含对象：application、page、request、response、session、exception、out、config、pageContext</li></ul></li><li><p>面向对象软件开发的优点有哪些？</p><ul><li>代码开发模块化，更易维护和修改</li><li>代码复用</li><li>增强代码的可靠性和灵活性</li><li>增加代码的可理解性</li><li>面向对象编程有很多重要的特性，比如：封装，继承，多态和抽象</li></ul></li><li><p>封装的定义和好处有哪些？</p><ul><li>封装给对象提供了隐藏内部特性和行为的能力。对象提供一些能被其他对象访问的方法来改变它内部的数据。在 Java 当中，有 3 种修饰符：public，private 和 protected。每一种修饰符给其他的位于同一个包或者不同包下面对象赋予了不同的访问权限。下面列出了使用封装的一些好处：</li><li>通过隐藏对象的属性来保护对象内部的状态</li><li>提高了代码的可用性和可维护性，因为对象的行为可以被单独的改变或者是扩展</li><li>禁止对象之间的不良交互提高模块化</li><li>参考这个文档获取更多关于封装的细节和示例</li></ul></li><li><p>多态的定义？</p><ul><li>多态是编程语言给不同的底层数据类型做相同的接口展示的一种能力</li><li>一个多态类型上的操作可以应用到其他类型的值上面</li></ul></li><li><p>继承的定义？</p><ul><li>继承给对象提供了从基类获取字段和方法的能力。继承提供了代码的重用行，也可以在不修改类的情况下给现存的类添加新特性</li></ul></li><li><p>抽象的定义？抽象和封装的不同点？</p><ul><li>抽象是把想法从具体的实例中分离出来的步骤，因此，要根据他们的功能而不是实现细节来创建类。Java 支持创建只暴漏接口而不包含方法实现的抽象的类。这种抽象技术的主要目的是把类的行为和实现细节分离开</li><li>抽象和封装是互补的概念。一方面，抽象关注对象的行为。另一方面，封装关注对象行为的细节。一般是通过隐藏对象内部状态信息做到封装，因此，封装可以看成是用来提供抽象的一种策略</li></ul></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之学习UML类图和时序图</title>
      <link href="20160724/designpattern-uml/"/>
      <url>20160724/designpattern-uml/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="学习-UML-类图和时序图"><a href="#学习-UML-类图和时序图" class="headerlink" title="学习 UML 类图和时序图"></a>学习 UML 类图和时序图</h1><p>类图中各个类之间的关系； 能看懂类图中各个类之间的线条、箭头代表什么意思后，也就足够应对 日常的工作和交流； 同时，我们应该能将类图所表达的含义和最终的代码对应起来</p><a id="more"></a><h2 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h2><p><img src="https://blog-1251678165.cos.ap-chengdu.myqcloud.com/29rXZX.jpg"></p><ul><li>车的类图结构为&lt;&lt;abstract&gt;&gt;，表示车是一个抽象类；</li><li>它有两个继承类：小汽车和自行车；它们之间的关系为实现关系，使用带空心箭头的虚线表示；</li><li>小汽车为与 SUV 之间也是继承关系，它们之间的关系为泛化关系，使用带空心箭头的实线表示；</li><li>小汽车与发动机之间是组合关系，使用带实心箭头的实线表示；</li><li>学生与班级之间是聚合关系，使用带空心箭头的实线表示；</li><li>学生与身份证之间为关联关系，使用一根实线表示；</li><li>学生上学需要用到自行车，与自行车是一种依赖关系，使用带箭头的虚线表示；</li></ul><h2 id="类与类之间的关系"><a href="#类与类之间的关系" class="headerlink" title="类与类之间的关系"></a>类与类之间的关系</h2><h3 id="1-泛化关系-generalization"><a href="#1-泛化关系-generalization" class="headerlink" title="1.泛化关系(generalization)"></a>1.泛化关系(generalization)</h3><ul><li>类的继承结构表现在 UML 中为：泛化(generalize)与实现(realize)</li><li>继承关系为 is-a 的关系；两个对象之间如果可以用 is-a 来表示，就是继承关系：（..是..)</li><li>例如：汽车是车，狗是动物，地球是行星</li><li>泛化关系用一条带空心箭头的直接表示；如下图表示（A 继承自 B）<br><img src="https://blog-1251678165.cos.ap-chengdu.myqcloud.com/arL9Qf.jpg"></li><li>例如：汽车在现实中有实现，可用汽车定义具体的对象；汽车与 SUV 之间为泛化关系；<br><img src="https://blog-1251678165.cos.ap-chengdu.myqcloud.com/yqaZ1R.jpg"></li></ul><blockquote><ul><li>注：最终代码中，泛化关系表现为<em>继承非抽象类</em></li></ul></blockquote><h3 id="2-实现关系-realize"><a href="#2-实现关系-realize" class="headerlink" title="2.实现关系(realize)"></a>2.实现关系(realize)</h3><ul><li>实现关系用一条带空心箭头的虚线表示</li><li>例如：eg：”车”为一个抽象概念，在现实中并无法直接用来定义对象；只有指明具体的子类(汽车还是自行车)，才 可以用来定义对象（”车”这个类在 C++中用抽象类表示，在 JAVA 中有接口这个概念，更容易理解）<br><img src="https://blog-1251678165.cos.ap-chengdu.myqcloud.com/9oBm7t.jpg"></li></ul><blockquote><ul><li>注：最终代码中，实现关系表现为<em>继承抽象类</em></li></ul></blockquote><h3 id="3-聚合关系-aggregation"><a href="#3-聚合关系-aggregation" class="headerlink" title="3.聚合关系(aggregation)"></a>3.聚合关系(aggregation)</h3><ul><li>聚合关系用一条带空心菱形箭头的直线表示，如下图表示 A 聚合到 B 上，或者说 B 由 A 组成<br><img src="https://blog-1251678165.cos.ap-chengdu.myqcloud.com/o52AIJ.jpg"></li><li>聚合关系用于表示实体对象之间的关系，表示整体由部分构成的语义；例如一个部门由多个员工组成</li><li>与组合关系不同的是，整体和部分不是强依赖的，即使整体不存在了，部分仍然存在；例如， 部门撤销了，人员不会消失，他们依然存在</li></ul><h3 id="4-组合关系-composition"><a href="#4-组合关系-composition" class="headerlink" title="- 4.组合关系(composition)"></a>- 4.组合关系(composition)</h3><ul><li>组合关系用一条带实心菱形箭头直线表示，如下图表示 A 组成 B，或者 B 由 A 组成<br><img src="https://blog-1251678165.cos.ap-chengdu.myqcloud.com/PZnMM8.jpg"></li><li>与聚合关系相比相同之处：同样表示整体由部分构成的语义；比如公司由多个部门组成</li><li>但组合关系是一种强依赖的特殊聚合关系，如果整体不存在了，则部分也不存在了；例如， 公司不存在了，部门也将不存在了</li></ul><h3 id="5-关联关系-association"><a href="#5-关联关系-association" class="headerlink" title="5.关联关系(association)"></a>5.关联关系(association)</h3><ul><li>关联关系是用一条直线表示的；它描述不同类的对象之间的结构关系；它是一种静态关系， 通常与运行状态无关，一般由常识等因素决定的；它一般用来定义对象之间静态的、天然的结构； 所以，关联关系是一种“强关联”的关系</li><li>例如：乘车人和车票之间就是一种关联关系；主板和 PC 主机之间的一种关联关系</li><li>关联关系默认不强调方向，表示对象间相互知道；如果特别强调方向，如下图，表示 A 知道 B，但 B 不知道 A<br><img src="https://blog-1251678165.cos.ap-chengdu.myqcloud.com/GvpcSE.jpg"></li></ul><blockquote><ul><li>注：在最终代码中，关联对象通常是<em>以成员变量的形式实现的</em></li></ul></blockquote><h3 id="6-依赖关系-dependency"><a href="#6-依赖关系-dependency" class="headerlink" title="6.依赖关系(dependency)"></a>6.依赖关系(dependency)</h3><ul><li>依赖关系是用一套带箭头的虚线表示的；如下图表示 A 依赖于 B；他描述一个对象在运行期间会用到另一个对象的关系<br><img src="https://blog-1251678165.cos.ap-chengdu.myqcloud.com/eKl57t.jpg"></li><li>与关联关系不同的是，它是一种临时性的关系，通常在运行期间产生，并且随着运行时的变化； 依赖关系也可能发生变化</li><li>依赖也有方向，其中双向依赖是一种非常糟糕的结构，一般都应该只保持单向依赖</li></ul><blockquote><ul><li>注：在最终代码中，依赖关系体现为<em>类构造方法及类方法的传入参数</em>，箭头的指向为调用关系；依赖关系处理临时知道对方外，还是“使用”对方的方法和属性</li></ul></blockquote><h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><ul><li>为了展示对象之间的交互细节，后续对设计模式解析的章节，都会用到时序图；</li><li>时序图（Sequence Diagram）是显示对象之间交互的图，这些对象是按时间顺序排列的。时序图中显示的是参与交互的对象及其对象之间消息交互的顺序。</li><li>时序图包括的建模元素主要有：对象（Actor）、生命线（Lifeline）、控制焦点（Focus of control）、消息（Message）等等。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html">看懂 UML 类图和时序图</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> DesignPattern </tag>
            
            <tag> UML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android面试要点总结</title>
      <link href="20160715/interview-android-summary/"/>
      <url>20160715/interview-android-summary/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Android-面试要点总结"><a href="#Android-面试要点总结" class="headerlink" title="Android 面试要点总结"></a>Android 面试要点总结</h1><h2 id="1-Java-技术"><a href="#1-Java-技术" class="headerlink" title="1.Java 技术"></a>1.Java 技术</h2><ul><li><p>1.1 Java 基础<br>_ 对象、继承、多态理解<br>_ 泛型作用及使用场景<br>_ 枚举的特点及使用场景<br>_ 线程 sleep 和 wait 的区别<br>_ Java 反射机制<br>_ weak/soft/strong 的区别 * Object 的 hasCode()与 equals()的区别和作用</p><a id="more"></a></li><li><p>1.2 集合类</p><ul><li>Java 常用集合类、区别和性能</li><li>并发相关集合类</li><li>部分常用集合类的内部实现方式</li></ul></li><li><p>1.3 多线程相关</p><ul><li>Thread、Runable、Callable、Futrue 类关系和区别</li><li>JDK 中默认提供哪些线程池，有何区别</li><li>线程同步有几种方式，分别阐述在项目中的用法</li><li>在理解默认线程池前提下，自己实现线程池</li></ul></li><li><p>1.4 字符</p><ul><li>注解的使用</li><li>注解的级别及意义</li><li>如何自定义注解</li></ul></li></ul><h2 id="2-Android-技术"><a href="#2-Android-技术" class="headerlink" title="2.Android 技术"></a>2.Android 技术</h2><ul><li><p>2.1 Android 基础</p><ul><li>四大组件的意义及使用，生命周期回调及意义</li><li>AsynTask、Handle 的使用</li><li>Android 系统层次框架结构</li><li>AsynTask 的实现方式</li><li>AsynTask 使用的时候应该注意什么</li><li>Android 常见的存储方式</li><li>Looper、Handler 和 MessageQueue 的关系</li><li>Activity 的启动流程（考察队 Framework 的熟悉程度）、</li><li>多进程开发注意事项（Application 类区分进程，进程间内存不可见、进程间通讯方式）</li></ul></li><li><p>2.2 Resource 相关</p><ul><li>.9 图片的意义</li><li>style 和 theme 的作用和用法</li><li>dpi、sp、px 的区别以及转换关系</li><li>raw 和 assets 的文件夹作用，二者的区别</li><li>Android 系统如何在多个资源文件夹下查找匹配最合适的资源</li></ul></li><li><p>2.3 虚拟机</p><ul><li>Java 内存模型</li><li>Android 虚拟机特点</li><li>Dalvik 和 Art 的区别</li><li>熟悉垃圾回收的实现机制，了解虚拟机的 GC 类型</li></ul></li><li><p>2.4 View 相关</p><ul><li>常用组件的使用：ListView、RecyclerView 及 Adapter 的使用</li><li>View 之间的继承关系</li><li>Invalidate 与 postInvalidate 的区别</li><li>自定义 View 的实现方式（根据项目经验询问相关条件）</li><li>onMeasure/onLayout/onDraw 的作用</li><li>Paint、Matrix、Shader 等绘制相关类的方法作用</li><li>详细描述事件分发机制</li></ul></li><li><p>2.5 动画</p><ul><li>Android 动画的实现方式</li><li>Interpolatio 类的意义和常用的 Interpolator</li><li>ViewAnimation 与属性动画有什么区别</li><li>如何自定义 ViewAnimation</li><li>属性动画的实现原理</li></ul></li><li><p>2.6 图片处理</p><ul><li>一般图片中如何加载大图</li><li>图片压缩方式</li><li>如何不压缩图片加载高清图</li><li>图片加载过程中，一般会使用缓存，这个缓存的主要作用是什么</li><li>谈谈自己熟悉的图片加载框架</li></ul></li></ul><h2 id="3-项目经验"><a href="#3-项目经验" class="headerlink" title="3.项目经验"></a>3.项目经验</h2><ul><li><p>3.1 开发工具</p><ul><li>代码管理工具：SVN、Git</li><li>常用调试工具：Hierarchy Viewer、 DDMS 等</li><li>CI 工具：Lint 检查，Findbugs，Jenkins</li><li>内存分析工具：dumpsys、memoinfo、MAT</li></ul></li><li><p>3.2 项目工程</p><ul><li>APP 更新策略：推送/拉取</li><li>如何统一处理错误* 如何收集用户行为</li><li>日志管理有哪些要点？(Debug 包开放，release 包关闭，错误日志反馈)</li><li>打包方式 Ant、Maven、Gradle</li><li>机型适配情况</li></ul></li><li><p>3.3 开发平台</p><ul><li>是否使用过第三方平台</li><li>常用开放平台的熟悉度(微信、QQ、微博、支付宝等常用的支付和分享)</li><li>是否进行过对第三方平台的统一封装？</li><li>是否自己开发过 SDK？</li></ul></li><li><p>3.4 设计相关</p><ul><li>有哪些常用的设计模式、设计原则</li><li>设计模式在 Android 源码中的应用</li><li>设计模式在项目中的应用</li><li>项目中的分包方式</li><li>MVC 在 android 中的应用，利弊</li><li>android 项目中的常见层次结构,包划分</li><li>有没有设计过项目中的层级结构、包划分</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Java </tag>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Studio开发插件</title>
      <link href="20160225/as-plugins/"/>
      <url>20160225/as-plugins/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Android-Studio-开发插件"><a href="#Android-Studio-开发插件" class="headerlink" title="Android Studio 开发插件"></a>Android Studio 开发插件</h1><h2 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h2><ul><li><input checked="" disabled="" type="checkbox"> .ignore</li><li><input checked="" disabled="" type="checkbox"> ADB Idea</li><li><input checked="" disabled="" type="checkbox"> ADB WIFI</li><li><input checked="" disabled="" type="checkbox"> Alibaba Java Coding Guidelines</li><li><input disabled="" type="checkbox"> Android Drawable Importer</li><li><input checked="" disabled="" type="checkbox"> Android Material Design Icon Generator</li><li><input checked="" disabled="" type="checkbox"> Android Parcelable code generator</li><li><input disabled="" type="checkbox"> Background Image Plus</li><li><input disabled="" type="checkbox"> CodeGlance</li><li><input disabled="" type="checkbox"> CSV Plugin</li><li><input checked="" disabled="" type="checkbox"> Dart</li><li><input checked="" disabled="" type="checkbox"> EventBus3 Intellij Plugin</li><li><input disabled="" type="checkbox"> FindBus-IDEA</li><li><input checked="" disabled="" type="checkbox"> Flutter</li><li><input checked="" disabled="" type="checkbox"> Flutter Snippets</li><li><input checked="" disabled="" type="checkbox"> FlutterJsonBeanFactory</li><li><input checked="" disabled="" type="checkbox"> GenerateSerialVersionUID</li><li><input checked="" disabled="" type="checkbox"> Git Commit Template</li><li><input disabled="" type="checkbox"> Grep Console</li><li><input checked="" disabled="" type="checkbox"> Gson Format</li><li><input checked="" disabled="" type="checkbox"> JSON To Kotlin Class (JsonToKotlinClass)</li><li><input disabled="" type="checkbox"> Key Promoter X</li><li><input checked="" disabled="" type="checkbox"> Kotlin</li><li><input checked="" disabled="" type="checkbox"> Lifecycle Sorter</li><li><input checked="" disabled="" type="checkbox"> Markdown</li><li><input checked="" disabled="" type="checkbox"> Material Theme UI</li><li><input checked="" disabled="" type="checkbox"> MultiTypeTemplates</li><li><input disabled="" type="checkbox"> Rainbow Brackets</li><li><input disabled="" type="checkbox"> Rainbow CSV</li><li><input disabled="" type="checkbox"> Rainglow Color Schemes</li><li><input checked="" disabled="" type="checkbox"> RegexpTester</li><li><input checked="" disabled="" type="checkbox"> String Manipulation</li><li><input checked="" disabled="" type="checkbox"> Translation</li></ul><h2 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h2><p>打开 Preference&gt;Plugins&gt;Browse Repositories 在线安装即可</p><h2 id="安装示例"><a href="#安装示例" class="headerlink" title="安装示例"></a>安装示例</h2><p><img src="https://blog-1251678165.cos.ap-chengdu.myqcloud.com/14vtkn.png"><br><img src="https://blog-1251678165.cos.ap-chengdu.myqcloud.com/6SaknN.png"><br><img src="https://blog-1251678165.cos.ap-chengdu.myqcloud.com/118Qxz.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac OS X 终端命令学习</title>
      <link href="20151229/mac-terminalusing/"/>
      <url>20151229/mac-terminalusing/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Mac-OS-X-终端命令学习"><a href="#Mac-OS-X-终端命令学习" class="headerlink" title="Mac OS X 终端命令学习"></a>Mac OS X 终端命令学习</h1><ol><li>显示当前目录的路径</li></ol><ul><li>pwd<a id="more"></a></li></ul><ol start="2"><li>列出文件</li></ol><ul><li>ls 参数 目录名</li><li>参数: -w 显示中文，-l 详细信息， -a 包括隐藏文件，每一行开头是 “d” 则为文件夹，开头是 “-” 则为文件。</li><li>例: 看看驱动目录下有什么：<br>ls /System/Library/Extensions</li></ul><ol start="3"><li>打开目录</li></ol><ul><li>cd 目录名</li><li>cd .. ：返回上一级目录</li><li>cd ../.. ：cd ../.. /..：返回上两级/三级目录</li><li>cd . ：当前目录</li><li>例：想到驱动目录下溜达一圈：<br>cd /System/Library/Extensions</li></ul><ol start="4"><li>建立新目录</li></ol><ul><li>mkdir 目录名</li><li>例：在驱动目录下建一个备份目录<br>backup：mkdir/System/Library/Extensions/backup</li></ul><ol start="5"><li>新建文件</li></ol><ul><li>touch 文件名</li><li>例：在当前目录下建一个备份文件 backup：<br>touch backup.txt</li></ul><ol start="6"><li>拷贝文件</li></ol><ul><li>cp 参数 源文件 目标文件</li><li>例：想把桌面的 Natit.kext 拷贝到驱动目录中<br> cp -R /User/用户名/Desktop/Natit.kext /System/Library/Extensions</li><li>参数 R 表示对目录进行递归操作，kext 在图形界面下看起来是个文件，实际上是个文件夹。</li><li>把驱动目录下的所有文件备份到桌面 backup：<br>cp -R /System/Library/Extensions/ /User/用户名/Desktop/backup</li></ul><ol start="7"><li>删除文件</li></ol><ul><li>rm 参数 文件</li><li>参数－rf 表示递归和强制，千万要小心使用，如果执行了 rm -rf / 你的系统就全没了</li><li>例：想删除驱动的缓存：<code>rm </code>-rf /System/Library/Extensions.kextcache<code> rm -rf /System/Library/Extensions.mkext</code></li></ul><ol start="8"><li>移动文件</li></ol><ul><li>mv 源文件 目标文件</li><li>例：想把 AppleHDA.Kext 移到桌面：<br>mv /System/Library/Extensions/AppleHDA.kext /User/用户名/Desktop</li></ul><ol start="9"><li>文本编辑</li></ol><ul><li>nano 文件名<br>例：编辑 Info.plist：nano /System/Library/Extensions/Natit.kext/Info.plist</li></ul><ol start="10"><li>清屏</li></ol><ul><li>clear</li></ul><ol start="11"><li>目录操作：</li></ol><table><thead><tr><th>命令名</th><th>功能描述</th><th>使用举例</th></tr></thead><tbody><tr><td>mkdir</td><td>创建一个目录</td><td>mkdir dirname</td></tr><tr><td>rmdir</td><td>删除一个目录</td><td>rmdir dirname</td></tr><tr><td>mvdir</td><td>移动或重命名一个目录</td><td>mvdir dir1 dir2</td></tr><tr><td>cd</td><td>改变当前目录</td><td>cd dirname</td></tr><tr><td>pwd</td><td>显示当前目录的路径名</td><td>pwd</td></tr><tr><td>ls</td><td>显示当前目录的内容</td><td>ls -la</td></tr></tbody></table><ol start="12"><li>文件操作：</li></ol><table><thead><tr><th>命令名</th><th>功能描述</th><th>使用举例</th></tr></thead><tbody><tr><td>cat</td><td>显示或连接文件</td><td>cat filename</td></tr><tr><td>od</td><td>显示非文本文件的内容</td><td>od -c filename</td></tr><tr><td>cp</td><td>复制文件或目录</td><td>cp file1 file2</td></tr><tr><td>rm</td><td>删除文件或目录</td><td>rm filename</td></tr><tr><td>mv</td><td>改变文件名或所在目录</td><td>mv file1 file2</td></tr><tr><td>find</td><td>使用匹配表达式查找文件</td><td>find . -name “*.c” -print</td></tr><tr><td>file</td><td>显示文件类型</td><td>file filename</td></tr></tbody></table><ol start="13"><li>选择操作：</li></ol><table><thead><tr><th>命令名</th><th>功能描述</th><th>使用举例</th></tr></thead><tbody><tr><td>head</td><td>显示文件的最初几行</td><td>head -20 filename</td></tr><tr><td>tail</td><td>显示文件的最后几行</td><td>tail -15 filename</td></tr><tr><td>cut</td><td>显示文件每行中的某些域</td><td>cut -f1,7 -d: /etc/passwd</td></tr><tr><td>colrm</td><td>从标准输入中删除若干列</td><td>colrm 8 20 file2</td></tr><tr><td>diff</td><td>比较并显示两个文件的差异</td><td>diff file1 file2</td></tr><tr><td>sort</td><td>排序或归并文件</td><td>sort -d -f -u file1</td></tr><tr><td>uniq</td><td>去掉文件中的重复行</td><td>uniq file1 file2</td></tr><tr><td>comm</td><td>显示两有序文件的公共和非公共行</td><td>comm file1 file2</td></tr><tr><td>wc</td><td>统计文件的字符数、词数和行数</td><td>wc filename</td></tr><tr><td>nl</td><td>给文件加上行号</td><td>nl file1 &gt;file2</td></tr></tbody></table><ol start="14"><li><p>进程操作：</p><table><thead><tr><th>命令名</th><th>功能描述</th><th>使用举例</th></tr></thead><tbody><tr><td>ps</td><td>显示进程当前状态</td><td>ps u</td></tr><tr><td>kill</td><td>终止进程</td><td>kill -9 30142</td></tr></tbody></table></li><li><p>时间操作：</p><table><thead><tr><th>命令名</th><th>功能描述</th><th>使用举例</th></tr></thead><tbody><tr><td>date</td><td>显示系统的当前日期和时间</td><td>date</td></tr><tr><td>cal</td><td>显示日历</td><td>cal 8 1996</td></tr><tr><td>time</td><td>统计程序的执行时间</td><td>time a.out</td></tr></tbody></table></li><li><p>网络与通信操作：</p><table><thead><tr><th>命令名</th><th>功能描述</th><th>使用举例</th></tr></thead><tbody><tr><td>telnet</td><td>远程登录</td><td>telnet hpc.sp.net.edu.cn</td></tr><tr><td>rlogin</td><td>远程登录</td><td>rlogin hostname -l username</td></tr><tr><td>rsh</td><td>在远程主机执行指定命令</td><td>rsh f01n03 date</td></tr><tr><td>ftp</td><td>在本地主机与远程主机之间传输文件</td><td>ftpftp.sp.net.edu.cn</td></tr><tr><td>rcp</td><td>在本地主机与远程主机 之间复制文件</td><td>rcp file1 host1:file2</td></tr><tr><td>ping</td><td>给一个网络主机发送 回应请求</td><td>ping hpc.sp.net.edu.cn</td></tr><tr><td>mail</td><td>阅读和发送电子邮件</td><td>mail</td></tr><tr><td>write</td><td>给另一用户发送报文</td><td>write username pts/1</td></tr><tr><td>mesg</td><td>允许或拒绝接收报文</td><td>mesg n</td></tr></tbody></table></li><li><p>Korn Shell 命令：</p><table><thead><tr><th>命令名</th><th>功能描述</th><th>使用举例</th></tr></thead><tbody><tr><td>history</td><td>列出最近执行过的 几条命令及编号</td><td>history</td></tr><tr><td>r</td><td>重复执行最近执行过的 某条命令</td><td>r -2</td></tr><tr><td>alias</td><td>给某个命令定义别名</td><td>alias del=rm -i</td></tr><tr><td>unalias</td><td>取消对某个别名的定义</td><td>unalias del</td></tr></tbody></table></li><li><p>其它命令：</p><table><thead><tr><th>命令名</th><th>功能描述</th><th>使用举例</th></tr></thead><tbody><tr><td>uname</td><td>显示操作系统的有关信息</td><td>uname -a</td></tr><tr><td>clear</td><td>清除屏幕或窗口内容</td><td>clear</td></tr><tr><td>env</td><td>显示当前所有设置过的环境变量</td><td>env</td></tr><tr><td>who</td><td>列出当前登录的所有用户</td><td>who</td></tr><tr><td>whoami</td><td>显示当前正进行操作的用户名</td><td>whoami</td></tr><tr><td>tty</td><td>显示终端或伪终端的名称</td><td>tty</td></tr><tr><td>stty</td><td>显示或重置控制键定义</td><td>stty -a</td></tr><tr><td>du</td><td>查询磁盘使用情况</td><td>du -k subdir</td></tr><tr><td>df</td><td>显示文件系统的总空间和可用空间</td><td>df</td></tr><tr><td>w</td><td>显示当前系统活动的总信息</td><td>w</td></tr></tbody></table></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> macOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HexoBlog搭建</title>
      <link href="20151124/hexo-blog-build/"/>
      <url>20151124/hexo-blog-build/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="HexoBlog-搭建"><a href="#HexoBlog-搭建" class="headerlink" title="HexoBlog 搭建"></a>HexoBlog 搭建</h1><p>更详细教程参考：<a href="https://easyhexo.com/">https://easyhexo.com/</a></p><h2 id="一-环境搭建"><a href="#一-环境搭建" class="headerlink" title="一.环境搭建"></a>一.环境搭建</h2><h3 id="1-安装-git"><a href="#1-安装-git" class="headerlink" title="1. 安装 git"></a>1. 安装 git</h3><pre><code>- Mac OSX下:安装Xcode即可/或者安装命令行工具- Windows下:安装git bash</code></pre><a id="more"></a><h3 id="2-安装-node-js"><a href="#2-安装-node-js" class="headerlink" title="2. 安装 node.js"></a>2. 安装 node.js</h3><ul><li><p>1）Mac OSX 下:首先安装 Ruby 环境，然后安装 HomeBrew（详情 Google）</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ruby -e "$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)”<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>2）使用 Homebrew 安装 Node.js (注意检查 Node 版本，截止 2020.05.12 14.x 版本 会导致 hexo 部署出错)</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ brew update$ brew install node<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>3）Windows/OSX 下也可以进入<a href="https://nodejs.org/en/">Node.js 官网</a>下载安装包安装</p></li><li><p>4）一般 Node modules 通常被安装在每个项目的本地文件夹 node_modules，Npm 使用(更详细的命令操作参考百度/Google)</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ npm install &lt;package&gt;     # 安装在本地项目中$ npm install -g &lt;package&gt;  # 安装在全局<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h2 id="二-安装-Hexo（参考Hexo）"><a href="#二-安装-Hexo（参考Hexo）" class="headerlink" title="二.安装 Hexo（参考Hexo）"></a>二.安装 Hexo（参考<a href="https://hexo.io/">Hexo</a>）</h2><h3 id="1-初始化和安装"><a href="#1-初始化和安装" class="headerlink" title="1. 初始化和安装"></a>1. 初始化和安装</h3><p>在 Finder 中建立新的文件夹 Hexo，cd 进入这个目录下(推荐使用 iTerm2)进行操作</p><pre><code><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ cd /Users/weico/Hexo#这是我的电脑$ npm install hexo-cli -g$ hexo init blog$ cd blog$ npm install$ hexo g    #生成静态博客$ hexo s#也可以指定端口$ hexo server -p 5000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></code></pre><h3 id="2-Hexo-简单使用"><a href="#2-Hexo-简单使用" class="headerlink" title="2. Hexo 简单使用"></a>2. Hexo 简单使用</h3><ul><li><p>1）常用命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new "postName" #新建文章$ hexo new page "pageName" #新建页面$ hexo generate #生成静态页面至public目录$ hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）$ hexo deploy #将.deploy目录部署到GitHub$ hexo help  # 查看帮助$ hexo version  #查看Hexo的版本<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>2）复合命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy -g  #生成加部署$ hexo server -g  #生成加预览$ hexo cl &amp;&amp; hexo g &amp;&amp; hexo d &amp;&amp; hexo cl<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>3）命令简写</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo n == hexo new$ hexo g == hexo generate$ hexo s == hexo server$ hexo d == hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="3-部署到-GitHub"><a href="#3-部署到-GitHub" class="headerlink" title="3. 部署到 GitHub"></a>3. 部署到 GitHub</h3><ul><li>1）首先设置你的用户名密码<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ git config --global user.email "bu.ru@qq.com"$ git config --global user.name "bruce-sha"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>2）生成密钥<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ssh-keygen -t rsa -C "bu.ru@qq.com"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>3）到/Users/用户名/.ssh 下打开.pub 文件将其添加到 Github 上的 SSH Key</li><li>4）执行 npm install hexo-deployer-git –save ## 安装部署所需要的插件</li><li>5）部署到 Github 前需要配置_config.yml 文件，首先找到下面的内容<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"># Deployment## Docs: http://hexo.io/docs/deployment.htmldeploy:  type:# 将上面内容修改为：# Deployment## Docs: http://hexo.io/docs/deployment.htmldeploy:  type: git#这里使用git，而不使用github  repository: git@github.com:lecymeng/lecymeng.github.io.git#这是我的Github账户  branch: master#部署分支<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="4-插件安装"><a href="#4-插件安装" class="headerlink" title="4. 插件安装"></a>4. 插件安装</h3><ul><li><p>1）sitemap 插件安装、使用-可以将你站点地图提交给搜索引擎，文件路径\sitemap.xml</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ npm install hexo-generator-sitemap<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"># ExtensionsPlugins:- hexo-generator-sitemap#sitemapsitemap:  path: sitemap.xml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>2）feed 插件安装、使用-RSS 的生成插件，你可以在配置显示你站点的 RSS，文件路径\atom.xml</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ npm install hexo-generator-feed<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"># ExtensionsPlugins:- hexo-generator-feed- hexo-generator-sitemap#Feed Atomfeed:  type: atom  path: atom.xml  limit: 20<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="5-公益-404-页面"><a href="#5-公益-404-页面" class="headerlink" title="5. 公益 404 页面"></a>5. 公益 404 页面</h3><ul><li>腾讯公益 404 页面-在主题的 source 目录下创建 404.html，内容如下<pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>content-type<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/html;charset=utf-8;<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>IE=edge,chrome=1<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>robots<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>all<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>robots<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>index,follow<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span>      <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span>      <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.qq.com/404/search_children.js<span class="token punctuation">"</span></span>      <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>utf-8<span class="token punctuation">"</span></span>      <span class="token attr-name">homePageUrl</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>your site url <span class="token punctuation">"</span></span>      <span class="token attr-name">homePageName</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>回到我的主页<span class="token punctuation">"</span></span>    <span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="6-主体选择和配置"><a href="#6-主体选择和配置" class="headerlink" title="6. 主体选择和配置"></a>6. 主体选择和配置</h3><p>GitHub 或者在官网可以找到很多很漂亮的主题，安装对应的文档进行配置即可</p><p>也可以参考 <a href="https://easyhexo.com/">https://easyhexo.com/</a> 里面所罗列到的主题，都是非常不错的</p><h3 id="7-Q-amp-A"><a href="#7-Q-amp-A" class="headerlink" title="7. Q &amp; A"></a>7. Q &amp; A</h3><ul><li><p>1）hexo ERROR Deployer not found: github，不能部署到 github。</p><pre class="line-numbers language-none"><code class="language-none">解决办法：1.安装 npm install hexo-deployer-git –save；2.将Hexo的配置文件_config.yml中的deploy 的 type由github改为git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>2）生成 SSH key 时，在那个目录下执行的 ssh-keygen -t rsa -C “<a href="mailto:xxxx@xxxx.com">xxxx@xxxx.com</a>”就会在那生成.pub 文件，并不是在.ssh 里面 QAQ</p></li><li><p>3）SSH 无法连接到 GitHub 时，尝试 ssh-add ~/.ssh/私钥文件名</p></li><li><p>4）安装的时候最好加上 sudo</p></li></ul><h2 id="Hexo-自动构建-By-Travis"><a href="#Hexo-自动构建-By-Travis" class="headerlink" title="Hexo 自动构建 By Travis"></a>Hexo 自动构建 By Travis</h2><h3 id="配置-GitHub-Token"><a href="#配置-GitHub-Token" class="headerlink" title="配置 GitHub Token"></a>配置 GitHub Token</h3><p>如果需要使用 travis 自动化构建你的博客，travis 自然需要读写你的 GitHub 上的 Repo。GitHub 提供了 token 机制来供外部访问你的仓库。</p><p>进入<a href="https://github.com/settings/tokens">github.com/settings/tokens</a>，生成一个供 travis 读写你的 GitHub 用的 token，至于 token 的权限，不会的直接全选了，但是不建议这样做，风险比较大，或者选择能够访问和提交仓库代码的权限即可，token 注意保密，待会会用到。<br><img src="https://blog-1251678165.cos.ap-chengdu.myqcloud.com/2020-05-12/15892123178972.jpg" alt="-w1028"></p><h3 id="配置-Travis-CI"><a href="#配置-Travis-CI" class="headerlink" title="配置 Travis-CI"></a>配置 Travis-CI</h3><p>使用 GitHub 账号登陆 travis，在 travis 进入仓库同步管理进入 travis-ci.org/profile，打开刚才托管的 hexo 博客源码仓库同步开关<br><img src="https://blog-1251678165.cos.ap-chengdu.myqcloud.com/2020-05-12/15892124687030.jpg" alt="-w682"></p><p>进入设置页，设置自动化编译时机，自动化编译过程中需要用到的变量。<br><img src="https://blog-1251678165.cos.ap-chengdu.myqcloud.com/2020-05-12/15892127916778.jpg" alt="-w1015"><br><img src="https://blog-1251678165.cos.ap-chengdu.myqcloud.com/2020-05-12/15892128991659.jpg" alt="-w1171"></p><p>添加必要的 Shell 变量<br><img src="https://blog-1251678165.cos.ap-chengdu.myqcloud.com/2020-05-12/15892129715179.jpg" alt="-w1475"><br>记住 NAME 在配置 travis.yml 会用到</p><h3 id="编写-travis-yml-文件"><a href="#编写-travis-yml-文件" class="headerlink" title="编写.travis.yml 文件"></a>编写.travis.yml 文件</h3><p>.travis.yml 是 travis 平台进行自动化构建的配置文件，travis 会根据配置文件生成一个 shell 自动化脚本。</p><p>进入 hexo 博客源码本地 repo</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd hexotouch .travis.ymlvim .travis.yml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"># 指定构建环境是Node.jslanguage: node_js# 指定版本，当前最新版14.x会导致hexo部署失败，改为12.16node_js:  - 12.16.3# 指定需要sudo权限sudo: required# 设置缓存文件cache:  directories:    - node_modules# 设置钩子只检测hexo分支的push变动branches:  only:    - hexo# 在构建之前安装hexo环境before_install:  - npm install -g hexo-cli# 安装git插件和搜索功能插件install:  - npm install  - npm install hexo-deployer-git --save# 执行清缓存，生成网页操作script:  - hexo clean  - hexo generate# 设置git提交名，邮箱；替换真实token到_config.yml文件，最后depoy部署after_script:  - git config user.name "lecymeng"  - git config user.email "1570682285@qq.com"  # 替换同目录下的 `_config.yml` 文件中 `github_token` 字符串为travis后台刚才配置的变量，注意&gt;此处sed命令用了双引号，单引号无效  - sed -i "s/github_token/${GITHUB_TOKEN}/g" ./_config.yml  - sed -i "s/coding_token/${CODING_TOKEN}/g" ./_config.yml  - sed -i "s/phone_number/${CODING_NUMBER}/g" ./_config.yml  - hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改下_config.yml 文件的 deploy 节点：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"># 修改前deploy:  - type: git    repo: git@github.com:userName/RepoName.git    branch: master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">deploy:  - type: git    # github_token 会被 .travis.yml 中sed命令替换    repo: https://github_token@github.com/lecymeng/lecymeng.github.io.git    branch: master  - type: git    # 新的e.coding 只能用电话和邮箱，不能使用账户名，邮箱带@字符会导致Git链接识别错误    repo: https://phone_number:coding_token@e.coding.net/weicools/Weicools.git    branch: master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="配置参考"><a href="#配置参考" class="headerlink" title="配置参考"></a>配置参考</h3><ul><li><a href="https://michael728.github.io/2019/06/16/cicd-hexo-blog-travis/">https://michael728.github.io/2019/06/16/cicd-hexo-blog-travis/</a></li><li><a href="http://duansm.top/2018/08/05/hexo-travis/">http://duansm.top/2018/08/05/hexo-travis/</a></li><li><a href="https://juejin.im/post/5a1fa30c6fb9a045263b5d2a">https://juejin.im/post/5a1fa30c6fb9a045263b5d2a</a></li><li><a href="https://github.com/xiong-it/xiong-it.github.io/blob/hexo/.travis.yml">https://github.com/xiong-it/xiong-it.github.io/blob/hexo/.travis.yml</a></li><li><a href="https://github.com/xiong-it/xiong-it.github.io/blob/hexo/_config.yml">https://github.com/xiong-it/xiong-it.github.io/blob/hexo/_config.yml</a></li></ul><h2 id="双线部署-GitHub-Coding"><a href="#双线部署-GitHub-Coding" class="headerlink" title="双线部署 GitHub+Coding"></a>双线部署 GitHub+Coding</h2><p>hexo deploy 时(由于部署的环境上没有配置 SSH)，所以需要使用 https+TOKEN 模式 实现更快部署<br>GitHub 格式：<a href="https://github_token@github.com/useName/RepoName.git">https://github_token@github.com/useName/RepoName.git</a><br>Coding 格式：https://[phone_number]:[coding_token/coding_password]@e.coding.net/useName/RepoName.git</p><blockquote><p>coding_password 不能带有@ 否则会导致 GitUrl 识别错误</p></blockquote><h3 id="开启-Coding-Page"><a href="#开启-Coding-Page" class="headerlink" title="开启 Coding Page"></a>开启 Coding Page</h3><p>打开仓库设置，打开持续集成和持续部署<br><img src="https://blog-1251678165.cos.ap-chengdu.myqcloud.com/2020-05-12/15892135165321.jpg" alt="-w1760"><br>然后打开持续部署中的静态网站，点击立即部署，就会得到一个 coding 的博客网址<br><img src="https://blog-1251678165.cos.ap-chengdu.myqcloud.com/2020-05-12/15892136176032.jpg" alt="-w1893"><br>然后点击设置，配置域名，配置之前需要先在域名解析中添加 CNAME 解析道 Coding 的博客地址例如：<a href="https://030dsd.coding-pages.com/">https://xxxx.coding-pages.com</a>，注意如果有 GitHub 的解析的话需要先删除，否则无法开启 https。(Coding Pages 申请 SSL/TLS 安全证书出现以下错误：urn:acme:error:unauthorized: Invalid response from <a href="http://www.xxxx.cn/.well-known/acme-challenge/ysOz9wW3U_GFPP8kRP4w8uknBZ9UfiUT7t2xpu9pDCw">http://www.xxxx.cn/.well-known/acme-challenge/ysOz9wW3U_GFPP8kRP4w8uknBZ9UfiUT7t2xpu9pDCw</a> [185.199.111.153]: ，因为这种情况下，在验证域名所有权时会定位到 Github Pages 的主机上导致 SSL 证书申请失败)<br><img src="https://blog-1251678165.cos.ap-chengdu.myqcloud.com/141psU.png" alt="141psU"><br>配置好域名解析之后，在 Coding 中绑定域名，然后强制开启 https，开启成功后再去配置 GitHub 的解析<br><img src="https://blog-1251678165.cos.ap-chengdu.myqcloud.com/2020-05-12/15892138072661.jpg" alt="-w1578"></p><h3 id="双线部署参考"><a href="#双线部署参考" class="headerlink" title="双线部署参考"></a>双线部署参考</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/111608743?from_voters_page=true">新版 coding-page 与 Gridea 免费搭建个人博客</a></li><li><a href="https://www.cnblogs.com/sunhang32/p/11969964.html">加速自己的 hexo，使用 GitHub+Coding 实现国内外网站加速</a></li><li><a href="https://huaien.co/technology/enable-https-on-coding-pages/">给托管在 Coding Pages 上的博客开启 HTTPS 支持 申请失败的原因</a></li><li><a href="https://www.cnblogs.com/TRHX/p/11699949.html">Coding Pages 申请 SSL 证书错误</a></li></ul><h2 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h2><ul><li><a href="https://easyhexo.com/">https://easyhexo.com/</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
